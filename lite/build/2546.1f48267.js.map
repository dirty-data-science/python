{"version":3,"file":"2546.1f48267.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../../src/kernel/serialize.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/src/kernel.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/async-mutex/index.mjs","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/src/kernels.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/src/tokens.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/src/kernelspecs.ts"],"sourcesContent":[null,"import { KernelMessage } from '@jupyterlab/services';\n\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { IKernel } from './tokens';\n\n/**\n * A base kernel class handling basic kernel messaging.\n */\nexport abstract class BaseKernel implements IKernel {\n  /**\n   * Construct a new BaseKernel.\n   *\n   * @param options The instantiation options for a BaseKernel.\n   */\n  constructor(options: IKernel.IOptions) {\n    const { id, name, location, sendMessage } = options;\n    this._id = id;\n    this._name = name;\n    this._location = location;\n    this._sendMessage = sendMessage;\n  }\n\n  /**\n   * A promise that is fulfilled when the kernel is ready.\n   */\n  get ready(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  /**\n   * Return whether the kernel is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * A signal emitted when the kernel is disposed.\n   */\n  get disposed(): ISignal<this, void> {\n    return this._disposed;\n  }\n\n  /**\n   * Get the kernel id\n   */\n  get id(): string {\n    return this._id;\n  }\n\n  /**\n   * Get the name of the kernel\n   */\n  get name(): string {\n    return this._name;\n  }\n\n  /**\n   * The location in the virtual filesystem from which the kernel was started.\n   */\n  get location(): string {\n    return this._location;\n  }\n\n  /**\n   * The current execution count\n   */\n  get executionCount(): number {\n    return this._executionCount;\n  }\n\n  /**\n   * Get the last parent header\n   */\n  get parentHeader(): KernelMessage.IHeader<KernelMessage.MessageType> | undefined {\n    return this._parentHeader;\n  }\n\n  /**\n   * Get the last parent message (mimic ipykernel's get_parent)\n   */\n  get parent(): KernelMessage.IMessage | undefined {\n    return this._parent;\n  }\n\n  /**\n   * Dispose the kernel.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n    this._disposed.emit(void 0);\n  }\n\n  /**\n   * Handle an incoming message from the client.\n   *\n   * @param msg The message to handle\n   */\n  async handleMessage(msg: KernelMessage.IMessage): Promise<void> {\n    this._busy(msg);\n\n    this._parent = msg;\n\n    const msgType = msg.header.msg_type;\n    switch (msgType) {\n      case 'kernel_info_request':\n        await this._kernelInfo(msg);\n        break;\n      case 'execute_request':\n        await this._execute(msg);\n        break;\n      case 'input_reply':\n        this.inputReply(msg.content as KernelMessage.IInputReplyMsg['content']);\n        break;\n      case 'inspect_request':\n        await this._inspect(msg);\n        break;\n      case 'is_complete_request':\n        await this._isCompleteRequest(msg);\n        break;\n      case 'complete_request':\n        await this._complete(msg);\n        break;\n      case 'history_request':\n        await this._historyRequest(msg);\n        break;\n      case 'comm_open':\n        await this.commOpen(msg as KernelMessage.ICommOpenMsg);\n        break;\n      case 'comm_msg':\n        await this.commMsg(msg as KernelMessage.ICommMsgMsg);\n        break;\n      case 'comm_close':\n        await this.commClose(msg as KernelMessage.ICommCloseMsg);\n        break;\n      default:\n        break;\n    }\n\n    this._idle(msg);\n  }\n\n  /**\n   * Handle a `kernel_info_request` message.\n   *\n   * @returns A promise that resolves with the kernel info.\n   */\n  abstract kernelInfoRequest(): Promise<KernelMessage.IInfoReplyMsg['content']>;\n\n  /**\n   * Handle an `execute_request` message.\n   *\n   * @param content - The content of the execute_request kernel message\n   */\n  abstract executeRequest(\n    content: KernelMessage.IExecuteRequestMsg['content']\n  ): Promise<KernelMessage.IExecuteReplyMsg['content']>;\n\n  /**\n   * Handle a `complete_request` message.\n   *\n   * @param content - The content of the request.\n   */\n  abstract completeRequest(\n    content: KernelMessage.ICompleteRequestMsg['content']\n  ): Promise<KernelMessage.ICompleteReplyMsg['content']>;\n\n  /**\n   * Handle an `inspect_request` message.\n   *\n   * @param content - The content of the request.\n   *\n   * @returns A promise that resolves with the response message.\n   */\n  abstract inspectRequest(\n    content: KernelMessage.IInspectRequestMsg['content']\n  ): Promise<KernelMessage.IInspectReplyMsg['content']>;\n\n  /**\n   * Handle an `is_complete_request` message.\n   *\n   * @param content - The content of the request.\n   *\n   * @returns A promise that resolves with the response message.\n   */\n  abstract isCompleteRequest(\n    content: KernelMessage.IIsCompleteRequestMsg['content']\n  ): Promise<KernelMessage.IIsCompleteReplyMsg['content']>;\n\n  /**\n   * Handle a `comm_info_request` message.\n   *\n   * @param content - The content of the request.\n   *\n   * @returns A promise that resolves with the response message.\n   */\n  abstract commInfoRequest(\n    content: KernelMessage.ICommInfoRequestMsg['content']\n  ): Promise<KernelMessage.ICommInfoReplyMsg['content']>;\n\n  /**\n   * Send an `input_reply` message.\n   *\n   * @param content - The content of the reply.\n   */\n  abstract inputReply(content: KernelMessage.IInputReplyMsg['content']): void;\n\n  /**\n   * Send an `comm_open` message.\n   *\n   * @param msg - The comm_open message.\n   */\n  abstract commOpen(msg: KernelMessage.ICommOpenMsg): Promise<void>;\n\n  /**\n   * Send an `comm_msg` message.\n   *\n   * @param msg - The comm_msg message.\n   */\n  abstract commMsg(msg: KernelMessage.ICommMsgMsg): Promise<void>;\n\n  /**\n   * Send an `comm_close` message.\n   *\n   * @param close - The comm_close message.\n   */\n  abstract commClose(msg: KernelMessage.ICommCloseMsg): Promise<void>;\n\n  /**\n   * Stream an event from the kernel\n   *\n   * @param parentHeader The parent header.\n   * @param content The stream content.\n   */\n  protected stream(\n    content: KernelMessage.IStreamMsg['content'],\n    parentHeader:\n      | KernelMessage.IHeader<KernelMessage.MessageType>\n      | undefined = undefined\n  ): void {\n    const parentHeaderValue =\n      typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n    const message = KernelMessage.createMessage<KernelMessage.IStreamMsg>({\n      channel: 'iopub',\n      msgType: 'stream',\n      // TODO: better handle this\n      session: parentHeaderValue?.session ?? '',\n      parentHeader: parentHeaderValue,\n      content,\n    });\n    this._sendMessage(message);\n  }\n\n  /**\n   * Send a `display_data` message to the client.\n   *\n   * @param parentHeader The parent header.\n   * @param content The display_data content.\n   */\n  protected displayData(\n    content: KernelMessage.IDisplayDataMsg['content'],\n    parentHeader:\n      | KernelMessage.IHeader<KernelMessage.MessageType>\n      | undefined = undefined\n  ): void {\n    // Make sure metadata is always set\n    const parentHeaderValue =\n      typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n    content.metadata = content.metadata ?? {};\n\n    const message = KernelMessage.createMessage<KernelMessage.IDisplayDataMsg>({\n      channel: 'iopub',\n      msgType: 'display_data',\n      // TODO: better handle this\n      session: parentHeaderValue?.session ?? '',\n      parentHeader: parentHeaderValue,\n      content,\n    });\n    this._sendMessage(message);\n  }\n\n  /**\n   * Send a `input_request` message to the client.\n   *\n   * @param parentHeader The parent header.\n   * @param content The input_request content.\n   */\n  protected inputRequest(\n    content: KernelMessage.IInputRequestMsg['content'],\n    parentHeader:\n      | KernelMessage.IHeader<KernelMessage.MessageType>\n      | undefined = undefined\n  ): void {\n    const parentHeaderValue =\n      typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n    const message = KernelMessage.createMessage<KernelMessage.IInputRequestMsg>({\n      channel: 'stdin',\n      msgType: 'input_request',\n      // TODO: better handle this\n      session: parentHeaderValue?.session ?? '',\n      parentHeader: parentHeaderValue,\n      content,\n    });\n    this._sendMessage(message);\n  }\n\n  /**\n   * Send an `execute_result` message.\n   *\n   * @param parentHeader The parent header.\n   * @param content The execute result content.\n   */\n  protected publishExecuteResult(\n    content: KernelMessage.IExecuteResultMsg['content'],\n    parentHeader:\n      | KernelMessage.IHeader<KernelMessage.MessageType>\n      | undefined = undefined\n  ): void {\n    const parentHeaderValue =\n      typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n    const message = KernelMessage.createMessage<KernelMessage.IExecuteResultMsg>({\n      channel: 'iopub',\n      msgType: 'execute_result',\n      // TODO: better handle this\n      session: parentHeaderValue?.session ?? '',\n      parentHeader: parentHeaderValue,\n      content,\n    });\n    this._sendMessage(message);\n  }\n\n  /**\n   * Send an `error` message to the client.\n   *\n   * @param parentHeader The parent header.\n   * @param content The error content.\n   */\n  protected publishExecuteError(\n    content: KernelMessage.IErrorMsg['content'],\n    parentHeader:\n      | KernelMessage.IHeader<KernelMessage.MessageType>\n      | undefined = undefined\n  ): void {\n    const parentHeaderValue =\n      typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n    const message = KernelMessage.createMessage<KernelMessage.IErrorMsg>({\n      channel: 'iopub',\n      msgType: 'error',\n      // TODO: better handle this\n      session: parentHeaderValue?.session ?? '',\n      parentHeader: parentHeaderValue,\n      content,\n    });\n    this._sendMessage(message);\n  }\n\n  /**\n   * Send a `update_display_data` message to the client.\n   *\n   * @param parentHeader The parent header.\n   * @param content The update_display_data content.\n   */\n  protected updateDisplayData(\n    content: KernelMessage.IUpdateDisplayDataMsg['content'],\n    parentHeader:\n      | KernelMessage.IHeader<KernelMessage.MessageType>\n      | undefined = undefined\n  ): void {\n    const parentHeaderValue =\n      typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n    const message = KernelMessage.createMessage<KernelMessage.IUpdateDisplayDataMsg>({\n      channel: 'iopub',\n      msgType: 'update_display_data',\n      // TODO: better handle this\n      session: parentHeaderValue?.session ?? '',\n      parentHeader: parentHeaderValue,\n      content,\n    });\n    this._sendMessage(message);\n  }\n\n  /**\n   * Send a `clear_output` message to the client.\n   *\n   * @param parentHeader The parent header.\n   * @param content The clear_output content.\n   */\n  protected clearOutput(\n    content: KernelMessage.IClearOutputMsg['content'],\n    parentHeader:\n      | KernelMessage.IHeader<KernelMessage.MessageType>\n      | undefined = undefined\n  ): void {\n    const parentHeaderValue =\n      typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n    const message = KernelMessage.createMessage<KernelMessage.IClearOutputMsg>({\n      channel: 'iopub',\n      msgType: 'clear_output',\n      // TODO: better handle this\n      session: parentHeaderValue?.session ?? '',\n      parentHeader: parentHeaderValue,\n      content,\n    });\n    this._sendMessage(message);\n  }\n\n  /**\n   * Send a `comm` message to the client.\n   *\n   * @param .\n   */\n  protected handleComm(\n    type: 'comm_close' | 'comm_msg' | 'comm_open',\n    content: KernelMessage.ICommMsgMsg['content'],\n    metadata: KernelMessage.ICommMsgMsg['metadata'],\n    buffers: KernelMessage.ICommMsgMsg['buffers'],\n    parentHeader:\n      | KernelMessage.IHeader<KernelMessage.MessageType>\n      | undefined = undefined\n  ): void {\n    const parentHeaderValue =\n      typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n    const message = KernelMessage.createMessage<any>({\n      channel: 'iopub',\n      msgType: type,\n      // TODO: better handle this\n      session: parentHeaderValue?.session ?? '',\n      parentHeader: parentHeaderValue,\n      content,\n      metadata,\n      buffers,\n    });\n    this._sendMessage(message);\n  }\n\n  /**\n   * Send an 'idle' status message.\n   *\n   * @param parent The parent message\n   */\n  private _idle(parent: KernelMessage.IMessage): void {\n    const message = KernelMessage.createMessage<KernelMessage.IStatusMsg>({\n      msgType: 'status',\n      session: parent.header.session,\n      parentHeader: parent.header,\n      channel: 'iopub',\n      content: {\n        execution_state: 'idle',\n      },\n    });\n    this._sendMessage(message);\n  }\n\n  /**\n   * Send a 'busy' status message.\n   *\n   * @param parent The parent message.\n   */\n  private _busy(parent: KernelMessage.IMessage): void {\n    const message = KernelMessage.createMessage<KernelMessage.IStatusMsg>({\n      msgType: 'status',\n      session: parent.header.session,\n      parentHeader: parent.header,\n      channel: 'iopub',\n      content: {\n        execution_state: 'busy',\n      },\n    });\n    this._sendMessage(message);\n  }\n\n  /**\n   * Handle a kernel_info_request message\n   *\n   * @param parent The parent message.\n   */\n  private async _kernelInfo(parent: KernelMessage.IMessage): Promise<void> {\n    const content = await this.kernelInfoRequest();\n\n    const message = KernelMessage.createMessage<KernelMessage.IInfoReplyMsg>({\n      msgType: 'kernel_info_reply',\n      channel: 'shell',\n      session: parent.header.session,\n      parentHeader: parent.header as KernelMessage.IHeader<'kernel_info_request'>,\n      content,\n    });\n\n    this._sendMessage(message);\n  }\n\n  /**\n   * Handle a `history_request` message\n   *\n   * @param msg The parent message.\n   */\n  private async _historyRequest(msg: KernelMessage.IMessage): Promise<void> {\n    const historyMsg = msg as KernelMessage.IHistoryRequestMsg;\n    const message = KernelMessage.createMessage<KernelMessage.IHistoryReplyMsg>({\n      msgType: 'history_reply',\n      channel: 'shell',\n      parentHeader: historyMsg.header,\n      session: msg.header.session,\n      content: {\n        status: 'ok',\n        history: this._history as KernelMessage.IHistoryReply['history'],\n      },\n    });\n    this._sendMessage(message);\n  }\n\n  /**\n   * Send an `execute_input` message.\n   *\n   * @param msg The parent message.\n   */\n  private _executeInput(msg: KernelMessage.IMessage): void {\n    const parent = msg as KernelMessage.IExecuteInputMsg;\n    const code = parent.content.code;\n    const message = KernelMessage.createMessage<KernelMessage.IExecuteInputMsg>({\n      msgType: 'execute_input',\n      parentHeader: parent.header,\n      channel: 'iopub',\n      session: msg.header.session,\n      content: {\n        code,\n        execution_count: this._executionCount,\n      },\n    });\n    this._sendMessage(message);\n  }\n\n  /**\n   * Handle an execute_request message.\n   *\n   * @param msg The parent message.\n   */\n  private async _execute(msg: KernelMessage.IMessage): Promise<void> {\n    const executeMsg = msg as KernelMessage.IExecuteRequestMsg;\n    const content = executeMsg.content;\n    if (content.store_history) {\n      this._executionCount++;\n    }\n\n    // TODO: handle differently\n    this._parentHeader = executeMsg.header;\n\n    this._executeInput(executeMsg);\n\n    if (content.store_history) {\n      this._history.push([0, 0, content.code]);\n    }\n\n    const reply = await this.executeRequest(executeMsg.content);\n    const message = KernelMessage.createMessage<KernelMessage.IExecuteReplyMsg>({\n      msgType: 'execute_reply',\n      channel: 'shell',\n      parentHeader: executeMsg.header,\n      session: msg.header.session,\n      content: reply,\n    });\n\n    this._sendMessage(message);\n  }\n\n  /**\n   * Handle an complete_request message\n   *\n   * @param msg The parent message.\n   */\n  private async _complete(msg: KernelMessage.IMessage): Promise<void> {\n    const completeMsg = msg as KernelMessage.ICompleteRequestMsg;\n    const content = await this.completeRequest(completeMsg.content);\n    const message = KernelMessage.createMessage<KernelMessage.ICompleteReplyMsg>({\n      msgType: 'complete_reply',\n      parentHeader: completeMsg.header,\n      channel: 'shell',\n      session: msg.header.session,\n      content,\n    });\n\n    this._sendMessage(message);\n  }\n\n  /**\n   * Handle an inspect_request message\n   *\n   * @param msg The parent message.\n   */\n  private async _inspect(msg: KernelMessage.IMessage): Promise<void> {\n    const inspectMsg = msg as KernelMessage.IInspectRequestMsg;\n    const content = await this.inspectRequest(inspectMsg.content);\n    const message = KernelMessage.createMessage<KernelMessage.IInspectReplyMsg>({\n      msgType: 'inspect_reply',\n      parentHeader: inspectMsg.header,\n      channel: 'shell',\n      session: msg.header.session,\n      content,\n    });\n\n    this._sendMessage(message);\n  }\n\n  /**\n   * Handle an is_complete_request message\n   *\n   * @param msg The parent message.\n   */\n  private async _isCompleteRequest(msg: KernelMessage.IMessage): Promise<void> {\n    const isCompleteMsg = msg as KernelMessage.IIsCompleteRequestMsg;\n    const content = await this.isCompleteRequest(isCompleteMsg.content);\n    const message = KernelMessage.createMessage<KernelMessage.IIsCompleteReplyMsg>({\n      msgType: 'is_complete_reply',\n      parentHeader: isCompleteMsg.header,\n      channel: 'shell',\n      session: msg.header.session,\n      content,\n    });\n\n    this._sendMessage(message);\n  }\n\n  private _id: string;\n  private _name: string;\n  private _location: string;\n  private _history: [number, number, string][] = [];\n  private _executionCount = 0;\n  private _isDisposed = false;\n  private _disposed = new Signal<this, void>(this);\n  private _sendMessage: IKernel.SendMessage;\n  private _parentHeader: KernelMessage.IHeader<KernelMessage.MessageType> | undefined =\n    undefined;\n  private _parent: KernelMessage.IMessage | undefined = undefined;\n}\n","const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_maxConcurrency, _cancelError = E_CANCELED) {\n        this._maxConcurrency = _maxConcurrency;\n        this._cancelError = _cancelError;\n        this._queue = [];\n        this._waiters = [];\n        if (_maxConcurrency <= 0) {\n            throw new Error('semaphore must be initialized to a positive value');\n        }\n        this._value = _maxConcurrency;\n    }\n    acquire() {\n        const locked = this.isLocked();\n        const ticketPromise = new Promise((resolve, reject) => this._queue.push({ resolve, reject }));\n        if (!locked)\n            this._dispatch();\n        return ticketPromise;\n    }\n    runExclusive(callback) {\n        return __awaiter$2(this, void 0, void 0, function* () {\n            const [value, release] = yield this.acquire();\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock() {\n        return __awaiter$2(this, void 0, void 0, function* () {\n            if (!this.isLocked()) {\n                return Promise.resolve();\n            }\n            const waitPromise = new Promise((resolve) => this._waiters.push({ resolve }));\n            return waitPromise;\n        });\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n    release() {\n        if (this._maxConcurrency > 1) {\n            throw new Error('this method is unavailable on semaphores with concurrency > 1; use the scoped release returned by acquire instead');\n        }\n        if (this._currentReleaser) {\n            const releaser = this._currentReleaser;\n            this._currentReleaser = undefined;\n            releaser();\n        }\n    }\n    cancel() {\n        this._queue.forEach((ticket) => ticket.reject(this._cancelError));\n        this._queue = [];\n    }\n    _dispatch() {\n        const nextTicket = this._queue.shift();\n        if (!nextTicket)\n            return;\n        let released = false;\n        this._currentReleaser = () => {\n            if (released)\n                return;\n            released = true;\n            this._value++;\n            this._resolveWaiters();\n            this._dispatch();\n        };\n        nextTicket.resolve([this._value--, this._currentReleaser]);\n    }\n    _resolveWaiters() {\n        this._waiters.forEach((waiter) => waiter.resolve());\n        this._waiters = [];\n    }\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, void 0, void 0, function* () {\n            const [, releaser] = yield this._semaphore.acquire();\n            return releaser;\n        });\n    }\n    runExclusive(callback) {\n        return this._semaphore.runExclusive(() => callback());\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock() {\n        return this._semaphore.waitForUnlock();\n    }\n    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n    release() {\n        this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: () => new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            let isTimeout = false;\n            const handle = setTimeout(() => {\n                isTimeout = true;\n                reject(timeoutError);\n            }, timeout);\n            try {\n                const ticket = yield sync.acquire();\n                if (isTimeout) {\n                    const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                    release();\n                }\n                else {\n                    clearTimeout(handle);\n                    resolve(ticket);\n                }\n            }\n            catch (e) {\n                if (!isTimeout) {\n                    clearTimeout(handle);\n                    reject(e);\n                }\n            }\n        })),\n        runExclusive(callback) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire();\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n        release() {\n            sync.release();\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: () => sync.waitForUnlock(),\n        isLocked: () => sync.isLocked(),\n    };\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n","import { ObservableMap } from '@jupyterlab/observables';\n\nimport { Kernel, KernelMessage } from '@jupyterlab/services';\n\nimport { deserialize, serialize } from '@jupyterlab/services/lib/kernel/serialize';\n\nimport { UUID } from '@lumino/coreutils';\n\nimport { Server as WebSocketServer, Client as WebSocketClient } from 'mock-socket';\n\nimport { IKernel, IKernels, IKernelSpecs } from './tokens';\n\nimport { Mutex } from 'async-mutex';\n\nimport { PageConfig } from '@jupyterlab/coreutils';\n\n/**\n * A class to handle requests to /api/kernels\n */\nexport class Kernels implements IKernels {\n  /**\n   * Construct a new Kernels\n   *\n   * @param options The instantiation options\n   */\n  constructor(options: Kernels.IOptions) {\n    const { kernelspecs } = options;\n    this._kernelspecs = kernelspecs;\n  }\n\n  /**\n   * Start a new kernel.\n   *\n   * @param options The kernel start options.\n   */\n  async startNew(options: Kernels.IKernelOptions): Promise<Kernel.IModel> {\n    const { id, name, location } = options;\n\n    const factory = this._kernelspecs.factories.get(name);\n    // bail if there is no factory associated with the requested kernel\n    if (!factory) {\n      return { id, name };\n    }\n\n    // create a synchronization mechanism to allow only one message\n    // to be processed at a time\n    const mutex = new Mutex();\n\n    // hook a new client to a kernel\n    const hook = (\n      kernelId: string,\n      clientId: string,\n      socket: WebSocketClient\n    ): void => {\n      const kernel = this._kernels.get(kernelId);\n\n      if (!kernel) {\n        throw Error(`No kernel ${kernelId}`);\n      }\n\n      this._clients.set(clientId, socket);\n      this._kernelClients.get(kernelId)?.add(clientId);\n\n      const processMsg = async (msg: KernelMessage.IMessage) => {\n        await mutex.runExclusive(async () => {\n          await kernel.ready;\n          await kernel.handleMessage(msg);\n        });\n      };\n\n      socket.on(\n        'message',\n        async (message: string | ArrayBuffer | Blob | ArrayBufferView) => {\n          let msg;\n          if (message instanceof ArrayBuffer) {\n            message = new Uint8Array(message).buffer;\n            msg = deserialize(message);\n          } else if (typeof message === 'string') {\n            msg = deserialize(message);\n          } else {\n            return;\n          }\n\n          // TODO Find a better solution for this?\n          // input-reply is asynchronous, must not be processed like other messages\n          if (msg.header.msg_type === 'input_reply') {\n            kernel.handleMessage(msg);\n          } else {\n            void processMsg(msg);\n          }\n        }\n      );\n\n      const removeClient = () => {\n        this._clients.delete(clientId);\n        this._kernelClients.get(kernelId)?.delete(clientId);\n      };\n\n      kernel.disposed.connect(removeClient);\n\n      // TODO: check whether this is called\n      // https://github.com/thoov/mock-socket/issues/298\n      // https://github.com/jupyterlab/jupyterlab/blob/6bc884a7a8ed73c615ce72ba097bdb790482b5bf/packages/services/src/kernel/default.ts#L1245\n      socket.onclose = removeClient;\n    };\n\n    // ensure kernel id\n    const kernelId = id ?? UUID.uuid4();\n\n    // There is one server per kernel which handles multiple clients\n    const kernelUrl = `${Kernels.WS_BASE_URL}api/kernels/${kernelId}/channels`;\n    const runningKernel = this._kernels.get(kernelId);\n    if (runningKernel) {\n      return {\n        id: runningKernel.id,\n        name: runningKernel.name,\n      };\n    }\n\n    // start the kernel\n    const sendMessage = (msg: KernelMessage.IMessage): void => {\n      const clientId = msg.header.session;\n      const socket = this._clients.get(clientId);\n      if (!socket) {\n        console.warn(`Trying to send message on removed socket for kernel ${kernelId}`);\n        return;\n      }\n\n      const message = serialize(msg);\n      // process iopub messages\n      if (msg.channel === 'iopub') {\n        const clients = this._kernelClients.get(kernelId);\n        clients?.forEach((id) => {\n          this._clients.get(id)?.send(message);\n        });\n        return;\n      }\n      socket.send(message);\n    };\n\n    const kernel = await factory({\n      id: kernelId,\n      sendMessage,\n      name,\n      location,\n    });\n\n    this._kernels.set(kernelId, kernel);\n    this._kernelClients.set(kernelId, new Set<string>());\n\n    // create the websocket server for the kernel\n    const wsServer = new WebSocketServer(kernelUrl);\n    wsServer.on('connection', (socket: WebSocketClient): void => {\n      const url = new URL(socket.url);\n      const clientId = url.searchParams.get('session_id') ?? '';\n      hook(kernelId, clientId, socket);\n    });\n\n    // clean up closed connection\n    wsServer.on('close', (): void => {\n      this._clients.keys().forEach((clientId) => {\n        const socket = this._clients.get(clientId);\n        if (socket?.readyState === WebSocket.CLOSED) {\n          this._clients.delete(clientId);\n          this._kernelClients.get(kernelId)?.delete(clientId);\n        }\n      });\n    });\n\n    // cleanup on kernel shutdown\n    kernel.disposed.connect(() => {\n      wsServer.close();\n      this._kernels.delete(kernelId);\n      this._kernelClients.delete(kernelId);\n    });\n\n    return {\n      id: kernel.id,\n      name: kernel.name,\n    };\n  }\n\n  /**\n   * Restart a kernel.\n   *\n   * @param kernelId The kernel id.\n   */\n  async restart(kernelId: string): Promise<Kernel.IModel> {\n    const kernel = this._kernels.get(kernelId);\n    if (!kernel) {\n      throw Error(`Kernel ${kernelId} does not exist`);\n    }\n    const { id, name, location } = kernel;\n    kernel.dispose();\n    return this.startNew({ id, name, location });\n  }\n\n  /**\n   * Shut down a kernel.\n   *\n   * @param id The kernel id.\n   */\n  async shutdown(id: string): Promise<void> {\n    this._kernels.delete(id)?.dispose();\n  }\n\n  private _kernels = new ObservableMap<IKernel>();\n  private _clients = new ObservableMap<WebSocketClient>();\n  private _kernelClients = new ObservableMap<Set<string>>();\n  private _kernelspecs: IKernelSpecs;\n}\n\n/**\n * A namespace for Kernels statics.\n */\nexport namespace Kernels {\n  /**\n   * Options to create a new Kernels.\n   */\n  export interface IOptions {\n    /**\n     * The kernel specs service.\n     */\n    kernelspecs: IKernelSpecs;\n  }\n\n  /**\n   * Options to start a new kernel.\n   */\n  export interface IKernelOptions {\n    /**\n     * The kernel id.\n     */\n    id: string;\n\n    /**\n     * The kernel name.\n     */\n    name: string;\n\n    /**\n     * The location in the virtual filesystem from which the kernel was started.\n     */\n    location: string;\n  }\n\n  /**\n   * The base url for the Kernels manager\n   */\n  export const WS_BASE_URL = PageConfig.getBaseUrl().replace(/^http/, 'ws');\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport type { Remote } from 'comlink';\n\nimport { Kernel, KernelMessage, KernelSpec } from '@jupyterlab/services';\n\nimport { Token } from '@lumino/coreutils';\n\nimport { IObservableDisposable } from '@lumino/disposable';\n\nimport { Kernels } from './kernels';\n\nimport { KernelSpecs } from './kernelspecs';\n\n/**\n * The token for the kernels service.\n */\nexport const IKernels = new Token<IKernels>('@jupyterlite/kernel:IKernels');\n\n/**\n * The kernel name of last resort.\n */\nexport const FALLBACK_KERNEL = 'javascript';\n\n/**\n * An interface for the Kernels service.\n */\nexport interface IKernels {\n  /**\n   * Start a new kernel.\n   *\n   * @param options The kernel startup options.\n   */\n  startNew: (options: Kernels.IKernelOptions) => Promise<Kernel.IModel>;\n\n  /**\n   * Restart a kernel.\n   *\n   * @param id The kernel id.\n   */\n  restart: (id: string) => Promise<Kernel.IModel>;\n\n  /**\n   * Shut down a kernel.\n   *\n   * @param id The kernel id.\n   */\n  shutdown: (id: string) => Promise<void>;\n}\n\n/**\n * An interface for a kernel running in the browser.\n */\nexport interface IKernel extends IObservableDisposable {\n  /**\n   * The id of the server-side kernel.\n   */\n  readonly id: string;\n\n  /**\n   * The name of the server-side kernel.\n   */\n  readonly name: string;\n\n  /**\n   * The location in the virtual filesystem from which the kernel was started.\n   */\n  readonly location: string;\n\n  /**\n   * A promise that is fulfilled when the kernel is ready.\n   */\n  readonly ready: Promise<void>;\n\n  /**\n   * Handle an incoming message from the client.\n   *\n   * @param msg The message to handle\n   */\n  handleMessage(msg: KernelMessage.IMessage): Promise<void>;\n}\n\n/**\n * A namespace for IKernel statics.\n */\nexport namespace IKernel {\n  /**\n   * The type for the send message function.\n   */\n  export type SendMessage = (msg: KernelMessage.IMessage) => void;\n\n  /**\n   * The instantiation options for an IKernel.\n   */\n  export interface IOptions {\n    /**\n     * The kernel id.\n     */\n    id: string;\n\n    /**\n     * The name of the kernel.\n     */\n    name: string;\n\n    /**\n     * The location in the virtual filesystem from which the kernel was started.\n     */\n    location: string;\n\n    /**\n     * The method to send messages back to the server.\n     */\n    sendMessage: SendMessage;\n  }\n}\n\n/**\n * The token for the kernel spec service.\n */\nexport const IKernelSpecs = new Token<IKernelSpecs>('@jupyterlite/kernel:IKernelSpecs');\n\n/**\n * The interface for the kernel specs service.\n */\nexport interface IKernelSpecs {\n  /**\n   * Get the kernel specs.\n   */\n  readonly specs: KernelSpec.ISpecModels | null;\n\n  /**\n   * Get the default kernel name.\n   */\n  readonly defaultKernelName: string;\n\n  /**\n   * Get the kernel factories for the current kernels.\n   */\n  readonly factories: KernelSpecs.KernelFactories;\n\n  /**\n   * Register a new kernel spec\n   *\n   * @param options The kernel spec options.\n   */\n  register: (options: KernelSpecs.IKernelOptions) => void;\n}\n\n/**\n * An interface for a comlink-based worker kernel\n */\nexport interface IWorkerKernel {\n  /**\n   * Handle any lazy setup activities.\n   */\n  initialize(options: IWorkerKernel.IOptions): Promise<void>;\n  execute(\n    content: KernelMessage.IExecuteRequestMsg['content'],\n    parent: any\n  ): Promise<KernelMessage.IExecuteReplyMsg['content']>;\n  complete(\n    content: KernelMessage.ICompleteRequestMsg['content'],\n    parent: any\n  ): Promise<KernelMessage.ICompleteReplyMsg['content']>;\n  inspect(\n    content: KernelMessage.IInspectRequestMsg['content'],\n    parent: any\n  ): Promise<KernelMessage.IInspectReplyMsg['content']>;\n  isComplete(\n    content: KernelMessage.IIsCompleteRequestMsg['content'],\n    parent: any\n  ): Promise<KernelMessage.IIsCompleteReplyMsg['content']>;\n  commInfo(\n    content: KernelMessage.ICommInfoRequestMsg['content'],\n    parent: any\n  ): Promise<KernelMessage.ICommInfoReplyMsg['content']>;\n  commOpen(content: KernelMessage.ICommOpenMsg, parent: any): Promise<void>;\n  commMsg(content: KernelMessage.ICommMsgMsg, parent: any): Promise<void>;\n  commClose(content: KernelMessage.ICommCloseMsg, parent: any): Promise<void>;\n  inputReply(\n    content: KernelMessage.IInputReplyMsg['content'],\n    parent: any\n  ): Promise<void>;\n}\n\n/**\n * A namespace for worker kernels.\n **/\nexport namespace IWorkerKernel {\n  /**\n   * Common values likely to be required by all kernels.\n   */\n  export interface IOptions {\n    /**\n     * The base URL of the kernel server.\n     */\n    baseUrl: string;\n  }\n}\n\nexport interface IRemoteKernel extends Remote<IWorkerKernel> {}\n","import { PageConfig } from '@jupyterlab/coreutils';\n\nimport { KernelSpec } from '@jupyterlab/services';\n\nimport { IKernel, IKernelSpecs, FALLBACK_KERNEL } from './tokens';\n\n/**\n * A class to handle requests to /api/kernelspecs\n */\nexport class KernelSpecs implements IKernelSpecs {\n  /**\n   * Get the kernel specs.\n   */\n  get specs(): KernelSpec.ISpecModels | null {\n    if (this._specs.size === 0) {\n      return null;\n    }\n\n    return {\n      default: this.defaultKernelName,\n      kernelspecs: Object.fromEntries(this._specs),\n    };\n  }\n\n  /**\n   * Get the default kernel name.\n   */\n  get defaultKernelName(): string {\n    let defaultKernelName = PageConfig.getOption('defaultKernelName');\n\n    if (!defaultKernelName && this._specs.size) {\n      const keys = Array.from(this._specs.keys());\n      keys.sort();\n      defaultKernelName = keys[0];\n    }\n\n    return defaultKernelName || FALLBACK_KERNEL;\n  }\n\n  /**\n   * Get the kernel factories for the current kernels.\n   */\n  get factories(): KernelSpecs.KernelFactories {\n    return this._factories;\n  }\n\n  /**\n   * Register a new kernel.\n   *\n   * @param options The options to register a new kernel.\n   */\n  register(options: KernelSpecs.IKernelOptions): void {\n    const { spec, create } = options;\n    this._specs.set(spec.name, spec);\n    this._factories.set(spec.name, create);\n  }\n\n  private _specs = new Map<string, KernelSpec.ISpecModel>();\n  private _factories = new Map<string, KernelSpecs.KernelFactory>();\n}\n\n/**\n * A namespace for KernelSpecs statics.\n */\nexport namespace KernelSpecs {\n  /**\n   * Registration options for a new kernel.\n   */\n  export interface IKernelOptions {\n    /**\n     * The kernel spec.\n     */\n    spec: KernelSpec.ISpecModel;\n\n    /**\n     * The factory function to instantiate a new kernel.\n     */\n    create: KernelFactory;\n  }\n\n  /**\n   * The type for a kernel factory function used to instantiate new kernels.\n   */\n  export type KernelFactory = (options: IKernel.IOptions) => Promise<IKernel>;\n\n  /**\n   * The type for the record of kernel factory functions.\n   */\n  export type KernelFactories = Map<string, KernelFactory>;\n}\n"],"names":["BaseKernel","constructor","options","_history","_executionCount","_isDisposed","_disposed","Signal","this","_parentHeader","undefined","_parent","id","name","location","sendMessage","_id","_name","_location","_sendMessage","ready","Promise","resolve","isDisposed","disposed","executionCount","parentHeader","parent","dispose","emit","async","msg","_busy","header","msg_type","_kernelInfo","_execute","inputReply","content","_inspect","_isCompleteRequest","_complete","_historyRequest","commOpen","commMsg","commClose","_idle","stream","parentHeaderValue","message","KernelMessage","channel","msgType","session","displayData","metadata","inputRequest","publishExecuteResult","publishExecuteError","updateDisplayData","clearOutput","handleComm","type","buffers","execution_state","kernelInfoRequest","historyMsg","status","history","_executeInput","code","execution_count","executeMsg","store_history","push","reply","executeRequest","completeMsg","completeRequest","inspectMsg","inspectRequest","isCompleteMsg","isCompleteRequest","Error","E_CANCELED","__awaiter$2","thisArg","_arguments","P","generator","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Semaphore","_maxConcurrency","_cancelError","_queue","_waiters","_value","acquire","locked","isLocked","ticketPromise","_dispatch","runExclusive","callback","release","waitForUnlock","_currentReleaser","releaser","cancel","forEach","ticket","nextTicket","shift","released","_resolveWaiters","waiter","Mutex","cancelError","_semaphore","Kernels","_kernels","ObservableMap","_clients","_kernelClients","kernelspecs","_kernelspecs","factory","factories","get","mutex","hook","kernelId","clientId","socket","kernel","set","add","on","ArrayBuffer","Uint8Array","buffer","deserialize","handleMessage","processMsg","removeClient","delete","connect","onclose","UUID","kernelUrl","WS_BASE_URL","runningKernel","console","warn","serialize","send","clients","Set","wsServer","URL","url","searchParams","keys","readyState","WebSocket","CLOSED","close","startNew","PageConfig","replace","IKernels","Token","FALLBACK_KERNEL","IKernelSpecs","KernelSpecs","_specs","Map","_factories","specs","size","default","defaultKernelName","Object","fromEntries","Array","from","sort","register","spec","create"],"sourceRoot":""}