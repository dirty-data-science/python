{"version":3,"file":"8732.9320f73.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server-extension/src/index.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { PageConfig } from '@jupyterlab/coreutils';\n\nimport { Contents as ServerContents, KernelSpec } from '@jupyterlab/services';\n\nimport {\n  BroadcastChannelWrapper,\n  Contents,\n  IContents,\n  IBroadcastChannelWrapper,\n} from '@jupyterlite/contents';\n\nimport { IKernels, Kernels, IKernelSpecs, KernelSpecs } from '@jupyterlite/kernel';\n\nimport { ILicenses, Licenses } from '@jupyterlite/licenses';\n\nimport {\n  JupyterLiteServer,\n  JupyterLiteServerPlugin,\n  Router,\n  IServiceWorkerManager,\n  ServiceWorkerManager,\n} from '@jupyterlite/server';\n\nimport { ISessions, Sessions } from '@jupyterlite/session';\n\nimport { ISettings, Settings } from '@jupyterlite/settings';\n\nimport { ITranslation, Translation } from '@jupyterlite/translation';\n\nimport { ILocalForage, ensureMemoryStorage } from '@jupyterlite/localforage';\n\nimport localforage from 'localforage';\n\n/**\n * The localforage plugin\n */\nconst localforagePlugin: JupyterLiteServerPlugin<ILocalForage> = {\n  id: '@jupyterlite/server-extension:localforage',\n  autoStart: true,\n  provides: ILocalForage,\n  activate: (app: JupyterLiteServer) => {\n    return { localforage };\n  },\n};\n\n/**\n * The volatile localforage memory plugin\n */\nconst localforageMemoryPlugin: JupyterLiteServerPlugin<void> = {\n  id: '@jupyterlite/server-extension:localforage-memory-storage',\n  autoStart: true,\n  requires: [ILocalForage],\n  activate: async (app: JupyterLiteServer, forage: ILocalForage) => {\n    if (JSON.parse(PageConfig.getOption('enableMemoryStorage') || 'false')) {\n      console.warn(\n        'Memory storage fallback enabled: contents and settings may not be saved'\n      );\n      await ensureMemoryStorage(forage.localforage);\n    }\n  },\n};\n\n/**\n * The contents service plugin.\n */\nconst contentsPlugin: JupyterLiteServerPlugin<IContents> = {\n  id: '@jupyterlite/server-extension:contents',\n  requires: [ILocalForage],\n  autoStart: true,\n  provides: IContents,\n  activate: (app: JupyterLiteServer, forage: ILocalForage) => {\n    const storageName = PageConfig.getOption('contentsStorageName');\n    const storageDrivers = JSON.parse(\n      PageConfig.getOption('contentsStorageDrivers') || 'null'\n    );\n    const { localforage } = forage;\n    const contents = new Contents({\n      storageName,\n      storageDrivers,\n      localforage,\n    });\n    app.started.then(() => contents.initialize().catch(console.warn));\n    return contents;\n  },\n};\n\n/**\n * A plugin providing the routes for the contents service.\n */\nconst contentsRoutesPlugin: JupyterLiteServerPlugin<void> = {\n  id: '@jupyterlite/server-extension:contents-routes',\n  autoStart: true,\n  requires: [IContents],\n  activate: (app: JupyterLiteServer, contents: IContents) => {\n    // GET /api/contents/{path}/checkpoints - Get a list of checkpoints for a file\n    app.router.get(\n      '/api/contents/(.+)/checkpoints',\n      async (req: Router.IRequest, filename: string) => {\n        const res = await contents.listCheckpoints(filename);\n        return new Response(JSON.stringify(res));\n      }\n    );\n\n    // POST /api/contents/{path}/checkpoints/{checkpoint_id} - Restore a file to a particular checkpointed state\n    app.router.post(\n      '/api/contents/(.+)/checkpoints/(.*)',\n      async (req: Router.IRequest, filename: string, checkpoint: string) => {\n        const res = await contents.restoreCheckpoint(filename, checkpoint);\n        return new Response(JSON.stringify(res), { status: 204 });\n      }\n    );\n\n    // POST /api/contents/{path}/checkpoints - Create a new checkpoint for a file\n    app.router.post(\n      '/api/contents/(.+)/checkpoints',\n      async (req: Router.IRequest, filename: string) => {\n        const res = await contents.createCheckpoint(filename);\n        return new Response(JSON.stringify(res), { status: 201 });\n      }\n    );\n\n    // DELETE /api/contents/{path}/checkpoints/{checkpoint_id} - Delete a checkpoint\n    app.router.delete(\n      '/api/contents/(.+)/checkpoints/(.*)',\n      async (req: Router.IRequest, filename: string, checkpoint: string) => {\n        const res = await contents.deleteCheckpoint(filename, checkpoint);\n        return new Response(JSON.stringify(res), { status: 204 });\n      }\n    );\n\n    // GET /api/contents/{path} - Get contents of file or directory\n    app.router.get(\n      '/api/contents(.*)',\n      async (req: Router.IRequest, filename: string) => {\n        const options: ServerContents.IFetchOptions = {\n          content: req.query?.content === '1',\n        };\n        const nb = await contents.get(filename, options);\n        if (!nb) {\n          return new Response(null, { status: 404 });\n        }\n        return new Response(JSON.stringify(nb));\n      }\n    );\n\n    // POST /api/contents/{path} - Create a new file in the specified path\n    app.router.post('/api/contents(.*)', async (req: Router.IRequest, path: string) => {\n      const options = req.body;\n      const copyFrom = options?.copy_from as string;\n      let file: ServerContents.IModel | null;\n      if (copyFrom) {\n        file = await contents.copy(copyFrom, path);\n      } else {\n        file = await contents.newUntitled(options);\n      }\n      if (!file) {\n        return new Response(null, { status: 400 });\n      }\n      return new Response(JSON.stringify(file), { status: 201 });\n    });\n\n    // PATCH /api/contents/{path} - Rename a file or directory without re-uploading content\n    app.router.patch(\n      '/api/contents(.*)',\n      async (req: Router.IRequest, filename: string) => {\n        const newPath = (req.body?.path as string) ?? '';\n        filename = filename[0] === '/' ? filename.slice(1) : filename;\n        const nb = await contents.rename(filename, newPath);\n        return new Response(JSON.stringify(nb));\n      }\n    );\n\n    // PUT /api/contents/{path} - Save or upload a file\n    app.router.put(\n      '/api/contents/(.+)',\n      async (req: Router.IRequest, filename: string) => {\n        const body = req.body;\n        const nb = await contents.save(filename, body);\n        return new Response(JSON.stringify(nb));\n      }\n    );\n\n    // DELETE /api/contents/{path} - Delete a file in the given path\n    app.router.delete(\n      '/api/contents/(.+)',\n      async (req: Router.IRequest, filename: string) => {\n        await contents.delete(filename);\n        return new Response(null, { status: 204 });\n      }\n    );\n  },\n};\n\n/**\n * A plugin installing the service worker.\n */\nconst serviceWorkerPlugin: JupyterLiteServerPlugin<IServiceWorkerManager> = {\n  id: '@jupyterlite/server-extension:service-worker',\n  autoStart: true,\n  provides: IServiceWorkerManager,\n  activate: (app: JupyterLiteServer) => {\n    return new ServiceWorkerManager();\n  },\n};\n\n/**\n * A plugin for handling communication with the Emscpriten file system.\n */\nconst emscriptenFileSystemPlugin: JupyterLiteServerPlugin<IBroadcastChannelWrapper> = {\n  id: '@jupyterlite/server-extension:emscripten-filesystem',\n  autoStart: true,\n  optional: [IServiceWorkerManager],\n  provides: IBroadcastChannelWrapper,\n  activate: (\n    app: JupyterLiteServer,\n    serviceWorkerRegistrationWrapper?: IServiceWorkerManager\n  ): IBroadcastChannelWrapper => {\n    const { contents } = app.serviceManager;\n    const broadcaster = new BroadcastChannelWrapper({ contents });\n    const what = 'Kernel filesystem and JupyterLite contents';\n\n    function logStatus(msg?: string, err?: any) {\n      if (err) {\n        console.warn(err);\n      }\n      if (msg) {\n        console.warn(msg);\n      }\n      if (err || msg) {\n        console.warn(`${what} will NOT be synced`);\n      } else {\n        console.info(`${what} will be synced`);\n      }\n    }\n\n    if (!serviceWorkerRegistrationWrapper) {\n      logStatus('JupyterLite ServiceWorker not available');\n    } else {\n      serviceWorkerRegistrationWrapper.ready\n        .then(() => {\n          broadcaster.enable();\n          logStatus();\n        })\n        .catch((err: any) => {\n          logStatus('JupyterLite ServiceWorker failed to become available', err);\n        });\n    }\n\n    return broadcaster;\n  },\n};\n\n/**\n * The kernels service plugin.\n */\nconst kernelsPlugin: JupyterLiteServerPlugin<IKernels> = {\n  id: '@jupyterlite/server-extension:kernels',\n  autoStart: true,\n  provides: IKernels,\n  requires: [IKernelSpecs],\n  activate: (app: JupyterLiteServer, kernelspecs: IKernelSpecs) => {\n    return new Kernels({ kernelspecs });\n  },\n};\n\n/**\n * A plugin providing the routes for the kernels service\n */\nconst kernelsRoutesPlugin: JupyterLiteServerPlugin<void> = {\n  id: '@jupyterlite/server-extension:kernels-routes',\n  autoStart: true,\n  requires: [IKernels],\n  activate: (app: JupyterLiteServer, kernels: IKernels) => {\n    // POST /api/kernels/{kernel_id} - Restart a kernel\n    app.router.post(\n      '/api/kernels/(.*)/restart',\n      async (req: Router.IRequest, kernelId: string) => {\n        const res = await kernels.restart(kernelId);\n        return new Response(JSON.stringify(res));\n      }\n    );\n\n    // DELETE /api/kernels/{kernel_id} - Kill a kernel and delete the kernel id\n    app.router.delete(\n      '/api/kernels/(.*)',\n      async (req: Router.IRequest, kernelId: string) => {\n        const res = await kernels.shutdown(kernelId);\n        return new Response(JSON.stringify(res), { status: 204 });\n      }\n    );\n  },\n};\n\n/**\n * The kernel spec service plugin.\n */\nconst kernelSpecPlugin: JupyterLiteServerPlugin<IKernelSpecs> = {\n  id: '@jupyterlite/server-extension:kernelspec',\n  autoStart: true,\n  provides: IKernelSpecs,\n  activate: (app: JupyterLiteServer) => {\n    return new KernelSpecs();\n  },\n};\n\n/**\n * A plugin providing the routes for the kernelspec service.\n */\nconst kernelSpecRoutesPlugin: JupyterLiteServerPlugin<void> = {\n  id: '@jupyterlite/server-extension:kernelspec-routes',\n  autoStart: true,\n  requires: [IKernelSpecs],\n  activate: (app: JupyterLiteServer, kernelspecs: IKernelSpecs) => {\n    app.router.get('/api/kernelspecs', async (req: Router.IRequest) => {\n      const { specs } = kernelspecs;\n      if (!specs) {\n        return new Response(null);\n      }\n      // follow the same format as in Jupyter Server\n      const allKernelSpecs: {\n        [name: string]: {\n          name: string;\n          spec: KernelSpec.ISpecModel | undefined;\n          resources: { [name: string]: string } | undefined;\n        };\n      } = {};\n      const allSpecs = specs.kernelspecs;\n      Object.keys(allSpecs).forEach((name) => {\n        const spec = allSpecs[name];\n        const { resources } = spec ?? {};\n        allKernelSpecs[name] = {\n          name,\n          spec,\n          resources,\n        };\n      });\n      const res = {\n        default: specs.default,\n        kernelspecs: allKernelSpecs,\n      };\n      return new Response(JSON.stringify(res));\n    });\n  },\n};\n\n/**\n * The licenses service plugin\n */\nconst licensesPlugin: JupyterLiteServerPlugin<ILicenses> = {\n  id: '@jupyterlite/server-extension:licenses',\n  autoStart: true,\n  provides: ILicenses,\n  activate: (app: JupyterLiteServer) => {\n    return new Licenses();\n  },\n};\n\n/**\n * A plugin providing the routes for the licenses service.\n */\nconst licensesRoutesPlugin: JupyterLiteServerPlugin<void> = {\n  id: '@jupyterlite/server-extension:licenses-routes',\n  autoStart: true,\n  requires: [ILicenses],\n  activate(app: JupyterLiteServer, licenses: ILicenses) {\n    app.router.get('/api/licenses', async (req: Router.IRequest) => {\n      const res = await licenses.get();\n      return new Response(JSON.stringify(res));\n    });\n  },\n};\n\n/**\n * A plugin providing the routes for the nbconvert service.\n * TODO: provide the service in a separate plugin?\n */\nconst nbconvertRoutesPlugin: JupyterLiteServerPlugin<void> = {\n  id: '@jupyterlite/server-extension:nbconvert-routes',\n  autoStart: true,\n  activate: (app: JupyterLiteServer) => {\n    app.router.get('/api/nbconvert', async (req: Router.IRequest) => {\n      return new Response(JSON.stringify({}));\n    });\n  },\n};\n\n/**\n * The sessions service plugin.\n */\nconst sessionsPlugin: JupyterLiteServerPlugin<ISessions> = {\n  id: '@jupyterlite/server-extension:sessions',\n  autoStart: true,\n  provides: ISessions,\n  requires: [IKernels],\n  activate: (app: JupyterLiteServer, kernels: IKernels) => {\n    return new Sessions({ kernels });\n  },\n};\n\n/**\n * A plugin providing the routes for the session service.\n */\nconst sessionsRoutesPlugin: JupyterLiteServerPlugin<void> = {\n  id: '@jupyterlite/server-extension:sessions-routes',\n  autoStart: true,\n  requires: [ISessions],\n  activate: (app: JupyterLiteServer, sessions: ISessions) => {\n    // GET /api/sessions/{session} - Get session\n    app.router.get('/api/sessions/(.+)', async (req: Router.IRequest, id: string) => {\n      const session = await sessions.get(id);\n      return new Response(JSON.stringify(session), { status: 200 });\n    });\n\n    // GET /api/sessions - List available sessions\n    app.router.get('/api/sessions', async (req: Router.IRequest) => {\n      const list = await sessions.list();\n      return new Response(JSON.stringify(list), { status: 200 });\n    });\n\n    // PATCH /api/sessions/{session} - This can be used to rename a session\n    app.router.patch('/api/sessions(.*)', async (req: Router.IRequest, id: string) => {\n      const options = req.body as any;\n      const session = await sessions.patch(options);\n      return new Response(JSON.stringify(session), { status: 200 });\n    });\n\n    // DELETE /api/sessions/{session} - Delete a session\n    app.router.delete(\n      '/api/sessions/(.+)',\n      async (req: Router.IRequest, id: string) => {\n        await sessions.shutdown(id);\n        return new Response(null, { status: 204 });\n      }\n    );\n\n    // POST /api/sessions - Create a new session or return an existing session if a session of the same name already exists\n    app.router.post('/api/sessions', async (req: Router.IRequest) => {\n      const options = req.body as any;\n      const session = await sessions.startNew(options);\n      return new Response(JSON.stringify(session), { status: 201 });\n    });\n  },\n};\n\n/**\n * The settings service plugin.\n */\nconst settingsPlugin: JupyterLiteServerPlugin<ISettings> = {\n  id: '@jupyterlite/server-extension:settings',\n  autoStart: true,\n  requires: [ILocalForage],\n  provides: ISettings,\n  activate: (app: JupyterLiteServer, forage: ILocalForage) => {\n    const storageName = PageConfig.getOption('settingsStorageName');\n    const storageDrivers = JSON.parse(\n      PageConfig.getOption('settingsStorageDrivers') || 'null'\n    );\n    const { localforage } = forage;\n    const settings = new Settings({ storageName, storageDrivers, localforage });\n    app.started.then(() => settings.initialize().catch(console.warn));\n    return settings;\n  },\n};\n\n/**\n * A plugin providing the routes for the settings service.\n */\nconst settingsRoutesPlugin: JupyterLiteServerPlugin<void> = {\n  id: '@jupyterlite/server-extension:settings-routes',\n  autoStart: true,\n  requires: [ISettings],\n  activate: (app: JupyterLiteServer, settings: ISettings) => {\n    // TODO: improve the regex\n    // const pluginPattern = new RegExp(/(?:@([^/]+?)[/])?([^/]+?):(\\w+)/);\n    const pluginPattern = '/api/settings/((?:@([^/]+?)[/])?([^/]+?):([^:]+))$';\n\n    app.router.get(pluginPattern, async (req: Router.IRequest, pluginId: string) => {\n      const setting = await settings.get(pluginId);\n      return new Response(JSON.stringify(setting));\n    });\n\n    app.router.put(pluginPattern, async (req: Router.IRequest, pluginId: string) => {\n      const body = req.body as any;\n      const { raw } = body;\n      await settings.save(pluginId, raw);\n      return new Response(null, { status: 204 });\n    });\n\n    app.router.get('/api/settings', async (req: Router.IRequest) => {\n      const plugins = await settings.getAll();\n      return new Response(JSON.stringify(plugins));\n    });\n  },\n};\n\n/**\n * The translation service plugin.\n */\nconst translationPlugin: JupyterLiteServerPlugin<ITranslation> = {\n  id: '@jupyterlite/server-extension:translation',\n  autoStart: true,\n  provides: ITranslation,\n  activate: (app: JupyterLiteServer) => {\n    const translation = new Translation();\n\n    app.router.get(\n      '/api/translations/?(.*)',\n      async (req: Router.IRequest, locale: string) => {\n        const data = await translation.get(locale || 'all');\n        return new Response(JSON.stringify(data));\n      }\n    );\n\n    return translation;\n  },\n};\n\n/**\n * A plugin providing the routes for the translation service.\n */\nconst translationRoutesPlugin: JupyterLiteServerPlugin<void> = {\n  id: '@jupyterlite/server-extension:translation-routes',\n  autoStart: true,\n  requires: [ITranslation],\n  activate: (app: JupyterLiteServer, translation: ITranslation) => {\n    app.router.get(\n      '/api/translations/?(.*)',\n      async (req: Router.IRequest, locale: string) => {\n        const data = await translation.get(locale || 'all');\n        return new Response(JSON.stringify(data));\n      }\n    );\n  },\n};\n\nconst plugins: JupyterLiteServerPlugin<any>[] = [\n  contentsPlugin,\n  contentsRoutesPlugin,\n  emscriptenFileSystemPlugin,\n  kernelsPlugin,\n  kernelsRoutesPlugin,\n  kernelSpecPlugin,\n  kernelSpecRoutesPlugin,\n  licensesPlugin,\n  licensesRoutesPlugin,\n  localforageMemoryPlugin,\n  localforagePlugin,\n  nbconvertRoutesPlugin,\n  serviceWorkerPlugin,\n  sessionsPlugin,\n  sessionsRoutesPlugin,\n  settingsPlugin,\n  settingsRoutesPlugin,\n  translationPlugin,\n  translationRoutesPlugin,\n];\n\nexport default plugins;\n"],"names":["localforagePlugin","id","autoStart","provides","ILocalForage","activate","app","localforage","localforageMemoryPlugin","requires","async","forage","JSON","parse","PageConfig","console","warn","ensureMemoryStorage","contentsPlugin","IContents","storageName","storageDrivers","contents","Contents","started","then","initialize","catch","contentsRoutesPlugin","router","get","req","filename","res","listCheckpoints","Response","stringify","post","checkpoint","restoreCheckpoint","status","createCheckpoint","delete","deleteCheckpoint","options","content","query","nb","path","body","copyFrom","copy_from","file","copy","newUntitled","patch","newPath","slice","rename","put","save","serviceWorkerPlugin","IServiceWorkerManager","ServiceWorkerManager","optional","IBroadcastChannelWrapper","serviceWorkerRegistrationWrapper","serviceManager","broadcaster","BroadcastChannelWrapper","what","logStatus","msg","err","info","ready","enable","IKernels","IKernelSpecs","kernelspecs","Kernels","kernels","kernelId","restart","shutdown","KernelSpecs","specs","allKernelSpecs","allSpecs","Object","keys","forEach","name","spec","resources","default","ILicenses","Licenses","licenses","ISessions","Sessions","sessions","session","list","startNew","ISettings","settings","Settings","pluginPattern","pluginId","setting","raw","plugins","getAll","ITranslation","translation","Translation","locale","data"],"sourceRoot":""}