{"version":3,"file":"1245.be46619.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server/src/router.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server/src/app.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server/lib/service-worker.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server/src/tokens.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server/src/service-manager.ts"],"sourcesContent":["import { ReadonlyJSONObject } from '@lumino/coreutils';\n\n/**\n * A simple router.\n */\nexport class Router {\n  /**\n   * Add a new GET route\n   *\n   * @param pattern The pattern to match\n   * @param callback The function to call on pattern match\n   *\n   */\n  get(pattern: string | RegExp, callback: Router.Callback): void {\n    this._add('GET', pattern, callback);\n  }\n\n  /**\n   * Add a new PUT route\n   *\n   * @param pattern The pattern to match\n   * @param callback The function to call on pattern match\n   *\n   */\n  put(pattern: string | RegExp, callback: Router.Callback): void {\n    this._add('PUT', pattern, callback);\n  }\n\n  /**\n   * Add a new POST route\n   *\n   * @param pattern The pattern to match\n   * @param callback The function to call on pattern match\n   *\n   */\n  post(pattern: string | RegExp, callback: Router.Callback): void {\n    this._add('POST', pattern, callback);\n  }\n\n  /**\n   * Add a new PATCH route\n   *\n   * @param pattern The pattern to match\n   * @param callback The function to call on pattern match\n   *\n   */\n  patch(pattern: string | RegExp, callback: Router.Callback): void {\n    this._add('PATCH', pattern, callback);\n  }\n\n  /**\n   * Add a new DELETE route\n   *\n   * @param pattern The pattern to match\n   * @param callback The function to call on pattern match\n   *\n   */\n  delete(pattern: string | RegExp, callback: Router.Callback): void {\n    this._add('DELETE', pattern, callback);\n  }\n\n  /**\n   * Route a request.\n   *\n   * @param req The request to route.\n   */\n  async route(req: Request): Promise<Response> {\n    const url = new URL(req.url);\n    const { method } = req;\n    const { pathname } = url;\n\n    for (const r of this._routes) {\n      if (r.method !== method) {\n        continue;\n      }\n      const match = pathname.match(r.pattern);\n      if (!match) {\n        continue;\n      }\n      const matches = match.slice(1);\n      let body;\n      if (r.method === 'PATCH' || r.method === 'PUT' || r.method === 'POST') {\n        try {\n          body = JSON.parse(await req.text());\n        } catch {\n          body = undefined;\n        }\n      }\n      return r.callback.call(\n        null,\n        {\n          pathname,\n          body,\n          query: Object.fromEntries(url.searchParams),\n        },\n        ...matches\n      );\n    }\n\n    throw new Error('Cannot route ' + req.method + ' ' + req.url);\n  }\n\n  /**\n   * Add a new route.\n   *\n   * @param method The method\n   * @param pattern The pattern\n   * @param callback The callback\n   */\n  private _add(\n    method: Router.Method,\n    pattern: string | RegExp,\n    callback: Router.Callback\n  ): void {\n    if (typeof pattern === 'string') {\n      pattern = new RegExp(pattern);\n    }\n    this._routes.push({\n      method,\n      pattern,\n      callback,\n    });\n  }\n\n  private _routes: Router.IRoute[] = [];\n}\n\n/**\n * A namespace for Router statics.\n */\nexport namespace Router {\n  /**\n   * The Callback type.\n   */\n  export type Callback = (req: IRequest, ...args: string[]) => Promise<Response>;\n\n  /**\n   * The Method type.\n   */\n  export type Method = 'GET' | 'PUT' | 'POST' | 'PATCH' | 'DELETE';\n\n  /**\n   * The interface for a parsed request\n   */\n  export interface IRequest {\n    /**\n     * The path for the url.\n     */\n    pathname: string;\n\n    /**\n     * The optional query parameters.\n     */\n    query?: ReadonlyJSONObject;\n\n    /**\n     * The optional body parameters.\n     */\n    body?: ReadonlyJSONObject;\n  }\n\n  /**\n   * An interface for a route.\n   */\n  export interface IRoute {\n    method: Method;\n    pattern: string | RegExp;\n    callback: Callback;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { ServerConnection, ServiceManager } from '@jupyterlab/services';\n\nimport { Application, IPlugin } from '@lumino/application';\n\nimport { WebSocket } from 'mock-socket';\n\nimport { Router } from './router';\n\nexport type JupyterLiteServerPlugin<T> = IPlugin<JupyterLiteServer, T>;\n\n/**\n * Server is the main application class. It is instantiated once and shared.\n */\nexport class JupyterLiteServer extends Application<never> {\n  /**\n   * Construct a new JupyterLite object.\n   *\n   * @param options The instantiation options for a JupyterLiteServer application.\n   */\n  constructor(options: Application.IOptions<never>) {\n    super(options);\n    this._serviceManager = new ServiceManager({\n      standby: 'never',\n      serverSettings: {\n        ...ServerConnection.makeSettings(),\n        WebSocket,\n        fetch: this.fetch.bind(this) ?? undefined,\n      },\n    });\n  }\n\n  /**\n   * The name of the application.\n   */\n  readonly name = 'JupyterLite Server';\n\n  /**\n   * A namespace/prefix plugins may use to denote their provenance.\n   */\n  readonly namespace = this.name;\n\n  /**\n   * The version of the application.\n   */\n  readonly version = 'unknown';\n\n  /**\n   * Get the underlying `Router` instance.\n   */\n  get router(): Router {\n    return this._router;\n  }\n\n  /**\n   * Get the underlying lite service manager for this app.\n   */\n  get serviceManager(): ServiceManager {\n    return this._serviceManager;\n  }\n\n  /**\n   * Handle an incoming request from the client.\n   *\n   * @param req The incoming request\n   * @param init The optional init request\n   */\n  async fetch(\n    req: RequestInfo,\n    init?: RequestInit | null | undefined\n  ): Promise<Response> {\n    if (!(req instanceof Request)) {\n      throw Error('Request info is not a Request');\n    }\n    return this._router.route(req);\n  }\n\n  /**\n   * Attach the application shell to the DOM.\n   *\n   * @param id - The id of the host node for the shell, or `''`.\n   *\n   * #### Notes\n   * For this server application there is no shell to attach\n   */\n  protected attachShell(id: string): void {\n    // no-op\n  }\n\n  /**\n   * A method invoked on a window `'resize'` event.\n   *\n   * #### Notes\n   * For this server application there is no shell to update\n   */\n  protected evtResize(event: Event): void {\n    // no-op\n  }\n\n  /**\n   * Register plugins from a plugin module.\n   *\n   * @param mod - The plugin module to register.\n   */\n  registerPluginModule(mod: JupyterLiteServer.IPluginModule): void {\n    let data = mod.default;\n    // Handle commonjs exports.\n    if (!Object.prototype.hasOwnProperty.call(mod, '__esModule')) {\n      data = mod as any;\n    }\n    if (!Array.isArray(data)) {\n      data = [data];\n    }\n    data.forEach((item) => {\n      try {\n        this.registerPlugin(item);\n      } catch (error) {\n        console.error(error);\n      }\n    });\n  }\n\n  /**\n   * Register the plugins from multiple plugin modules.\n   *\n   * @param mods - The plugin modules to register.\n   */\n  registerPluginModules(mods: JupyterLiteServer.IPluginModule[]): void {\n    mods.forEach((mod) => {\n      this.registerPluginModule(mod);\n    });\n  }\n\n  private _router = new Router();\n  private _serviceManager: ServiceManager;\n}\n\n/**\n * A namespace for Server statics.\n */\nexport namespace JupyterLiteServer {\n  /**\n   * The interface for a module that exports a plugin or plugins as\n   * the default value.\n   */\n  export interface IPluginModule {\n    /**\n     * The default export.\n     */\n    default: IPlugin<JupyterLiteServer, any> | IPlugin<JupyterLiteServer, any>[];\n  }\n}\n","export default __webpack_public_path__ + \"service-worker-b2fb40a.js\";","import { Token } from '@lumino/coreutils';\n\nimport { ISignal } from '@lumino/signaling';\n\nimport SW_URL from '!!file-loader?name=[name]-[contenthash:7].[ext]&context=.!./service-worker';\n\n/**\n * The token for the ServiceWorker.\n */\nexport const IServiceWorkerManager = new Token<IServiceWorkerManager>(\n  '@jupyterlite/server-extension:IServiceWorkerManager'\n);\n\n/**\n * The interface for the ServiceWorkerRegistration.\n */\nexport interface IServiceWorkerManager {\n  /**\n   * Signal fired when the registration changed.\n   */\n  readonly registrationChanged: ISignal<\n    IServiceWorkerManager,\n    ServiceWorkerRegistration | null\n  >;\n\n  /**\n   * Whether the ServiceWorker is enabled or not.\n   */\n  readonly enabled: boolean;\n\n  /**\n   * A Promise that resolves when the ServiceWorker is registered, or rejects if it cannot\n   */\n  ready: Promise<void>;\n}\n\nexport const WORKER_NAME = `${SW_URL}`.split('/').slice(-1)[0];\n","import { PromiseDelegate } from '@lumino/coreutils';\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\n\nimport { IServiceWorkerManager, WORKER_NAME } from './tokens';\n\nexport class ServiceWorkerManager implements IServiceWorkerManager {\n  constructor() {\n    void this.initialize().catch(console.warn);\n  }\n\n  /**\n   * A signal emitted when the registration changes.\n   */\n  get registrationChanged(): ISignal<\n    IServiceWorkerManager,\n    ServiceWorkerRegistration | null\n  > {\n    return this._registrationChanged;\n  }\n\n  /**\n   * Whether the ServiceWorker is enabled or not.\n   */\n  get enabled(): boolean {\n    return this._registration !== null;\n  }\n\n  get ready(): Promise<void> {\n    return this._ready.promise;\n  }\n\n  private async initialize(): Promise<void> {\n    const { serviceWorker } = navigator;\n    const workerUrl = URLExt.join(PageConfig.getBaseUrl(), WORKER_NAME);\n    let registration: ServiceWorkerRegistration | null = null;\n\n    if (!serviceWorker) {\n      console.warn('ServiceWorkers not supported in this browser');\n    } else if (serviceWorker.controller) {\n      registration =\n        (await serviceWorker.getRegistration(serviceWorker.controller.scriptURL)) ||\n        null;\n      console.info('JupyterLite ServiceWorker was already registered');\n    }\n\n    if (!registration && serviceWorker) {\n      try {\n        console.info('Registering new JupyterLite ServiceWorker', workerUrl);\n        registration = await serviceWorker.register(workerUrl);\n        console.info('JupyterLite ServiceWorker was sucessfully registered');\n      } catch (err: any) {\n        console.warn(err);\n        console.warn(\n          `JupyterLite ServiceWorker registration unexpectedly failed: ${err}`\n        );\n      }\n    }\n\n    this.setRegistration(registration);\n\n    if (!registration) {\n      this._ready.reject(void 0);\n    } else {\n      this._ready.resolve(void 0);\n    }\n  }\n\n  private setRegistration(registration: ServiceWorkerRegistration | null) {\n    this._registration = registration;\n    this._registrationChanged.emit(this._registration);\n  }\n\n  private _registration: ServiceWorkerRegistration | null = null;\n  private _registrationChanged = new Signal<this, ServiceWorkerRegistration | null>(\n    this\n  );\n  private _ready = new PromiseDelegate<void>();\n}\n"],"names":["Router","_routes","get","pattern","callback","this","_add","put","post","patch","delete","async","req","url","URL","method","pathname","r","match","matches","slice","body","JSON","parse","text","undefined","call","query","Object","fromEntries","searchParams","Error","RegExp","push","JupyterLiteServer","Application","constructor","options","super","name","namespace","version","_router","_serviceManager","ServiceManager","standby","serverSettings","ServerConnection","WebSocket","fetch","bind","router","serviceManager","init","Request","route","attachShell","id","evtResize","event","registerPluginModule","mod","data","default","prototype","hasOwnProperty","Array","isArray","forEach","item","registerPlugin","error","console","registerPluginModules","mods","IServiceWorkerManager","Token","WORKER_NAME","split","ServiceWorkerManager","_registration","_registrationChanged","Signal","_ready","PromiseDelegate","initialize","catch","warn","registrationChanged","enabled","ready","promise","serviceWorker","navigator","workerUrl","URLExt","PageConfig","registration","controller","getRegistration","scriptURL","info","register","err","setRegistration","resolve","reject","emit"],"sourceRoot":""}