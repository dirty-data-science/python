{"version":3,"file":"302.8bcc38f.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/src/tokens.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/src/contents.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/src/emscripten.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/src/drivefs.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/src/broadcast.ts"],"sourcesContent":["import { IDisposable } from '@lumino/disposable';\nimport { IRenderMime } from '@jupyterlab/rendermime-interfaces';\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport mime from 'mime';\n\nimport { Contents as ServerContents } from '@jupyterlab/services';\n\nimport { Token } from '@lumino/coreutils';\n\n/**\n * The token for the settings service.\n */\nexport const IContents = new Token<IContents>('@jupyterlite/contents:IContents');\n\n/**\n * The interface for the contents service.\n */\nexport interface IContents {\n  /**\n   * A promise that resolves after the contents have been full initialized.\n   */\n  ready: Promise<void>;\n\n  /**\n   * Create a new untitled file or directory in the specified directory path.\n   *\n   * @param options: The options used to create the file.\n   *\n   * @returns A promise which resolves with the created file content when the file is created.\n   */\n  newUntitled(\n    options?: ServerContents.ICreateOptions\n  ): Promise<ServerContents.IModel | null>;\n\n  /**\n   * Copy a file into a given directory.\n   *\n   * @param path - The original file path.\n   * @param toDir - The destination directory path.\n   *\n   * @returns A promise which resolves with the new contents model when the\n   *  file is copied.\n   *\n   * #### Notes\n   * The server will select the name of the copied file.\n   */\n  copy(path: string, toDir: string): Promise<ServerContents.IModel>;\n\n  /**\n   * Get a file or directory.\n   *\n   * @param path: The path to the file.\n   * @param options: The options used to fetch the file.\n   *\n   * @returns A promise which resolves with the file content.\n   */\n  get(\n    path: string,\n    options?: ServerContents.IFetchOptions\n  ): Promise<ServerContents.IModel | null>;\n\n  /**\n   * Rename a file or directory.\n   *\n   * @param oldLocalPath - The original file path.\n   * @param newLocalPath - The new file path.\n   *\n   * @returns A promise which resolves with the new file content model when the file is renamed.\n   */\n  rename(oldLocalPath: string, newLocalPath: string): Promise<ServerContents.IModel>;\n\n  /**\n   * Save a file.\n   *\n   * @param path - The desired file path.\n   * @param options - Optional overrides to the model.\n   *\n   * @returns A promise which resolves with the file content model when the file is saved.\n   */\n  save(\n    path: string,\n    options?: Partial<ServerContents.IModel>\n  ): Promise<ServerContents.IModel | null>;\n\n  /**\n   * Delete a file.\n   *\n   * @param path - The path to the file.\n   */\n  delete(path: string): Promise<void>;\n\n  /**\n   * Create a checkpoint for a file.\n   *\n   * @param path - The path of the file.\n   *\n   * @returns A promise which resolves with the new checkpoint model when the\n   *   checkpoint is created.\n   */\n  createCheckpoint(path: string): Promise<ServerContents.ICheckpointModel>;\n\n  /**\n   * List available checkpoints for a file.\n   *\n   * @param path - The path of the file.\n   *\n   * @returns A promise which resolves with a list of checkpoint models for\n   *    the file.\n   */\n  listCheckpoints(path: string): Promise<ServerContents.ICheckpointModel[]>;\n\n  /**\n   * Restore a file to a known checkpoint state.\n   *\n   * @param path - The path of the file.\n   * @param checkpointID - The id of the checkpoint to restore.\n   *\n   * @returns A promise which resolves when the checkpoint is restored.\n   */\n  restoreCheckpoint(path: string, checkpointID: string): Promise<void>;\n\n  /**\n   * Delete a checkpoint for a file.\n   *\n   * @param path - The path of the file.\n   * @param checkpointID - The id of the checkpoint to delete.\n   *\n   * @returns A promise which resolves when the checkpoint is deleted.\n   */\n  deleteCheckpoint(path: string, checkpointID: string): Promise<void>;\n}\n\n/**\n * Commonly-used mimetypes\n */\nexport namespace MIME {\n  export const JSON = 'application/json';\n  export const PLAIN_TEXT = 'text/plain';\n  export const OCTET_STREAM = 'octet/stream';\n}\n\n/**\n * A namespace for file constructs.\n */\nexport namespace FILE {\n  /**\n   * Build-time configured file types.\n   */\n  const TYPES: Record<string, Partial<IRenderMime.IFileType>> = JSON.parse(\n    PageConfig.getOption('fileTypes') || '{}'\n  );\n\n  /**\n   * Get a mimetype (or fallback).\n   */\n  export function getType(ext: string, defaultType: string | null = null): string {\n    ext = ext.toLowerCase();\n    for (const fileType of Object.values(TYPES)) {\n      for (const fileExt of fileType.extensions || []) {\n        if (fileExt === ext && fileType.mimeTypes && fileType.mimeTypes.length) {\n          return fileType.mimeTypes[0];\n        }\n      }\n    }\n\n    return mime.getType(ext) || defaultType || MIME.OCTET_STREAM;\n  }\n\n  /**\n   * Determine whether the given extension matches a given fileFormat.\n   */\n  export function hasFormat(\n    ext: string,\n    fileFormat: 'base64' | 'text' | 'json'\n  ): boolean {\n    ext = ext.toLowerCase();\n    for (const fileType of Object.values(TYPES)) {\n      if (fileType.fileFormat !== fileFormat) {\n        continue;\n      }\n      for (const fileExt of fileType.extensions || []) {\n        if (fileExt === ext) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n\n/**\n * The token for the BroadcastChannel broadcaster.\n */\nexport const IBroadcastChannelWrapper = new Token<IBroadcastChannelWrapper>(\n  '@jupyterlite/contents:IBroadcastChannelWrapper'\n);\n\nexport interface IBroadcastChannelWrapper extends IDisposable {\n  enable(): void;\n  disable(): void;\n  enabled: boolean;\n}\n","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\n\nimport { Contents as ServerContents } from '@jupyterlab/services';\n\nimport { INotebookContent } from '@jupyterlab/nbformat';\n\nimport { PathExt } from '@jupyterlab/coreutils';\n\nimport type localforage from 'localforage';\n\nimport { IContents, MIME, FILE } from './tokens';\nimport { PromiseDelegate } from '@lumino/coreutils';\n\nexport type IModel = ServerContents.IModel;\n\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n\n/**\n * The number of checkpoints to save.\n */\nconst N_CHECKPOINTS = 5;\n\n/**\n * A class to handle requests to /api/contents\n */\nexport class Contents implements IContents {\n  /**\n   * Construct a new localForage-powered contents provider\n   */\n  constructor(options: Contents.IOptions) {\n    this._localforage = options.localforage;\n    this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n    this._storageDrivers = options.storageDrivers || null;\n    this._ready = new PromiseDelegate();\n  }\n\n  /**\n   * Finish any initialization after server has started and all extensions are applied.\n   */\n  async initialize() {\n    await this.initStorage();\n    this._ready.resolve(void 0);\n  }\n\n  /**\n   * Initialize all storage instances\n   */\n  protected async initStorage(): Promise<void> {\n    this._storage = this.createDefaultStorage();\n    this._counters = this.createDefaultCounters();\n    this._checkpoints = this.createDefaultCheckpoints();\n  }\n\n  /**\n   * A promise that resolves once all storage is fully initialized.\n   */\n  get ready(): Promise<void> {\n    return this._ready.promise;\n  }\n\n  /**\n   * A lazy reference to the underlying storage.\n   */\n  protected get storage(): Promise<LocalForage> {\n    return this.ready.then(() => this._storage as LocalForage);\n  }\n\n  /**\n   * A lazy reference to the underlying counters.\n   */\n  protected get counters(): Promise<LocalForage> {\n    return this.ready.then(() => this._counters as LocalForage);\n  }\n\n  /**\n   * A lazy reference to the underlying checkpoints.\n   */\n  protected get checkpoints(): Promise<LocalForage> {\n    return this.ready.then(() => this._checkpoints as LocalForage);\n  }\n\n  /**\n   * Get default options for localForage instances\n   */\n  protected get defaultStorageOptions(): LocalForageOptions {\n    const driver =\n      this._storageDrivers && this._storageDrivers.length ? this._storageDrivers : null;\n    return {\n      version: 1,\n      name: this._storageName,\n      ...(driver ? { driver } : {}),\n    };\n  }\n\n  /**\n   * Initialize the default storage for contents.\n   */\n  protected createDefaultStorage(): LocalForage {\n    return this._localforage.createInstance({\n      description: 'Offline Storage for Notebooks and Files',\n      storeName: 'files',\n      ...this.defaultStorageOptions,\n    });\n  }\n\n  /**\n   * Initialize the default storage for counting file suffixes.\n   */\n  protected createDefaultCounters(): LocalForage {\n    return this._localforage.createInstance({\n      description: 'Store the current file suffix counters',\n      storeName: 'counters',\n      ...this.defaultStorageOptions,\n    });\n  }\n\n  /**\n   * Create the default checkpoint storage.\n   */\n  protected createDefaultCheckpoints(): LocalForage {\n    return this._localforage.createInstance({\n      description: 'Offline Storage for Checkpoints',\n      storeName: 'checkpoints',\n      ...this.defaultStorageOptions,\n    });\n  }\n\n  /**\n   * Create a new untitled file or directory in the specified directory path.\n   *\n   * @param options: The options used to create the file.\n   *\n   * @returns A promise which resolves with the created file content when the file is created.\n   */\n  async newUntitled(options?: ServerContents.ICreateOptions): Promise<IModel | null> {\n    const path = options?.path ?? '';\n    const type = options?.type ?? 'notebook';\n    const created = new Date().toISOString();\n\n    let dirname = PathExt.dirname(path);\n    const basename = PathExt.basename(path);\n    const extname = PathExt.extname(path);\n    const item = await this.get(dirname);\n\n    // handle the case of \"Save As\", where the path points to the new file\n    // to create, e.g. subfolder/example-copy.ipynb\n    let name = '';\n    if (path && !extname && item) {\n      // directory\n      dirname = `${path}/`;\n      name = '';\n    } else if (dirname && basename) {\n      // file in a subfolder\n      dirname = `${dirname}/`;\n      name = basename;\n    } else {\n      // file at the top level\n      dirname = '';\n      name = path;\n    }\n\n    let file: IModel;\n    switch (type) {\n      case 'directory': {\n        const counter = await this._incrementCounter('directory');\n        name = `Untitled Folder${counter || ''}`;\n        file = {\n          name,\n          path: `${dirname}${name}`,\n          last_modified: created,\n          created,\n          format: 'json',\n          mimetype: '',\n          content: null,\n          size: 0,\n          writable: true,\n          type: 'directory',\n        };\n        break;\n      }\n      case 'notebook': {\n        const counter = await this._incrementCounter('notebook');\n        name = name || `Untitled${counter || ''}.ipynb`;\n        file = {\n          name,\n          path: `${dirname}${name}`,\n          last_modified: created,\n          created,\n          format: 'json',\n          mimetype: MIME.JSON,\n          content: Private.EMPTY_NB,\n          size: JSON.stringify(Private.EMPTY_NB).length,\n          writable: true,\n          type: 'notebook',\n        };\n        break;\n      }\n      default: {\n        const ext = options?.ext ?? '.txt';\n        const counter = await this._incrementCounter('file');\n        const mimetype = FILE.getType(ext) || MIME.OCTET_STREAM;\n\n        let format: ServerContents.FileFormat;\n        if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n          format = 'text';\n        } else if (ext.indexOf('json') !== -1 || ext.indexOf('ipynb') !== -1) {\n          format = 'json';\n        } else {\n          format = 'base64';\n        }\n\n        name = name || `untitled${counter || ''}${ext}`;\n        file = {\n          name,\n          path: `${dirname}${name}`,\n          last_modified: created,\n          created,\n          format,\n          mimetype,\n          content: '',\n          size: 0,\n          writable: true,\n          type: 'file',\n        };\n        break;\n      }\n    }\n\n    const key = file.path;\n    await (await this.storage).setItem(key, file);\n    return file;\n  }\n\n  /**\n   * Copy a file into a given directory.\n   *\n   * @param path - The original file path.\n   * @param toDir - The destination directory path.\n   *\n   * @returns A promise which resolves with the new contents model when the\n   *  file is copied.\n   *\n   * #### Notes\n   * The server will select the name of the copied file.\n   */\n  async copy(path: string, toDir: string): Promise<IModel> {\n    let name = PathExt.basename(path);\n    toDir = toDir === '' ? '' : `${toDir.slice(1)}/`;\n    // TODO: better handle naming collisions with existing files\n    while (await this.get(`${toDir}${name}`, { content: true })) {\n      const ext = PathExt.extname(name);\n      const base = name.replace(ext, '');\n      name = `${base} (copy)${ext}`;\n    }\n    const toPath = `${toDir}${name}`;\n    let item = await this.get(path, { content: true });\n    if (!item) {\n      throw Error(`Could not find file with path ${path}`);\n    }\n    item = {\n      ...item,\n      name,\n      path: toPath,\n    };\n    await (await this.storage).setItem(toPath, item);\n    return item;\n  }\n\n  /**\n   * Get a file or directory.\n   *\n   * @param path: The path to the file.\n   * @param options: The options used to fetch the file.\n   *\n   * @returns A promise which resolves with the file content.\n   */\n  async get(\n    path: string,\n    options?: ServerContents.IFetchOptions\n  ): Promise<IModel | null> {\n    // remove leading slash\n    path = decodeURIComponent(path.replace(/^\\//, ''));\n\n    if (path === '') {\n      return await this._getFolder(path);\n    }\n\n    const storage = await this.storage;\n    const item = await storage.getItem(path);\n    const serverItem = await this._getServerContents(path, options);\n\n    const model = (item || serverItem) as IModel | null;\n\n    if (!model) {\n      return null;\n    }\n\n    if (!options?.content) {\n      return {\n        size: 0,\n        ...model,\n        content: null,\n      };\n    }\n\n    // for directories, find all files with the path as the prefix\n    if (model.type === 'directory') {\n      const contentMap = new Map<string, IModel>();\n      await storage.iterate<IModel, void>((file, key) => {\n        // use an additional slash to not include the directory itself\n        if (key === `${path}/${file.name}`) {\n          contentMap.set(file.name, file);\n        }\n      });\n\n      const serverContents: IModel[] = serverItem\n        ? serverItem.content\n        : Array.from((await this._getServerDirectory(path)).values());\n      for (const file of serverContents) {\n        if (!contentMap.has(file.name)) {\n          contentMap.set(file.name, file);\n        }\n      }\n\n      const content = [...contentMap.values()];\n\n      return {\n        name: PathExt.basename(path),\n        path,\n        last_modified: model.last_modified,\n        created: model.created,\n        format: 'json',\n        mimetype: MIME.JSON,\n        content,\n        size: 0,\n        writable: true,\n        type: 'directory',\n      };\n    }\n    return model;\n  }\n\n  /**\n   * Rename a file or directory.\n   *\n   * @param oldLocalPath - The original file path.\n   * @param newLocalPath - The new file path.\n   *\n   * @returns A promise which resolves with the new file content model when the file is renamed.\n   */\n  async rename(oldLocalPath: string, newLocalPath: string): Promise<IModel> {\n    const path = decodeURIComponent(oldLocalPath);\n    const file = await this.get(path, { content: true });\n    if (!file) {\n      throw Error(`Could not find file with path ${path}`);\n    }\n    const modified = new Date().toISOString();\n    const name = PathExt.basename(newLocalPath);\n    const newFile = {\n      ...file,\n      name,\n      path: newLocalPath,\n      last_modified: modified,\n    };\n    const storage = await this.storage;\n    await storage.setItem(newLocalPath, newFile);\n    // remove the old file\n    await storage.removeItem(path);\n    // remove the corresponding checkpoint\n    await (await this.checkpoints).removeItem(path);\n    // if a directory, recurse through all children\n    if (file.type === 'directory') {\n      let child: IModel;\n      for (child of file.content) {\n        await this.rename(\n          URLExt.join(oldLocalPath, child.name),\n          URLExt.join(newLocalPath, child.name)\n        );\n      }\n    }\n\n    return newFile;\n  }\n\n  /**\n   * Save a file.\n   *\n   * @param path - The desired file path.\n   * @param options - Optional overrides to the model.\n   *\n   * @returns A promise which resolves with the file content model when the file is saved.\n   */\n  async save(path: string, options: Partial<IModel> = {}): Promise<IModel | null> {\n    path = decodeURIComponent(path);\n\n    // process the file if coming from an upload\n    const ext = PathExt.extname(options.name ?? '');\n    const chunk = options.chunk;\n\n    // retrieve the content if it is a later chunk or the last one\n    // the new content will then be appended to the existing one\n    const chunked = chunk ? chunk > 1 || chunk === -1 : false;\n    let item: IModel | null = await this.get(path, { content: chunked });\n\n    if (!item) {\n      item = await this.newUntitled({ path, ext, type: 'file' });\n    }\n\n    if (!item) {\n      return null;\n    }\n\n    // keep a reference to the original content\n    const originalContent = item.content;\n\n    const modified = new Date().toISOString();\n    // override with the new values\n    item = {\n      ...item,\n      ...options,\n      last_modified: modified,\n    };\n\n    if (options.content && options.format === 'base64') {\n      const lastChunk = chunk ? chunk === -1 : true;\n\n      if (ext === '.ipynb') {\n        const content = this._handleChunk(options.content, originalContent, chunked);\n        item = {\n          ...item,\n          content: lastChunk ? JSON.parse(content) : content,\n          format: 'json',\n          type: 'notebook',\n          size: content.length,\n        };\n      } else if (FILE.hasFormat(ext, 'json')) {\n        const content = this._handleChunk(options.content, originalContent, chunked);\n        item = {\n          ...item,\n          content: lastChunk ? JSON.parse(content) : content,\n          format: 'json',\n          type: 'file',\n          size: content.length,\n        };\n      } else if (FILE.hasFormat(ext, 'text')) {\n        const content = this._handleChunk(options.content, originalContent, chunked);\n        item = {\n          ...item,\n          content,\n          format: 'text',\n          type: 'file',\n          size: content.length,\n        };\n      } else {\n        const content = options.content;\n        item = {\n          ...item,\n          content,\n          size: atob(content).length,\n        };\n      }\n    }\n\n    await (await this.storage).setItem(path, item);\n    return item;\n  }\n\n  /**\n   * Delete a file from browser storage.\n   *\n   * Has no effect on server-backed files, which will re-appear with their\n   * original timestamp.\n   *\n   * @param path - The path to the file.\n   */\n  async delete(path: string): Promise<void> {\n    path = decodeURIComponent(path);\n    const slashed = `${path}/`;\n    const toDelete = (await (await this.storage).keys()).filter(\n      (key) => key === path || key.startsWith(slashed)\n    );\n    await Promise.all(toDelete.map(this.forgetPath, this));\n  }\n\n  /**\n   * Remove the localForage and checkpoints for a path.\n   *\n   * @param path - The path to the file\n   */\n  protected async forgetPath(path: string): Promise<void> {\n    await Promise.all([\n      (await this.storage).removeItem(path),\n      (await this.checkpoints).removeItem(path),\n    ]);\n  }\n\n  /**\n   * Create a checkpoint for a file.\n   *\n   * @param path - The path of the file.\n   *\n   * @returns A promise which resolves with the new checkpoint model when the\n   *   checkpoint is created.\n   */\n  async createCheckpoint(path: string): Promise<ServerContents.ICheckpointModel> {\n    const checkpoints = await this.checkpoints;\n    path = decodeURIComponent(path);\n    const item = await this.get(path, { content: true });\n    if (!item) {\n      throw Error(`Could not find file with path ${path}`);\n    }\n    const copies = (((await checkpoints.getItem(path)) as IModel[]) ?? []).filter(\n      Boolean\n    );\n    copies.push(item);\n    // keep only a certain amount of checkpoints per file\n    if (copies.length > N_CHECKPOINTS) {\n      copies.splice(0, copies.length - N_CHECKPOINTS);\n    }\n    await checkpoints.setItem(path, copies);\n    const id = `${copies.length - 1}`;\n    return { id, last_modified: (item as IModel).last_modified };\n  }\n\n  /**\n   * List available checkpoints for a file.\n   *\n   * @param path - The path of the file.\n   *\n   * @returns A promise which resolves with a list of checkpoint models for\n   *    the file.\n   */\n  async listCheckpoints(path: string): Promise<ServerContents.ICheckpointModel[]> {\n    const copies: IModel[] = (await (await this.checkpoints).getItem(path)) || [];\n    return copies.filter(Boolean).map(this.normalizeCheckpoint, this);\n  }\n\n  protected normalizeCheckpoint(\n    model: IModel,\n    id: number\n  ): ServerContents.ICheckpointModel {\n    return { id: id.toString(), last_modified: model.last_modified };\n  }\n\n  /**\n   * Restore a file to a known checkpoint state.\n   *\n   * @param path - The path of the file.\n   * @param checkpointID - The id of the checkpoint to restore.\n   *\n   * @returns A promise which resolves when the checkpoint is restored.\n   */\n  async restoreCheckpoint(path: string, checkpointID: string): Promise<void> {\n    path = decodeURIComponent(path);\n    const copies = ((await (await this.checkpoints).getItem(path)) || []) as IModel[];\n    const id = parseInt(checkpointID);\n    const item = copies[id];\n    await (await this.storage).setItem(path, item);\n  }\n\n  /**\n   * Delete a checkpoint for a file.\n   *\n   * @param path - The path of the file.\n   * @param checkpointID - The id of the checkpoint to delete.\n   *\n   * @returns A promise which resolves when the checkpoint is deleted.\n   */\n  async deleteCheckpoint(path: string, checkpointID: string): Promise<void> {\n    path = decodeURIComponent(path);\n    const copies = ((await (await this.checkpoints).getItem(path)) || []) as IModel[];\n    const id = parseInt(checkpointID);\n    copies.splice(id, 1);\n    await (await this.checkpoints).setItem(path, copies);\n  }\n\n  /**\n   * Handle a chunk of a file.\n   * Decode and unescape a base64-encoded string.\n   * @param content the content to process\n   *\n   * @returns the decoded string, appended to the original content if chunked\n   * /\n   */\n  private _handleChunk(\n    newContent: string,\n    originalContent: string,\n    chunked?: boolean\n  ): string {\n    const escaped = decodeURIComponent(escape(atob(newContent)));\n    const content = chunked ? originalContent + escaped : escaped;\n    return content;\n  }\n\n  /**\n   * retrieve the contents for this path from the union of local storage and\n   * `api/contents/{path}/all.json`.\n   *\n   * @param path - The contents path to retrieve\n   *\n   * @returns A promise which resolves with a Map of contents, keyed by local file name\n   */\n  private async _getFolder(path: string): Promise<IModel | null> {\n    const content = new Map<string, IModel>();\n    const storage = await this.storage;\n    await storage.iterate<IModel, void>((file, key) => {\n      if (key.includes('/')) {\n        return;\n      }\n      content.set(file.path, file);\n    });\n\n    // layer in contents that don't have local overwrites\n    for (const file of (await this._getServerDirectory(path)).values()) {\n      if (!content.has(file.path)) {\n        content.set(file.path, file);\n      }\n    }\n\n    if (path && content.size === 0) {\n      return null;\n    }\n\n    return {\n      name: '',\n      path,\n      last_modified: new Date(0).toISOString(),\n      created: new Date(0).toISOString(),\n      format: 'json',\n      mimetype: MIME.JSON,\n      content: Array.from(content.values()),\n      size: 0,\n      writable: true,\n      type: 'directory',\n    };\n  }\n\n  /**\n   * Attempt to recover the model from `{:path}/__all__.json` file, fall back to\n   * deriving the model (including content) off the file in `/files/`. Otherwise\n   * return `null`.\n   */\n  private async _getServerContents(\n    path: string,\n    options?: ServerContents.IFetchOptions\n  ): Promise<IModel | null> {\n    const name = PathExt.basename(path);\n    const parentContents = await this._getServerDirectory(URLExt.join(path, '..'));\n    let model = parentContents.get(name);\n    if (!model) {\n      return null;\n    }\n    model = model || {\n      name,\n      path,\n      last_modified: new Date(0).toISOString(),\n      created: new Date(0).toISOString(),\n      format: 'text',\n      mimetype: MIME.PLAIN_TEXT,\n      type: 'file',\n      writable: true,\n      size: 0,\n      content: '',\n    };\n\n    if (options?.content) {\n      if (model.type === 'directory') {\n        const serverContents = await this._getServerDirectory(path);\n        model = { ...model, content: Array.from(serverContents.values()) };\n      } else {\n        const fileUrl = URLExt.join(PageConfig.getBaseUrl(), 'files', path);\n        const response = await fetch(fileUrl);\n        if (!response.ok) {\n          return null;\n        }\n        const mimetype = model.mimetype || response.headers.get('Content-Type');\n        const ext = PathExt.extname(name);\n\n        if (\n          model.type === 'notebook' ||\n          FILE.hasFormat(ext, 'json') ||\n          mimetype?.indexOf('json') !== -1 ||\n          path.match(/\\.(ipynb|[^/]*json[^/]*)$/)\n        ) {\n          const contentText = await response.text();\n          model = {\n            ...model,\n            content: JSON.parse(contentText),\n            format: 'json',\n            mimetype: model.mimetype || MIME.JSON,\n            size: contentText.length,\n          };\n        } else if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n          const contentText = await response.text();\n          model = {\n            ...model,\n            content: contentText,\n            format: 'text',\n            mimetype: mimetype || MIME.PLAIN_TEXT,\n            size: contentText.length,\n          };\n        } else {\n          const contentBytes = await response.arrayBuffer();\n          const contentBuffer = new Uint8Array(contentBytes);\n          model = {\n            ...model,\n            content: btoa(contentBuffer.reduce(this.reduceBytesToString, '')),\n            format: 'base64',\n            mimetype: mimetype || MIME.OCTET_STREAM,\n            size: contentBuffer.length,\n          };\n        }\n      }\n    }\n\n    return model;\n  }\n\n  /**\n   * A reducer for turning arbitrary binary into a string\n   */\n  protected reduceBytesToString = (data: string, byte: number): string => {\n    return data + String.fromCharCode(byte);\n  };\n\n  /**\n   * retrieve the contents for this path from `__index__.json` in the appropriate\n   * folder.\n   *\n   * @param newLocalPath - The new file path.\n   *\n   * @returns A promise which resolves with a Map of contents, keyed by local file name\n   */\n  private async _getServerDirectory(path: string): Promise<Map<string, IModel>> {\n    const content = this._serverContents.get(path) || new Map();\n\n    if (!this._serverContents.has(path)) {\n      const apiURL = URLExt.join(\n        PageConfig.getBaseUrl(),\n        'api/contents',\n        path,\n        'all.json'\n      );\n\n      try {\n        const response = await fetch(apiURL);\n        const json = JSON.parse(await response.text());\n        for (const file of json['content'] as IModel[]) {\n          content.set(file.name, file);\n        }\n      } catch (err) {\n        console.warn(\n          `don't worry, about ${err}... nothing's broken. If there had been a\n          file at ${apiURL}, you might see some more files.`\n        );\n      }\n      this._serverContents.set(path, content);\n    }\n\n    return content;\n  }\n\n  /**\n   * Increment the counter for a given file type.\n   * Used to avoid collisions when creating new untitled files.\n   *\n   * @param type The file type to increment the counter for.\n   */\n  private async _incrementCounter(type: ServerContents.ContentType): Promise<number> {\n    const counters = await this.counters;\n    const current = ((await counters.getItem(type)) as number) ?? -1;\n    const counter = current + 1;\n    await counters.setItem(type, counter);\n    return counter;\n  }\n\n  private _serverContents = new Map<string, Map<string, IModel>>();\n  private _storageName: string = DEFAULT_STORAGE_NAME;\n  private _storageDrivers: string[] | null = null;\n  private _ready: PromiseDelegate<void>;\n  private _storage: LocalForage | undefined;\n  private _counters: LocalForage | undefined;\n  private _checkpoints: LocalForage | undefined;\n  private _localforage: typeof localforage;\n}\n\n/**\n * A namespace for contents information.\n */\nexport namespace Contents {\n  export interface IOptions {\n    /**\n     * The name of the storage instance on e.g. IndexedDB, localStorage\n     */\n    storageName?: string | null;\n    storageDrivers?: string[] | null;\n    localforage: typeof localforage;\n  }\n}\n\n/**\n * A namespace for private data.\n */\nnamespace Private {\n  /**\n   * The content for an empty notebook.\n   */\n  export const EMPTY_NB: INotebookContent = {\n    metadata: {\n      orig_nbformat: 4,\n    },\n    nbformat_minor: 4,\n    nbformat: 4,\n    cells: [],\n  };\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n// Types and implementation inspired from https://github.com/jvilk/BrowserFS\n// LICENSE: https://github.com/jvilk/BrowserFS/blob/8977a704ea469d05daf857e4818bef1f4f498326/LICENSE\n// And from https://github.com/gzuidhof/starboard-notebook\n\n// LICENSE: https://github.com/gzuidhof/starboard-notebook/blob/cd8d3fc30af4bd29cdd8f6b8c207df8138f5d5dd/LICENSE\n\n/**\n * Types for Emscripten primitives.\n *\n * Ideally, much more of these would be taken from `@types/emscripten`.\n */\n\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"../../../node_modules/@types/emscripten/index.d.ts\" />\ntype EmscriptenFS = typeof FS;\n\nexport const DIR_MODE = 16895; // 040777\nexport const FILE_MODE = 33206; // 100666\nexport const SEEK_CUR = 1;\nexport const SEEK_END = 2;\n\nexport interface IStats {\n  dev: number;\n  ino: number;\n  mode: number;\n  nlink: number;\n  uid: number;\n  gid: number;\n  rdev: number;\n  size: number;\n  blksize: number;\n  blocks: number;\n  atime: Date;\n  mtime: Date;\n  ctime: Date;\n  timestamp?: number;\n}\n\nexport interface IEmscriptenFSNode {\n  id: number;\n  name: string;\n  mode: number;\n  parent: IEmscriptenFSNode;\n  mount: { opts: { root: string } };\n  stream_ops: IEmscriptenStreamOps;\n  node_ops: IEmscriptenNodeOps;\n  timestamp: number;\n}\n\nexport interface IEmscriptenStream {\n  node: IEmscriptenFSNode;\n  nfd: any;\n  flags: string;\n  position: number;\n}\n\nexport interface IEmscriptenNodeOps {\n  getattr(node: IEmscriptenFSNode): IStats;\n  setattr(node: IEmscriptenFSNode, attr: IStats): void;\n  lookup(parent: IEmscriptenFSNode, name: string): IEmscriptenFSNode;\n  mknod(\n    parent: IEmscriptenFSNode,\n    name: string,\n    mode: number,\n    dev: number\n  ): IEmscriptenFSNode;\n  rename(oldNode: IEmscriptenFSNode, newDir: IEmscriptenFSNode, newName: string): void;\n  unlink(parent: IEmscriptenFSNode, name: string): void;\n  rmdir(parent: IEmscriptenFSNode, name: string): void;\n  readdir(node: IEmscriptenFSNode): string[];\n  symlink(parent: IEmscriptenFSNode, newName: string, oldPath: string): void;\n  readlink(node: IEmscriptenFSNode): string;\n}\n\nexport interface IEmscriptenStreamOps {\n  open(stream: IEmscriptenStream): void;\n  close(stream: IEmscriptenStream): void;\n  read(\n    stream: IEmscriptenStream,\n    buffer: Uint8Array,\n    offset: number,\n    length: number,\n    position: number\n  ): number;\n  write(\n    stream: IEmscriptenStream,\n    buffer: Uint8Array,\n    offset: number,\n    length: number,\n    position: number\n  ): number;\n  llseek(stream: IEmscriptenStream, offset: number, whence: number): number;\n}\n\n/**\n * The emscripten filesystem module API.\n */\nexport type FS = EmscriptenFS & {\n  ErrnoError: any;\n  createNode: (\n    parent: IEmscriptenFSNode | null,\n    name: string,\n    mode: number,\n    dev: number\n  ) => IEmscriptenFSNode;\n};\n\n/**\n * The emscripten filesystem error codes.\n */\nexport type ERRNO_CODES = any;\n\n/**\n * The emscripten FS Path API.\n */\nexport type PATH = {\n  basename: (path: string) => string;\n  dirname: (path: string) => string;\n  join: (...parts: string[]) => string;\n  join2: (l: string, r: string) => string;\n  normalize: (path: string) => string;\n  splitPath: (filename: string) => string;\n};\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n// Types and implementation inspired from https://github.com/jvilk/BrowserFS\n// LICENSE: https://github.com/jvilk/BrowserFS/blob/8977a704ea469d05daf857e4818bef1f4f498326/LICENSE\n// And from https://github.com/gzuidhof/starboard-notebook\n\n// LICENSE: https://github.com/gzuidhof/starboard-notebook/blob/cd8d3fc30af4bd29cdd8f6b8c207df8138f5d5dd/LICENSE\nimport {\n  FS,\n  ERRNO_CODES,\n  PATH,\n  DIR_MODE,\n  SEEK_CUR,\n  SEEK_END,\n  IEmscriptenStream,\n  IEmscriptenStreamOps,\n  IEmscriptenNodeOps,\n  IEmscriptenFSNode,\n  IStats,\n} from './emscripten';\n\nexport const DRIVE_SEPARATOR = ':';\nexport const DRIVE_API_PATH = '/api/drive.v1';\n\nexport const BLOCK_SIZE = 4096;\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder('utf-8');\n\nexport type TDriveMethod =\n  | 'readdir'\n  | 'rmdir'\n  | 'rename'\n  | 'getmode'\n  | 'lookup'\n  | 'mknod'\n  | 'getattr'\n  | 'get'\n  | 'put';\n\n/**\n * Interface of a request on the /api/drive endpoint\n */\nexport interface IDriveRequest {\n  /**\n   * The method of the request (rmdir, readdir etc)\n   */\n  method: TDriveMethod;\n\n  /**\n   * The path to the file/directory for which the request was sent\n   */\n  path: string;\n\n  /**\n   * Extra data on the request\n   */\n  data?: any;\n}\n\n// Mapping flag -> do we need to overwrite the file upon closing it\nconst flagNeedsWrite: { [flag: number]: boolean } = {\n  0 /*O_RDONLY*/: false,\n  1 /*O_WRONLY*/: true,\n  2 /*O_RDWR*/: true,\n  64 /*O_CREAT*/: true,\n  65 /*O_WRONLY|O_CREAT*/: true,\n  66 /*O_RDWR|O_CREAT*/: true,\n  129 /*O_WRONLY|O_EXCL*/: true,\n  193 /*O_WRONLY|O_CREAT|O_EXCL*/: true,\n  514 /*O_RDWR|O_TRUNC*/: true,\n  577 /*O_WRONLY|O_CREAT|O_TRUNC*/: true,\n  578 /*O_CREAT|O_RDWR|O_TRUNC*/: true,\n  705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: true,\n  706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: true,\n  1024 /*O_APPEND*/: true,\n  1025 /*O_WRONLY|O_APPEND*/: true,\n  1026 /*O_RDWR|O_APPEND*/: true,\n  1089 /*O_WRONLY|O_CREAT|O_APPEND*/: true,\n  1090 /*O_RDWR|O_CREAT|O_APPEND*/: true,\n  1153 /*O_WRONLY|O_EXCL|O_APPEND*/: true,\n  1154 /*O_RDWR|O_EXCL|O_APPEND*/: true,\n  1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: true,\n  1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: true,\n  4096 /*O_RDONLY|O_DSYNC*/: true,\n  4098 /*O_RDWR|O_DSYNC*/: true,\n};\n\n/** Implementation-specifc extension of an open stream, adding the file. */\nexport interface IDriveStream extends IEmscriptenStream {\n  file?: DriveFS.IFile;\n}\n\nexport class DriveFSEmscriptenStreamOps implements IEmscriptenStreamOps {\n  private fs: DriveFS;\n\n  constructor(fs: DriveFS) {\n    this.fs = fs;\n  }\n\n  open(stream: IDriveStream): void {\n    const path = this.fs.realPath(stream.node);\n    if (this.fs.FS.isFile(stream.node.mode)) {\n      stream.file = this.fs.API.get(path);\n    }\n  }\n\n  close(stream: IDriveStream): void {\n    if (!this.fs.FS.isFile(stream.node.mode) || !stream.file) {\n      return;\n    }\n\n    const path = this.fs.realPath(stream.node);\n\n    const flags = stream.flags;\n    let parsedFlags = typeof flags === 'string' ? parseInt(flags, 10) : flags;\n    parsedFlags &= 0x1fff;\n\n    let needsWrite = true;\n    if (parsedFlags in flagNeedsWrite) {\n      needsWrite = flagNeedsWrite[parsedFlags];\n    }\n\n    if (needsWrite) {\n      this.fs.API.put(path, stream.file);\n    }\n\n    stream.file = undefined;\n  }\n\n  read(\n    stream: IDriveStream,\n    buffer: Uint8Array,\n    offset: number,\n    length: number,\n    position: number\n  ): number {\n    if (\n      length <= 0 ||\n      stream.file === undefined ||\n      position >= (stream.file.data.length || 0)\n    ) {\n      return 0;\n    }\n\n    const size = Math.min(stream.file.data.length - position, length);\n    buffer.set(stream.file.data.subarray(position, position + size), offset);\n    return size;\n  }\n\n  write(\n    stream: IDriveStream,\n    buffer: Uint8Array,\n    offset: number,\n    length: number,\n    position: number\n  ): number {\n    if (length <= 0 || stream.file === undefined) {\n      return 0;\n    }\n\n    stream.node.timestamp = Date.now();\n\n    if (position + length > (stream.file?.data.length || 0)) {\n      const oldData = stream.file.data ? stream.file.data : new Uint8Array();\n      stream.file.data = new Uint8Array(position + length);\n      stream.file.data.set(oldData);\n    }\n\n    stream.file.data.set(buffer.subarray(offset, offset + length), position);\n\n    return length;\n  }\n\n  llseek(stream: IDriveStream, offset: number, whence: number): number {\n    let position = offset;\n    if (whence === SEEK_CUR) {\n      position += stream.position;\n    } else if (whence === SEEK_END) {\n      if (this.fs.FS.isFile(stream.node.mode)) {\n        if (stream.file !== undefined) {\n          position += stream.file.data.length;\n        } else {\n          throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EPERM);\n        }\n      }\n    }\n\n    if (position < 0) {\n      throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EINVAL);\n    }\n\n    return position;\n  }\n}\n\nexport class DriveFSEmscriptenNodeOps implements IEmscriptenNodeOps {\n  private fs: DriveFS;\n\n  constructor(fs: DriveFS) {\n    this.fs = fs;\n  }\n\n  getattr(node: IEmscriptenFSNode): IStats {\n    return {\n      ...this.fs.API.getattr(this.fs.realPath(node)),\n      mode: node.mode,\n      ino: node.id,\n    };\n  }\n\n  setattr(node: IEmscriptenFSNode, attr: IStats): void {\n    for (const [key, value] of Object.entries(attr)) {\n      switch (key) {\n        case 'mode':\n          node.mode = value;\n          break;\n        case 'timestamp':\n          node.timestamp = value;\n          break;\n        default:\n          console.warn('setattr', key, 'of', value, 'on', node, 'not yet implemented');\n          break;\n      }\n    }\n  }\n\n  lookup(parent: IEmscriptenFSNode, name: string): IEmscriptenFSNode {\n    const path = this.fs.PATH.join2(this.fs.realPath(parent), name);\n    const result = this.fs.API.lookup(path);\n    if (!result.ok) {\n      throw this.fs.FS.genericErrors[this.fs.ERRNO_CODES['ENOENT']];\n    }\n    return this.fs.createNode(parent, name, result.mode, 0);\n  }\n\n  mknod(\n    parent: IEmscriptenFSNode,\n    name: string,\n    mode: number,\n    dev: number\n  ): IEmscriptenFSNode {\n    const path = this.fs.PATH.join2(this.fs.realPath(parent), name);\n    this.fs.API.mknod(path, mode);\n    return this.fs.createNode(parent, name, mode, dev);\n  }\n\n  rename(oldNode: IEmscriptenFSNode, newDir: IEmscriptenFSNode, newName: string): void {\n    this.fs.API.rename(\n      oldNode.parent\n        ? this.fs.PATH.join2(this.fs.realPath(oldNode.parent), oldNode.name)\n        : oldNode.name,\n      this.fs.PATH.join2(this.fs.realPath(newDir), newName)\n    );\n\n    // Updating the in-memory node\n    oldNode.name = newName;\n    oldNode.parent = newDir;\n  }\n\n  unlink(parent: IEmscriptenFSNode, name: string): void {\n    this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(parent), name));\n  }\n\n  rmdir(parent: IEmscriptenFSNode, name: string) {\n    this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(parent), name));\n  }\n\n  readdir(node: IEmscriptenFSNode): string[] {\n    return this.fs.API.readdir(this.fs.realPath(node));\n  }\n\n  symlink(parent: IEmscriptenFSNode, newName: string, oldPath: string): void {\n    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n  }\n\n  readlink(node: IEmscriptenFSNode): string {\n    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n  }\n}\n\n/**\n * Wrap ServiceWorker requests for an Emscripten-compatible synchronous API.\n */\nexport class ContentsAPI {\n  constructor(\n    baseUrl: string,\n    driveName: string,\n    mountpoint: string,\n    FS: FS,\n    ERRNO_CODES: ERRNO_CODES\n  ) {\n    this._baseUrl = baseUrl;\n    this._driveName = driveName;\n    this._mountpoint = mountpoint;\n    this.FS = FS;\n    this.ERRNO_CODES = ERRNO_CODES;\n  }\n\n  request(data: IDriveRequest): any {\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', encodeURI(this.endpoint), false);\n\n    try {\n      xhr.send(JSON.stringify(data));\n    } catch (e) {\n      console.error(e);\n    }\n\n    if (xhr.status >= 400) {\n      throw new this.FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n    }\n\n    return JSON.parse(xhr.responseText);\n  }\n\n  lookup(path: string): DriveFS.ILookup {\n    return this.request({ method: 'lookup', path: this.normalizePath(path) });\n  }\n\n  getmode(path: string): number {\n    return Number.parseInt(\n      this.request({ method: 'getmode', path: this.normalizePath(path) })\n    );\n  }\n\n  mknod(path: string, mode: number) {\n    return this.request({\n      method: 'mknod',\n      path: this.normalizePath(path),\n      data: { mode },\n    });\n  }\n\n  rename(oldPath: string, newPath: string): void {\n    return this.request({\n      method: 'rename',\n      path: this.normalizePath(oldPath),\n      data: { newPath: this.normalizePath(newPath) },\n    });\n  }\n\n  readdir(path: string): string[] {\n    const dirlist = this.request({\n      method: 'readdir',\n      path: this.normalizePath(path),\n    });\n    dirlist.push('.');\n    dirlist.push('..');\n    return dirlist;\n  }\n\n  rmdir(path: string): void {\n    return this.request({ method: 'rmdir', path: this.normalizePath(path) });\n  }\n\n  get(path: string): DriveFS.IFile {\n    const response = this.request({ method: 'get', path: this.normalizePath(path) });\n\n    const serializedContent = response.content;\n    const format: 'json' | 'text' | 'base64' | null = response.format;\n\n    switch (format) {\n      case 'json':\n      case 'text':\n        return {\n          data: encoder.encode(serializedContent),\n          format,\n        };\n      case 'base64': {\n        const binString = atob(serializedContent);\n        const len = binString.length;\n        const data = new Uint8Array(len);\n        for (let i = 0; i < len; i++) {\n          data[i] = binString.charCodeAt(i);\n        }\n        return {\n          data,\n          format,\n        };\n      }\n      default:\n        throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);\n    }\n  }\n\n  put(path: string, value: DriveFS.IFile) {\n    switch (value.format) {\n      case 'json':\n      case 'text':\n        return this.request({\n          method: 'put',\n          path: this.normalizePath(path),\n          data: {\n            format: value.format,\n            data: decoder.decode(value.data),\n          },\n        });\n      case 'base64': {\n        let binary = '';\n        for (let i = 0; i < value.data.byteLength; i++) {\n          binary += String.fromCharCode(value.data[i]);\n        }\n        return this.request({\n          method: 'put',\n          path: this.normalizePath(path),\n          data: {\n            format: value.format,\n            data: btoa(binary),\n          },\n        });\n      }\n    }\n  }\n\n  getattr(path: string): IStats {\n    const stats: IStats = this.request({\n      method: 'getattr',\n      path: this.normalizePath(path),\n    });\n    // Turn datetimes into proper objects\n    stats.atime = new Date(stats.atime);\n    stats.mtime = new Date(stats.mtime);\n    stats.ctime = new Date(stats.ctime);\n    // ensure a non-undefined size (0 isn't great, though)\n    stats.size = stats.size || 0;\n    return stats;\n  }\n\n  /**\n   * Normalize a Path by making it compliant for the content manager\n   *\n   * @param path: the path relatively to the Emscripten drive\n   */\n  normalizePath(path: string): string {\n    // Remove mountpoint prefix\n    if (path.startsWith(this._mountpoint)) {\n      path = path.slice(this._mountpoint.length);\n    }\n\n    // Add JupyterLab drive name\n    if (this._driveName) {\n      path = `${this._driveName}${DRIVE_SEPARATOR}${path}`;\n    }\n\n    return path;\n  }\n\n  /**\n   * Get the api/drive endpoint\n   */\n  get endpoint(): string {\n    return `${this._baseUrl}api/drive`;\n  }\n\n  private _baseUrl: string;\n  private _driveName: string;\n  private _mountpoint: string;\n  private FS: FS;\n  private ERRNO_CODES: ERRNO_CODES;\n}\n\nexport class DriveFS {\n  FS: FS;\n  API: ContentsAPI;\n  PATH: PATH;\n  ERRNO_CODES: ERRNO_CODES;\n  driveName: string;\n\n  constructor(options: DriveFS.IOptions) {\n    this.FS = options.FS;\n    this.PATH = options.PATH;\n    this.ERRNO_CODES = options.ERRNO_CODES;\n    this.API = new ContentsAPI(\n      options.baseUrl,\n      options.driveName,\n      options.mountpoint,\n      this.FS,\n      this.ERRNO_CODES\n    );\n    this.driveName = options.driveName;\n\n    this.node_ops = new DriveFSEmscriptenNodeOps(this);\n    this.stream_ops = new DriveFSEmscriptenStreamOps(this);\n  }\n\n  node_ops: IEmscriptenNodeOps;\n  stream_ops: IEmscriptenStreamOps;\n\n  mount(mount: any): IEmscriptenFSNode {\n    return this.createNode(null, mount.mountpoint, DIR_MODE | 511, 0);\n  }\n\n  createNode(\n    parent: IEmscriptenFSNode | null,\n    name: string,\n    mode: number,\n    dev: number\n  ): IEmscriptenFSNode {\n    const FS = this.FS;\n    if (!FS.isDir(mode) && !FS.isFile(mode)) {\n      throw new FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n    }\n    const node = FS.createNode(parent, name, mode, dev);\n    node.node_ops = this.node_ops;\n    node.stream_ops = this.stream_ops;\n    return node;\n  }\n\n  getMode(path: string): number {\n    return this.API.getmode(path);\n  }\n\n  realPath(node: IEmscriptenFSNode): string {\n    const parts: string[] = [];\n    let currentNode: IEmscriptenFSNode = node;\n\n    parts.push(currentNode.name);\n    while (currentNode.parent !== currentNode) {\n      currentNode = currentNode.parent;\n      parts.push(currentNode.name);\n    }\n    parts.reverse();\n\n    return this.PATH.join.apply(null, parts);\n  }\n}\n\n/**\n * A namespace for DriveFS configurations, etc.\n */\nexport namespace DriveFS {\n  /**\n   * A file representation;\n   */\n  export interface IFile {\n    data: Uint8Array;\n    format: 'json' | 'text' | 'base64';\n  }\n\n  /**\n   * The response to a lookup request;\n   */\n  export interface ILookup {\n    ok: boolean;\n    mode: number;\n  }\n\n  /**\n   * Initialization options for a drive;\n   */\n  export interface IOptions {\n    FS: FS;\n    PATH: PATH;\n    ERRNO_CODES: ERRNO_CODES;\n    baseUrl: string;\n    driveName: string;\n    mountpoint: string;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { PathExt } from '@jupyterlab/coreutils';\n\nimport { Contents as ServerContents, ContentsManager } from '@jupyterlab/services';\n\nimport { DIR_MODE, FILE_MODE } from './emscripten';\n\nimport { BLOCK_SIZE, IDriveRequest, DRIVE_API_PATH } from './drivefs';\n\nimport { IModel } from './contents';\n\nimport { IBroadcastChannelWrapper } from './tokens';\n\n/** A broadcaster for the ServiceWorker */\nexport class BroadcastChannelWrapper implements IBroadcastChannelWrapper {\n  public isDisposed = false;\n\n  constructor(options: BroadcastChannelWrapper.IOptions) {\n    this._contents = options.contents;\n  }\n\n  get enabled() {\n    return this._enabled;\n  }\n\n  enable() {\n    if (this._channel) {\n      console.warn('BroadcastChannel already created and enabled');\n      return;\n    }\n    this._channel = new BroadcastChannel(DRIVE_API_PATH);\n    this._channel.addEventListener('message', this._onMessage);\n    this._enabled = true;\n  }\n\n  disable() {\n    if (this._channel) {\n      this._channel.removeEventListener('message', this._onMessage);\n      this._channel = null;\n    }\n    this._enabled = false;\n  }\n\n  /** Clean up the broadcaster. */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n    this.disable();\n    this.isDisposed = true;\n  }\n\n  /** Handle a message received on the BroadcastChannel */\n  protected _onMessage = async (event: MessageEvent<IDriveRequest>): Promise<void> => {\n    if (!this._channel) {\n      return;\n    }\n    const { _contents } = this;\n    const request = event.data;\n    const { path } = request;\n\n    // many successful responses default to null\n    let response: any = null;\n\n    // most requests will use a model\n    let model: ServerContents.IModel;\n\n    switch (request.method) {\n      case 'readdir':\n        model = await _contents.get(path, { content: true });\n        response = [];\n        if (model.type === 'directory' && model.content) {\n          response = model.content.map((subcontent: IModel) => subcontent.name);\n        }\n        break;\n      case 'rmdir':\n        await _contents.delete(path);\n        break;\n      case 'rename':\n        await _contents.rename(path, request.data.newPath);\n        break;\n      case 'getmode':\n        model = await _contents.get(path);\n        if (model.type === 'directory') {\n          response = DIR_MODE;\n        } else {\n          response = FILE_MODE;\n        }\n        break;\n      case 'lookup':\n        try {\n          model = await _contents.get(path);\n          response = {\n            ok: true,\n            mode: model.type === 'directory' ? DIR_MODE : FILE_MODE,\n          };\n        } catch (e) {\n          response = { ok: false };\n        }\n        break;\n      case 'mknod':\n        model = await _contents.newUntitled({\n          path: PathExt.dirname(path),\n          type: Number.parseInt(request.data.mode) === DIR_MODE ? 'directory' : 'file',\n          ext: PathExt.extname(path),\n        });\n        await _contents.rename(model.path, path);\n        break;\n      case 'getattr':\n        model = await _contents.get(path);\n\n        response = {\n          dev: 1,\n          nlink: 1,\n          uid: 0,\n          gid: 0,\n          rdev: 0,\n          size: model.size || 0,\n          blksize: BLOCK_SIZE,\n          blocks: Math.ceil(model.size || 0 / BLOCK_SIZE),\n          atime: model.last_modified, // TODO Get the proper atime?\n          mtime: model.last_modified,\n          ctime: model.created,\n          timestamp: 0,\n        };\n        break;\n      case 'get':\n        model = await _contents.get(path, { content: true });\n\n        if (model.type === 'directory') {\n          break;\n        }\n\n        response = {\n          content:\n            model.format === 'json' ? JSON.stringify(model.content) : model.content,\n          format: model.format,\n        };\n        break;\n      case 'put':\n        await _contents.save(path, {\n          content:\n            request.data.format === 'json'\n              ? JSON.parse(request.data.data)\n              : request.data.data,\n          type: 'file',\n          format: request.data.format as ServerContents.FileFormat,\n        });\n        break;\n      default:\n        response = null as never;\n        break;\n    }\n\n    this._channel.postMessage(response);\n  };\n\n  protected _channel: BroadcastChannel | null = null;\n  protected _contents: ContentsManager;\n  protected _enabled = false;\n}\n\n/** A namespace for  */\nexport namespace BroadcastChannelWrapper {\n  export interface IOptions {\n    contents: ContentsManager;\n  }\n  export type TBroadcastResponse = any;\n}\n"],"names":["IContents","Token","MIME","FILE","JSON","PLAIN_TEXT","OCTET_STREAM","TYPES","parse","PageConfig","getType","ext","defaultType","toLowerCase","fileType","Object","values","fileExt","extensions","mimeTypes","length","hasFormat","fileFormat","IBroadcastChannelWrapper","DEFAULT_STORAGE_NAME","Contents","constructor","options","reduceBytesToString","data","byte","String","fromCharCode","_serverContents","Map","_storageName","_storageDrivers","this","_localforage","localforage","storageName","storageDrivers","_ready","PromiseDelegate","async","initStorage","resolve","_storage","createDefaultStorage","_counters","createDefaultCounters","_checkpoints","createDefaultCheckpoints","ready","promise","storage","then","counters","checkpoints","defaultStorageOptions","driver","version","name","createInstance","description","storeName","path","type","created","Date","toISOString","dirname","PathExt","basename","extname","item","get","file","_incrementCounter","last_modified","format","mimetype","content","size","writable","counter","Private","EMPTY_NB","stringify","indexOf","key","setItem","toDir","slice","base","replace","toPath","Error","decodeURIComponent","_getFolder","getItem","serverItem","_getServerContents","model","contentMap","iterate","set","serverContents","Array","from","_getServerDirectory","has","oldLocalPath","newLocalPath","modified","newFile","removeItem","child","rename","URLExt","chunk","chunked","newUntitled","originalContent","lastChunk","_handleChunk","atob","slashed","toDelete","keys","filter","startsWith","Promise","all","map","forgetPath","copies","Boolean","push","splice","id","normalizeCheckpoint","toString","checkpointID","parseInt","newContent","escaped","escape","includes","fileUrl","response","fetch","ok","headers","match","contentText","text","contentBytes","arrayBuffer","contentBuffer","Uint8Array","btoa","reduce","apiURL","json","err","console","warn","metadata","orig_nbformat","nbformat_minor","nbformat","cells","DIR_MODE","FILE_MODE","SEEK_CUR","SEEK_END","DRIVE_SEPARATOR","DRIVE_API_PATH","BLOCK_SIZE","encoder","TextEncoder","decoder","TextDecoder","flagNeedsWrite","DriveFSEmscriptenStreamOps","fs","open","stream","realPath","node","FS","isFile","mode","API","close","flags","parsedFlags","needsWrite","put","undefined","read","buffer","offset","position","Math","min","subarray","write","timestamp","now","oldData","llseek","whence","ErrnoError","ERRNO_CODES","EPERM","EINVAL","DriveFSEmscriptenNodeOps","getattr","ino","setattr","attr","value","entries","lookup","parent","PATH","join2","result","genericErrors","createNode","mknod","dev","oldNode","newDir","newName","unlink","rmdir","readdir","symlink","oldPath","readlink","ContentsAPI","baseUrl","driveName","mountpoint","_baseUrl","_driveName","_mountpoint","request","xhr","XMLHttpRequest","encodeURI","endpoint","send","e","error","status","responseText","method","normalizePath","getmode","Number","newPath","dirlist","serializedContent","encode","binString","len","i","charCodeAt","decode","binary","byteLength","stats","atime","mtime","ctime","DriveFS","node_ops","stream_ops","mount","isDir","getMode","parts","currentNode","reverse","join","apply","BroadcastChannelWrapper","isDisposed","_onMessage","event","_channel","_contents","subcontent","delete","nlink","uid","gid","rdev","blksize","blocks","ceil","save","postMessage","_enabled","contents","enabled","enable","BroadcastChannel","addEventListener","disable","removeEventListener","dispose"],"sourceRoot":""}