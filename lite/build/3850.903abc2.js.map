{"version":3,"file":"3850.903abc2.js","mappings":";gNA6VUA,0BA7TR,WAAYC,GA2RJ,KAAAC,MAAyB,IAAIF,EAAQG,SA1R3CC,KAAKH,IAAMA,EA2Rf,OA1QE,sBAAI,sBAAO,KAAX,WACE,OAA2B,IAApBG,KAAKF,MAAMG,sCASpB,sBAAI,mBAAI,KAAR,WACE,OAAOD,KAAKF,MAAMG,sCAWpB,sBAAI,oBAAK,KAAT,WACE,IAAIC,EAAON,EAAQO,UAAUH,KAAKF,OAClC,OAAOI,EAAKD,KAAO,EAAIC,EAAKE,MAAM,QAAKC,mCAWzC,sBAAI,mBAAI,KAAR,WACE,IAAIH,EAAON,EAAQU,SAASN,KAAKF,OACjC,OAAOI,EAAKD,KAAO,EAAIC,EAAKE,MAAMF,EAAKD,KAAO,QAAKI,mCAWrD,YAAAE,KAAA,WACE,OAAOX,EAAQY,UAAUR,KAAKF,QAWhC,YAAAW,MAAA,WACE,OAAOb,EAAQc,WAAWV,KAAKF,QAmBjC,YAAAa,MAAA,SAAMC,EAAgBC,GACpB,OAAOjB,EAAQkB,WAAWd,KAAKF,MAAOc,EAAOC,IAmB/C,YAAAE,WAAA,SAAWH,EAAgBC,GACzB,OAAOjB,EAAQoB,gBAAgBhB,KAAKF,MAAOc,EAAOC,IAepD,YAAAI,GAAA,SAAGC,GACD,OAAOtB,EAAQuB,OAAOnB,KAAKF,MAAOoB,IAgBpC,YAAAE,IAAA,SAAOC,EAAQxB,GACb,OAAOD,EAAQ0B,QAAQtB,KAAKF,MAAOuB,EAAKxB,IAiB1C,YAAA0B,QAAA,SAAWF,EAAQxB,GACjB,OAAOD,EAAQ2B,QAAQvB,KAAKF,MAAOuB,EAAKxB,IAgB1C,YAAA2B,IAAA,SAAOH,EAAQxB,GACb,OAAOD,EAAQ6B,QAAQzB,KAAKF,MAAOuB,EAAKxB,IAW1C,YAAA6B,OAAA,SAAOtB,GACLJ,KAAK2B,QACL3B,KAAK4B,OAAOxB,IAed,YAAAyB,OAAA,SAAOC,GACL,IAAIC,EAAWnC,EAAQoC,WAAWhC,KAAKF,MAAOgC,EAAM9B,KAAKH,KAEzD,OADAG,KAAKF,MAAQF,EAAQqC,eAAejC,KAAKF,OAClCiC,GAWT,YAAAH,OAAA,SAAOxB,GAAP,YACE,IAAA8B,MAAK9B,GAAO,SAAA0B,GACV,EAAKD,OAAOC,OAiBhB,YAAAK,OAAA,SAAUd,EAAQxB,GAChB,IAAIiC,EAAOlC,EAAQwC,WAAWpC,KAAKF,MAAOuB,EAAKxB,GAE/C,OADAG,KAAKF,MAAQF,EAAQyC,iBAAiBrC,KAAKF,OACpCgC,GAeT,YAAAQ,OAAA,SAAOpB,GACL,IAAIY,EAAOlC,EAAQ2C,WAAWvC,KAAKF,MAAOoB,GAE1C,OADAlB,KAAKF,MAAQF,EAAQyC,iBAAiBrC,KAAKF,OACpCgC,GAST,YAAAH,MAAA,WACE/B,EAAQ+B,MAAM3B,KAAKF,OACnBE,KAAKF,MAAQ,IAAIF,EAAQG,UAI7B,MAOA,SAAiByC,GAaC,EAAAC,KAAhB,SACErC,EACAP,GAEA,IAAI6C,EAAO,IAAIF,EAAa3C,GAE5B,OADA6C,EAAKhB,OAAOtB,GACLsC,EAEV,CArBD,CAAiBF,IAAAA,EAAS,KA0B1B,SAAU5C,GAYR,8BAIW,KAAAQ,MAAa,GAKb,KAAAuC,MAAkB,GAKlB,KAAAC,SAAsB,GAsBjC,OAjBE,sBAAI,mBAAI,KAAR,WACE,OAAO,mCAMT,sBAAI,mBAAI,KAAR,WACE,OAAO5C,KAAK2C,MAAM3C,KAAK2C,MAAME,OAAS,oCAMxC,sBAAI,oBAAK,KAAT,WACE,OAAO7C,KAAK4C,SAASC,wCAEzB,EApCA,GAAa,EAAAC,WAAU,EAyCvB,8BAIE,KAAAC,KAA2B,KAK3B,KAAAC,KAA2B,KAKlB,KAAA5C,MAAa,GAsBxB,OAjBE,sBAAI,mBAAI,KAAR,WACE,OAAO,mCAMT,sBAAI,mBAAI,KAAR,WACE,OAAOJ,KAAKI,MAAMyC,wCAMpB,sBAAI,oBAAK,KAAT,WACE,OAAO7C,KAAKI,MAAMyC,wCAEtB,EApCA,GAqDA,SAAgB1C,EAAaD,GAC3B,KAAqB,IAAdA,EAAK+C,MACV/C,EAAOA,EAAK0C,SAAS,GAEvB,OAAO1C,EAaT,SAAgBI,EAAYJ,GAC1B,KAAqB,IAAdA,EAAK+C,MACV/C,EAAOA,EAAK0C,SAAS1C,EAAK0C,SAASC,OAAS,GAE9C,OAAO3C,EA2fT,SAAgByB,EAASzB,GACL,IAAdA,EAAK+C,OACP,IAAAf,MAAKhC,EAAK0C,SAAUjB,GACpBzB,EAAK0C,SAASC,OAAS,EACvB3C,EAAKyC,MAAME,OAAS,EACpB3C,EAAKE,MAAMyC,OAAS,IAEpB3C,EAAKE,MAAMyC,OAAS,EACpB3C,EAAK6C,KAAO,KACZ7C,EAAK8C,KAAO,MA9kBH,EAAAjD,SAAQ,EAqDL,EAAAI,UAAS,EAiBT,EAAAG,SAAQ,EAiBR,EAAAE,UAAhB,SAA6BN,GAC3B,IAAIgD,EAAO/C,EAAUD,GACrB,OAAO,IAAIiD,EAAmBD,EAAM,GAAI,IAa1B,EAAAxC,WAAhB,SAA8BR,GAC5B,IAAIgD,EAAO5C,EAASJ,GACpB,OAAO,IAAIkD,EAAiBF,EAAMA,EAAKjD,KAAO,GAAI,IAqBpC,EAAAa,WAAhB,SACEZ,EACAU,EACAC,GAIED,OADYP,IAAVO,EACM,EACCA,EAAQ,EACTyC,KAAKC,IAAI,EAAG1C,EAAQV,EAAKD,MAEzBoD,KAAKE,IAAI3C,EAAOV,EAAKD,MAK7BY,OADWR,IAATQ,EACKX,EAAKD,KACHY,EAAO,EACTwC,KAAKC,IAAI,EAAGzC,EAAOX,EAAKD,MAExBoD,KAAKE,IAAI1C,EAAMX,EAAKD,MAI7B,IAAIuD,EAAQH,KAAKC,IAAI,EAAGzC,EAAOD,GAG/B,GAAc,IAAV4C,EACF,OAAO,IAAAC,SAIT,KAAqB,IAAdvD,EAAK+C,MAA0B,CACpC,IAAIS,EAAIC,EAAsBzD,EAAKyC,MAAO/B,GACtC8C,EAAI,IAAG9C,GAASV,EAAKyC,MAAMe,EAAI,IACnCxD,EAAOA,EAAK0C,SAASc,GAIvB,OAAO,IAAIP,EAAmBjD,EAAMU,EAAO4C,IAqB7B,EAAAxC,gBAAhB,SACEd,EACAU,EACAC,GAIED,OADYP,IAAVO,EACMV,EAAKD,KAAO,EACXW,EAAQ,EACTyC,KAAKC,KAAK,EAAG1C,EAAQV,EAAKD,MAE1BoD,KAAKE,IAAI3C,EAAOV,EAAKD,KAAO,GAKpCY,OADWR,IAATQ,GACM,EACCA,EAAO,EACTwC,KAAKC,KAAK,EAAGzC,EAAOX,EAAKD,MAEzBoD,KAAKE,IAAI1C,EAAMX,EAAKD,KAAO,GAIpC,IAAIuD,EAAQH,KAAKC,IAAI,EAAG1C,EAAQC,GAGhC,GAAc,IAAV2C,EACF,OAAO,IAAAC,SAIT,KAAqB,IAAdvD,EAAK+C,MAA0B,CACpC,IAAIS,EAAIC,EAAsBzD,EAAKyC,MAAO/B,GACtC8C,EAAI,IAAG9C,GAASV,EAAKyC,MAAMe,EAAI,IACnCxD,EAAOA,EAAK0C,SAASc,GAIvB,OAAO,IAAIN,EAAiBlD,EAAMU,EAAO4C,IAiB3B,EAAArC,OAAhB,SAA0BjB,EAAegB,GAOvC,GALIA,EAAQ,IACVA,GAAShB,EAAKD,QAIZiB,EAAQ,GAAKA,GAAShB,EAAKD,MAA/B,CAKA,KAAqB,IAAdC,EAAK+C,MAA0B,CACpC,IAAIS,EAAIC,EAAsBzD,EAAKyC,MAAOzB,GACtCwC,EAAI,IAAGxC,GAAShB,EAAKyC,MAAMe,EAAI,IACnCxD,EAAOA,EAAK0C,SAASc,GAIvB,OAAOxD,EAAKE,MAAMc,KAiBJ,EAAAI,QAAhB,SACEpB,EACAmB,EACAxB,GAGA,KAAqB,IAAdK,EAAK+C,MAA0B,CACpC,IAAI,EAAIW,EAAoB1D,EAAKE,MAAOiB,EAAKxB,GAC7CK,EAAOA,EAAK0C,SAAS,GAOvB,OAHQiB,EAAa3D,EAAKE,MAAOiB,EAAKxB,IAG1B,GAmBE,EAAA0B,QAAhB,SACErB,EACAmB,EACAxB,GAMA,IAHA,IAAIqB,EAAQ,EAGS,IAAdhB,EAAK+C,MAA0B,CACpC,IAAI,EAAIW,EAAoB1D,EAAKE,MAAOiB,EAAKxB,GACzC,EAAI,IAAGqB,GAAShB,EAAKyC,MAAM,EAAI,IACnCzC,EAAOA,EAAK0C,SAAS,GAIvB,IAAIc,EAAIG,EAAa3D,EAAKE,MAAOiB,EAAKxB,GAGtC,OAAO6D,GAAK,EAAIxC,EAAQwC,GAAKxC,EAAQwC,GAkBvB,EAAAjC,QAAhB,SACEvB,EACAmB,EACAxB,GAGA,KAAqB,IAAdK,EAAK+C,MAA0B,CACpC,IAAI,EAAIW,EAAoB1D,EAAKE,MAAOiB,EAAKxB,GAC7CK,EAAOA,EAAK0C,SAAS,GAIvB,IAAIc,EAAIG,EAAa3D,EAAKE,MAAOiB,EAAKxB,GAGtC,OAAO6D,GAAK,EAAIxD,EAAKE,MAAMsD,QAAKrD,GAsBlB,EAAA2B,WAAhB,SAAgBA,EACd9B,EACA4B,EACAjC,GAGA,GAAkB,IAAdK,EAAK+C,KAAwB,CAE/B,IAGI,EAHA,EAAIY,EAAa3D,EAAKE,MAAO0B,EAAMjC,GAavC,OATI,GAAK,GACP,EAAWK,EAAKE,MAAM,GACtBF,EAAKE,MAAM,GAAK0B,IAEhB,OAAWzB,EACX,EAAAyD,SAAA,OAAgB5D,EAAKE,OAAQ,EAAI,EAAG0B,IAI/B,EAIT,IAAI4B,EAAIE,EAAoB1D,EAAKE,MAAO0B,EAAMjC,GAG1CkE,EAAQ7D,EAAK0C,SAASc,GAGtBM,EAAWD,EAAM9D,KAGjB8B,EAAWC,EAAW+B,EAAOjC,EAAMjC,GAGnCoE,EAAWF,EAAM9D,KAMrB,GAHAC,EAAKE,MAAMsD,GAAKK,EAAM3D,MAAM,GAGxB4D,IAAaC,EACf,OAAOlC,EAIT,GAAIgC,EAAMG,MAAQC,EAAgB,CAChC,IAAIpB,EAAOqB,EAAUL,GACrB,EAAAD,SAAA,OAAgB5D,EAAK0C,SAAUc,EAAI,EAAGX,GACtC,EAAAe,SAAA,OAAgB5D,EAAKE,MAAOsD,EAAI,EAAGX,EAAK3C,MAAM,IAOhD,OAHAiE,EAAYnE,EAAMwD,GAGX3B,GAoBO,EAAAK,WAAhB,SAAgBA,EACdlC,EACAmB,EACAxB,GAGA,GAAkB,IAAdK,EAAK+C,KAAwB,CAE/B,IAAI,EAAIY,EAAa3D,EAAKE,MAAOiB,EAAKxB,GAGtC,GAAI,EAAI,EACN,OAIF,OAAO,EAAAiE,SAAA,SAAkB5D,EAAKE,MAAO,GAIvC,IAAIsD,EAAIE,EAAoB1D,EAAKE,MAAOiB,EAAKxB,GAGzCkE,EAAQ7D,EAAK0C,SAASc,GAGtBM,EAAWD,EAAM9D,KAGjB6B,EAAOM,EAAW2B,EAAO1C,EAAKxB,GAMlC,OAAImE,IAHWD,EAAM9D,OAQrBC,EAAKE,MAAMsD,GAAKK,EAAM3D,MAAM,GAGxB2D,EAAMG,MAAQI,IAChBZ,EAAIa,EAAUrE,EAAMwD,IAItBW,EAAYnE,EAAMwD,IAZT5B,GAiCK,EAAAS,WAAhB,SAAgBA,EAAcrC,EAAegB,GAO3C,GALIA,EAAQ,IACVA,GAAShB,EAAKD,QAIZiB,EAAQ,GAAKA,GAAShB,EAAKD,MAA/B,CAKA,GAAkB,IAAdC,EAAK+C,KACP,OAAO,EAAAa,SAAA,SAAkB5D,EAAKE,MAAOc,GAIvC,IAAIwC,EAAIC,EAAsBzD,EAAKyC,MAAOzB,GACtCwC,EAAI,IAAGxC,GAAShB,EAAKyC,MAAMe,IAG/B,IAAIK,EAAQ7D,EAAK0C,SAASc,GAGtB5B,EAAOS,EAAWwB,EAAO7C,GAc7B,OAXAhB,EAAKE,MAAMsD,GAAKK,EAAM3D,MAAM,GAGxB2D,EAAMG,MAAQI,IAChBZ,EAAIa,EAAUrE,EAAMwD,IAItBW,EAAYnE,EAAMwD,GAGX5B,IAWO,EAAAH,MAAK,EAoBL,EAAAM,eAAhB,SAAkC/B,GAEhC,GAAIA,EAAKgE,OAASC,EAChB,OAAOjE,EAIT,IAAIsE,EAAO,IAAI1B,EAGXC,EAAOqB,EAAUlE,GAerB,OAZAsE,EAAK7B,MAAM,GAAKzC,EAAKD,KACrBuE,EAAK7B,MAAM,GAAKzC,EAAKD,KAAO8C,EAAK9C,KAGjCuE,EAAK5B,SAAS,GAAK1C,EACnBsE,EAAK5B,SAAS,GAAKG,EAGnByB,EAAKpE,MAAM,GAAKF,EAAKE,MAAM,GAC3BoE,EAAKpE,MAAM,GAAK2C,EAAK3C,MAAM,GAGpBoE,GAUO,EAAAnC,iBAAhB,SAAoCnC,GAElC,GAAkB,IAAdA,EAAK+C,KACP,OAAO/C,EAIT,GAAIA,EAAK0C,SAASC,OAAS,EACzB,OAAO3C,EAIT,IAAIsE,EAAOtE,EAAK0C,SAAS6B,MAMzB,OAHA9C,EAAMzB,GAGCsE,GAMT,IAAML,EAAiB,GAKjBG,EAAiBH,GAAkB,EAKzC,aAWE,WAAYjE,EAA0BgB,EAAesC,GACnDxD,KAAK0E,MAAQxE,EACbF,KAAK2E,OAASzD,EACdlB,KAAK4E,OAASpB,EA4ClB,OApCE,YAAAjD,KAAA,WACE,OAAOP,MAQT,YAAA6E,MAAA,WACE,OAAO,IAAI1B,EAAmBnD,KAAK0E,MAAO1E,KAAK2E,OAAQ3E,KAAK4E,SAQ9D,YAAA7B,KAAA,WACE,GAAmB,OAAf/C,KAAK0E,OAAkC,IAAhB1E,KAAK4E,OAGhC,OAAI5E,KAAK2E,QAAU3E,KAAK0E,MAAMzE,MAC5BD,KAAK0E,MAAQ1E,KAAK0E,MAAM3B,KACxB/C,KAAK2E,OAAS,EACP3E,KAAK+C,SAEV/C,KAAK4E,OAAS,GAChB5E,KAAK4E,SAEA5E,KAAK0E,MAAMtE,MAAMJ,KAAK2E,YAMjC,EA1DA,GA+DA,aAWE,WAAYzE,EAA0BgB,EAAesC,GACnDxD,KAAK0E,MAAQxE,EACbF,KAAK2E,OAASzD,EACdlB,KAAK4E,OAASpB,EA+ClB,OAvCE,YAAAjD,KAAA,WACE,OAAOP,MAQT,YAAA6E,MAAA,WACE,OAAO,IAAIzB,EAAiBpD,KAAK0E,MAAO1E,KAAK2E,OAAQ3E,KAAK4E,SAQ5D,YAAA7B,KAAA,WACE,GAAmB,OAAf/C,KAAK0E,OAAkC,IAAhB1E,KAAK4E,OAMhC,OAHI5E,KAAK2E,QAAU3E,KAAK0E,MAAMzE,OAC5BD,KAAK2E,OAAS3E,KAAK0E,MAAMzE,KAAO,GAE9BD,KAAK2E,OAAS,GAChB3E,KAAK0E,MAAQ1E,KAAK0E,MAAM1B,KACxBhD,KAAK2E,OAAS3E,KAAK0E,MAAQ1E,KAAK0E,MAAMzE,KAAO,GAAK,EAC3CD,KAAK+C,SAEV/C,KAAK4E,OAAS,GAChB5E,KAAK4E,SAEA5E,KAAK0E,MAAMtE,MAAMJ,KAAK2E,YAMjC,EA7DA,GAkEA,SAAShB,EAAsBhB,EAAiBzB,GAE9C,IADA,IAAI4D,EAAInC,EAAME,OACLa,EAAI,EAAGA,EAAIoB,IAAKpB,EACvB,GAAIf,EAAMe,GAAKxC,EACb,OAAOwC,EAGX,OAAOoB,EAAI,EAMb,SAASlB,EACPxD,EACAiB,EACAxB,GAGA,IADA,IAAIiF,EAAI1E,EAAMyC,OACLa,EAAI,EAAGA,EAAIoB,IAAKpB,EACvB,GAAI7D,EAAIO,EAAMsD,GAAIrC,GAAO,EACvB,OAAOqC,EAAI,EAGf,OAAOoB,EAAI,EAMb,SAASjB,EACPzD,EACAiB,EACAxB,GAGA,IADA,IAAIiF,EAAI1E,EAAMyC,OACLa,EAAI,EAAGA,EAAIoB,IAAKpB,EAAG,CAC1B,IAAIqB,EAAIlF,EAAIO,EAAMsD,GAAIrC,GACtB,GAAU,IAAN0D,EACF,OAAOrB,EAET,GAAIqB,EAAI,EACN,OAAQrB,EAAI,EAGhB,OAAQoB,EAAI,EAMd,SAAST,EAAenE,EAAqBwD,GAG3C,IAFM,IAAAf,EAAA,EAAAA,MAAOC,EAAA,EAAAA,SACToC,EAAOtB,EAAI,EAAIf,EAAMe,EAAI,GAAK,EACzBoB,EAAIlC,EAASC,OAAQa,EAAIoB,IAAKpB,EACrCsB,EAAOrC,EAAMe,GAAKsB,EAAOpC,EAASc,GAAGzD,KAEvC0C,EAAME,OAASD,EAASC,OAU1B,SAASuB,EAAalE,GAEpB,GAAkB,IAAdA,EAAK+C,KAAwB,CAO/B,IALA,IAAI,EAAO,IAAIlD,EAGX,EAAKG,EAAKE,MACV,EAAK,EAAKA,MACLsD,EAAIY,EAAgBQ,EAAI,EAAGjC,OAAQa,EAAIoB,IAAKpB,EACnD,EAAGuB,KAAK,EAAGvB,IAWb,OATA,EAAGb,OAASyB,EAGRpE,EAAK6C,OAAM7C,EAAK6C,KAAKC,KAAO,GAChC,EAAKD,KAAO7C,EAAK6C,KACjB,EAAKC,KAAO9C,EACZA,EAAK6C,KAAO,EAGL,EAIT,IAAIA,EAAO,IAAID,EAGXoC,EAAKhF,EAAK0C,SACVuC,EAAKpC,EAAKH,SACd,IAASc,EAAIY,EAAgBQ,EAAII,EAAGrC,OAAQa,EAAIoB,IAAKpB,EACnDyB,EAAGF,KAAKC,EAAGxB,IAEbwB,EAAGrC,OAASyB,EAGZ,IAAIc,EAAKlF,EAAKE,MACViF,EAAKtC,EAAK3C,MACd,IAASsD,EAAIY,EAAgBQ,EAAIM,EAAGvC,OAAQa,EAAIoB,IAAKpB,EACnD2B,EAAGJ,KAAKG,EAAG1B,IASb,OAPA0B,EAAGvC,OAASyB,EAGZD,EAAYnE,EAAMoE,GAClBD,EAAYtB,EAAM,GAGXA,EAeT,SAASwB,EAAarE,EAAqBwD,mBAErCK,EAAQ7D,EAAK0C,SAASc,GAGtB4B,EAAgB,IAAN5B,EAAUxD,EAAK0C,SAASc,EAAI,GAAKxD,EAAK0C,SAASc,EAAI,GAG7D6B,EAAgB,IAAN7B,EACV8B,EAAwB,IAAfzB,EAAMd,KACfwC,EAAWH,EAAQpB,MAAQI,EAG/B,GAAIkB,GAAUC,GAAYF,EAAS,CAEjC,IACIG,EAAIJ,EASR,OAVIP,EAAIhB,GAIN3D,MAAM6E,KAAKS,EAAEtF,MAAMuF,SAGrBzF,EAAKE,MAAMsD,EAAI,GAAKgC,EAAEtF,MAAM,GAGrBsD,EAIT,GAAI8B,GAAUC,IAAaF,EAYzB,OATIG,EAAIJ,GADJP,EAAIhB,GAIN3D,MAAMwF,QAAQF,EAAEtF,MAAMqE,OAGxBvE,EAAKE,MAAMsD,GAAKqB,EAAE3E,MAAM,GAGjBsD,EAAI,EAIb,GAAI8B,IAAWC,GAAYF,EAAS,CAElC,IAAIR,EAAIhB,EAoBR,OAhBA,GAHI2B,EAAIJ,GAGNlF,OAAMwF,QAAO,QAAIb,EAAE3E,OAGrB,EAAA0D,SAAA,SAAkB5D,EAAK0C,SAAUc,GAGjC,EAAAI,SAAA,SAAkB5D,EAAKE,MAAOsD,EAAI,GAG9BqB,EAAE/B,OAAM+B,EAAE/B,KAAKD,KAAO2C,GAC1BA,EAAE1C,KAAO+B,EAAE/B,KAGXrB,EAAMoD,GAGCrB,EAIT,GAAI8B,IAAWC,IAAaF,EAsB1B,OApBIR,EAAIhB,GAIR,GAHI2B,EAAIJ,GAGNlF,OAAM6E,KAAI,QAAIF,EAAE3E,OAGlB,EAAA0D,SAAA,SAAkB5D,EAAK0C,SAAUc,GAGjC,EAAAI,SAAA,SAAkB5D,EAAKE,MAAOsD,GAG1BqB,EAAEhC,OAAMgC,EAAEhC,KAAKC,KAAO0C,GAC1BA,EAAE3C,KAAOgC,EAAEhC,KAGXpB,EAAMoD,GAGCrB,EAAI,EAIb,IAAK8B,GAAUC,GAAYF,EAmBzB,OAhBIG,EAAIJ,GADJP,EAAIhB,GAINnB,SAASqC,KAAKS,EAAE9C,SAAS+C,SAG3BZ,EAAE3E,MAAM6E,KAAKS,EAAEtF,MAAMuF,SAGrBzF,EAAKE,MAAMsD,EAAI,GAAKgC,EAAEtF,MAAM,GAG5BiE,EAAYU,EAAGA,EAAEb,MAAQ,GACzBG,EAAYqB,EAAG,GAGRhC,EAIT,IAAK8B,GAAUC,IAAaF,EAmB1B,OAhBIG,EAAIJ,GADJP,EAAIhB,GAINnB,SAASgD,QAAQF,EAAE9C,SAAS6B,OAG9BM,EAAE3E,MAAMwF,QAAQF,EAAEtF,MAAMqE,OAGxBvE,EAAKE,MAAMsD,GAAKqB,EAAE3E,MAAM,GAGxBiE,EAAYU,EAAG,GACfV,EAAYqB,EAAGA,EAAExB,MAAQ,GAGlBR,EAAI,EAIb,IAAK8B,IAAWC,GAAYF,EAyB1B,OAvBIR,EAAIhB,GAIR,GAHI2B,EAAIJ,GAGN1C,UAASgD,QAAO,QAAIb,EAAEnC,WAGxB,EAAA8C,EAAEtF,OAAMwF,QAAO,QAAIb,EAAE3E,OAGrB,EAAA0D,SAAA,SAAkB5D,EAAK0C,SAAUc,GAGjC,EAAAI,SAAA,SAAkB5D,EAAKE,MAAOsD,EAAI,GAGlCW,EAAYqB,EAAG,GAGfX,EAAEnC,SAASC,OAAS,EACpBlB,EAAMoD,GAGCrB,EAIT,IAAK8B,IAAWC,IAAaF,EAyB3B,OAvBIR,EAAIhB,GAIR,GAHI2B,EAAIJ,GAGN1C,UAASqC,KAAI,QAAIF,EAAEnC,WAGrB,EAAA8C,EAAEtF,OAAM6E,KAAI,QAAIF,EAAE3E,OAGlB,EAAA0D,SAAA,SAAkB5D,EAAK0C,SAAUc,GAGjC,EAAAI,SAAA,SAAkB5D,EAAKE,MAAOsD,GAG9BW,EAAYqB,EAAG,GAGfX,EAAEnC,SAASC,OAAS,EACpBlB,EAAMoD,GAGCrB,EAAI,EAIb,KAAM,cAET,CAjqCD,CAAU9D,IAAAA,EAAO,SC4WPA,eArrBV,aAmbU,KAAAiG,OAA2C,KAC3C,KAAAC,MAA0C,KAC1C,KAAAC,MAAQ,EAClB,OA/aE,sBAAI,sBAAO,KAAX,WACE,OAAsB,IAAf/F,KAAK+F,uCAYd,sBAAI,mBAAI,KAAR,WACE,OAAO/F,KAAK+F,uCAcd,sBAAI,qBAAM,KAAV,WACE,OAAO/F,KAAK+F,uCAWd,sBAAI,oBAAK,KAAT,WACE,OAAO/F,KAAK6F,OAAS7F,KAAK6F,OAAOG,WAAQ3F,mCAW3C,sBAAI,mBAAI,KAAR,WACE,OAAOL,KAAK8F,MAAQ9F,KAAK8F,MAAME,WAAQ3F,mCAWzC,sBAAI,wBAAS,KAAb,WACE,OAAOL,KAAK6F,wCAWd,sBAAI,uBAAQ,KAAZ,WACE,OAAO7F,KAAK8F,uCAWd,YAAAvF,KAAA,WACE,OAAO,IAAI0F,EAAWC,qBAAwBlG,KAAK6F,SAWrD,YAAApF,MAAA,WACE,OAAO,IAAIwF,EAAWE,mBAAsBnG,KAAK8F,QAWnD,YAAAM,MAAA,WACE,OAAO,IAAIH,EAAWI,oBAAuBrG,KAAK6F,SAWpD,YAAAS,WAAA,WACE,OAAO,IAAIL,EAAWM,kBAAqBvG,KAAK8F,QAWlD,YAAApE,OAAA,SAAO8E,GAAP,WACExG,KAAK2B,SACL,IAAAO,MAAKsE,GAAQ,SAAAR,GACX,EAAKS,QAAQT,OAejB,YAAAf,KAAA,SAAKe,GACHhG,KAAKyG,QAAQT,IAcf,YAAAvB,IAAA,WACE,OAAOzE,KAAK0G,cAcd,YAAAf,MAAA,SAAMK,GACJhG,KAAK2G,SAASX,IAchB,YAAAJ,QAAA,WACE,OAAO5F,KAAK4G,eAad,YAAAD,SAAA,SAASX,GACP,IAAI9F,EAAO,IAAIN,EAAQiH,eAAkB7G,KAAMgG,GAU/C,OATKhG,KAAK6F,QAIR3F,EAAK6C,KAAO/C,KAAK6F,OACjB7F,KAAK6F,OAAO7C,KAAO9C,EACnBF,KAAK6F,OAAS3F,IALdF,KAAK6F,OAAS3F,EACdF,KAAK8F,MAAQ5F,GAMfF,KAAK+F,QACE7F,GAaT,YAAAuG,QAAA,SAAQT,GACN,IAAI9F,EAAO,IAAIN,EAAQiH,eAAkB7G,KAAMgG,GAU/C,OATKhG,KAAK8F,OAIR5F,EAAK8C,KAAOhD,KAAK8F,MACjB9F,KAAK8F,MAAM/C,KAAO7C,EAClBF,KAAK8F,MAAQ5F,IALbF,KAAK6F,OAAS3F,EACdF,KAAK8F,MAAQ5F,GAMfF,KAAK+F,QACE7F,GAmBT,YAAA4G,aAAA,SAAad,EAAUe,GACrB,IAAKA,GAAOA,IAAQ/G,KAAK6F,OACvB,OAAO7F,KAAK2G,SAASX,GAEvB,KAAMe,aAAenH,EAAQiH,iBAAmBE,EAAIC,OAAShH,KAC3D,MAAM,IAAIiH,MAAM,4CAElB,IAAI/G,EAAO,IAAIN,EAAQiH,eAAkB7G,KAAMgG,GAC3CkB,EAAOH,EACP/D,EAAOkE,EAAKlE,KAMhB,OALA9C,EAAK6C,KAAOmE,EACZhH,EAAK8C,KAAOA,EACZkE,EAAKlE,KAAO9C,EACZ8C,EAAKD,KAAO7C,EACZF,KAAK+F,QACE7F,GAmBT,YAAAiH,YAAA,SAAYnB,EAAUe,GACpB,IAAKA,GAAOA,IAAQ/G,KAAK8F,MACvB,OAAO9F,KAAKyG,QAAQT,GAEtB,KAAMe,aAAenH,EAAQiH,iBAAmBE,EAAIC,OAAShH,KAC3D,MAAM,IAAIiH,MAAM,4CAElB,IAAI/G,EAAO,IAAIN,EAAQiH,eAAkB7G,KAAMgG,GAC3CkB,EAAOH,EACPhE,EAAOmE,EAAKnE,KAMhB,OALA7C,EAAK6C,KAAOA,EACZ7C,EAAK8C,KAAOkE,EACZA,EAAKnE,KAAO7C,EACZ6C,EAAKC,KAAO9C,EACZF,KAAK+F,QACE7F,GAWT,YAAA0G,YAAA,WACE,IAAI1G,EAAOF,KAAK6F,OAChB,GAAK3F,EAcL,OAXIA,IAASF,KAAK8F,OAChB9F,KAAK6F,OAAS,KACd7F,KAAK8F,MAAQ,OAEb9F,KAAK6F,OAAS3F,EAAK6C,KACnB/C,KAAK6F,OAAQ7C,KAAO,MAEtB9C,EAAK8G,KAAO,KACZ9G,EAAK6C,KAAO,KACZ7C,EAAK8C,KAAO,KACZhD,KAAK+F,QACE7F,EAAK8F,OAWd,YAAAU,WAAA,WACE,IAAIxG,EAAOF,KAAK8F,MAChB,GAAK5F,EAcL,OAXIA,IAASF,KAAK6F,QAChB7F,KAAK6F,OAAS,KACd7F,KAAK8F,MAAQ,OAEb9F,KAAK8F,MAAQ5F,EAAK8C,KAClBhD,KAAK8F,MAAO/C,KAAO,MAErB7C,EAAK8G,KAAO,KACZ9G,EAAK6C,KAAO,KACZ7C,EAAK8C,KAAO,KACZhD,KAAK+F,QACE7F,EAAK8F,OAcd,YAAAoB,WAAA,SAAWlH,GACT,KAAMA,aAAgBN,EAAQiH,iBAAmB3G,EAAK8G,OAAShH,KAC7D,MAAM,IAAIiH,MAAM,kCAElB,IAAIvC,EAAQxE,EACRwE,IAAU1E,KAAK6F,QAAUnB,IAAU1E,KAAK8F,OAC1C9F,KAAK6F,OAAS,KACd7F,KAAK8F,MAAQ,MACJpB,IAAU1E,KAAK6F,QACxB7F,KAAK6F,OAASnB,EAAM3B,KACpB/C,KAAK6F,OAAQ7C,KAAO,MACX0B,IAAU1E,KAAK8F,OACxB9F,KAAK8F,MAAQpB,EAAM1B,KACnBhD,KAAK8F,MAAO/C,KAAO,OAEnB2B,EAAM3B,KAAMC,KAAO0B,EAAM1B,KACzB0B,EAAM1B,KAAMD,KAAO2B,EAAM3B,MAE3B2B,EAAMsC,KAAO,KACbtC,EAAM3B,KAAO,KACb2B,EAAM1B,KAAO,KACbhD,KAAK+F,SASP,YAAApE,MAAA,WAEE,IADA,IAAIzB,EAAOF,KAAK6F,OACT3F,GAAM,CACX,IAAI6C,EAAO7C,EAAK6C,KAChB7C,EAAK8G,KAAO,KACZ9G,EAAK8C,KAAO,KACZ9C,EAAK6C,KAAO,KACZ7C,EAAO6C,EAET/C,KAAK6F,OAAS,KACd7F,KAAK8F,MAAQ,KACb9F,KAAK+F,MAAQ,GAMjB,MAKA,SAAiBE,GAgDC,EAAAxD,KAAhB,SAAwB+D,GACtB,IAAIQ,EAAO,IAAIf,EAEf,OADAe,EAAKtF,OAAO8E,GACLQ,GAMT,iBAME,WAAY9G,GACVF,KAAK0E,MAAQxE,EAoCjB,OA5BE,YAAAK,KAAA,WACE,OAAOP,MAQT,YAAA6E,MAAA,WACE,OAAO,IAAIqB,EAAwBlG,KAAK0E,QAQ1C,YAAA3B,KAAA,WACE,GAAK/C,KAAK0E,MAAV,CAGA,IAAIxE,EAAOF,KAAK0E,MAEhB,OADA1E,KAAK0E,MAAQxE,EAAK6C,KACX7C,EAAK8F,QAIhB,EA3CA,GAAa,EAAAE,qBAAoB,EAgDjC,iBAME,WAAYhG,GACVF,KAAK0E,MAAQxE,EAoCjB,OA5BE,YAAAK,KAAA,WACE,OAAOP,MAQT,YAAA6E,MAAA,WACE,OAAO,IAAIsB,EAAsBnG,KAAK0E,QAQxC,YAAA3B,KAAA,WACE,GAAK/C,KAAK0E,MAAV,CAGA,IAAIxE,EAAOF,KAAK0E,MAEhB,OADA1E,KAAK0E,MAAQxE,EAAK8C,KACX9C,EAAK8F,QAIhB,EA3CA,GAAa,EAAAG,mBAAkB,EAgD/B,iBAME,WAAYjG,GACVF,KAAK0E,MAAQxE,EAoCjB,OA5BE,YAAAK,KAAA,WACE,OAAOP,MAQT,YAAA6E,MAAA,WACE,OAAO,IAAIwB,EAAuBrG,KAAK0E,QAQzC,YAAA3B,KAAA,WACE,GAAK/C,KAAK0E,MAAV,CAGA,IAAIxE,EAAOF,KAAK0E,MAEhB,OADA1E,KAAK0E,MAAQxE,EAAK6C,KACX7C,IAIX,EA3CA,GAAa,EAAAmG,oBAAmB,EAgDhC,iBAME,WAAYnG,GACVF,KAAK0E,MAAQxE,EAoCjB,OA5BE,YAAAK,KAAA,WACE,OAAOP,MAQT,YAAA6E,MAAA,WACE,OAAO,IAAI0B,EAAqBvG,KAAK0E,QAQvC,YAAA3B,KAAA,WACE,GAAK/C,KAAK0E,MAAV,CAGA,IAAIxE,EAAOF,KAAK0E,MAEhB,OADA1E,KAAK0E,MAAQxE,EAAK8C,KACX9C,IAIX,EA3CA,GAAa,EAAAqG,kBAAiB,CA4C/B,CArPD,CAAiBN,IAAAA,EAAU,KA0P3B,SAAUrG,GAIK,EAAAiH,eA4BX,SAAYG,EAAqBhB,GAxBjC,KAAAgB,KAA6B,KAK7B,KAAAjE,KAAiC,KAKjC,KAAAC,KAAiC,KAe/BhD,KAAKgH,KAAOA,EACZhH,KAAKgG,MAAQA,EAGlB,CArCD,CAAUpG,IAAAA,EAAO,KCzrBjB,ICoLiByH,EDpLbC,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,CAAG,GAC1E,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOC,OAAOK,UAAUC,eAAeC,KAAKR,EAAGK,KAAIN,EAAEM,GAAKL,EAAEK,GAAI,EAC7FP,EAAcC,EAAGC,EAC5B,eCIE,WAAYvE,GACVjD,KAAKiD,KAAOA,EAsEhB,OAtCE,sBAAI,4BAAa,KAAjB,WACE,OAAO,mCAkCT,YAAAgF,SAAA,SAASC,GACP,OAAO,GAEX,mBAeA,4DAoBA,OD5GO,SAAmBX,EAAGC,GACzB,GAAiB,mBAANA,GAA0B,OAANA,EAC3B,MAAM,IAAIW,UAAU,uBAAyBC,OAAOZ,GAAK,iCAE7D,SAASa,IAAOrI,KAAKsI,YAAcf,CAAG,CADtCD,EAAcC,EAAGC,GAEjBD,EAAEO,UAAkB,OAANN,EAAaC,OAAOc,OAAOf,IAAMa,EAAGP,UAAYN,EAAEM,UAAW,IAAIO,EACnF,CCkFwC,MAOtC,sBAAI,4BAAa,KAAjB,WACE,OAAO,mCAST,YAAAJ,SAAA,SAASC,GACP,OAAO,GAEX,GApBwCM,IAqFxC,SAAiBnB,GAiBf,SAAgBoB,EAAYC,EAA0BC,GAEpD,IAAIC,EAAQC,EAAarH,IAAIkH,GAG7B,GAAKE,GAA0B,IAAjBA,EAAM/F,OAApB,CAMA,IAAIiG,GAAS,IAAAC,QAAM,IAAAtI,OAAMmI,IAAQ,SAAAI,GAC/B,OAAOA,GAuRX,SACEA,EACAN,EACAC,GAEA,IAAIM,GAAS,EACb,IAEIA,EADkB,mBAATD,EACAA,EAAKN,EAASC,GAEdK,EAAKE,YAAYR,EAASC,GAErC,MAAOQ,GACPC,EAAiBD,GAEnB,OAAOF,EAtSSI,CAAWL,EAAMN,EAASC,MAItCG,GACFQ,EAAcZ,EAASC,QAXvBW,EAAcZ,EAASC,GANX,EAAAF,YAAW,EAmCX,EAAAc,YAAhB,SAA4Bb,EAA0BC,GAE/CA,EAAIa,gBAMO,IAAAC,MAAKC,GAAc,SAAAC,GACjC,OAAIA,EAAOjB,UAAYA,KAGlBiB,EAAOhB,KAGRgB,EAAOhB,IAAI1F,OAAS0F,EAAI1F,QAGvB0G,EAAOhB,IAAIa,eAGTG,EAAOhB,IAAIV,SAASU,OA+Q/B,SAAwBD,EAA0BC,GAEhDe,EAAajD,QAAQ,CAAEiC,QAAO,EAAEC,IAAG,IAGhB,IAAfiB,IAKJA,EAAaC,EAASC,IA3SpBC,CAAerB,EAASC,IA2CZ,EAAAqB,mBAAhB,SACEtB,EACAM,GAGA,IAAIJ,EAAQC,EAAarH,IAAIkH,GAGzBE,IAAkC,IAAzBA,EAAMrH,QAAQyH,KAKtBJ,EAGHA,EAAM3D,KAAK+D,GAFXH,EAAaoB,IAAIvB,EAAS,CAACM,MAkBf,EAAAkB,kBAAhB,SACExB,EACAM,GAGA,IAAIJ,EAAQC,EAAarH,IAAIkH,GAG7B,GAAKE,EAAL,CAKA,IAAIlF,EAAIkF,EAAMrH,QAAQyH,IACX,IAAPtF,IAKJkF,EAAMlF,GAAK,KACXyG,EAAgBvB,MAWF,EAAAwB,UAAhB,SAA0B1B,GAExB,IAAIE,EAAQC,EAAarH,IAAIkH,GAGzBE,GAASA,EAAM/F,OAAS,IAC1B,EAAAiB,SAAA,KAAc8E,EAAO,MACrBuB,EAAgBvB,KAIlB,IAAA1G,MAAKwH,GAAc,SAAAC,GACbA,EAAOjB,UAAYA,IACrBiB,EAAOjB,QAAU,KACjBiB,EAAOhB,IAAM,UAiBH,EAAA0B,MAAhB,WAEMC,GAA6B,IAAfV,IAKlBW,EAAWX,GAGXU,GAAa,EACbR,IACAQ,GAAa,IAgBC,EAAAE,oBAAhB,WACE,OAAOpB,GAcO,EAAAqB,oBAAhB,SACE/B,GAEA,IAAIgC,EAAMtB,EAEV,OADAA,EAAmBV,EACZgC,GAWT,IAAMhB,EAAe,IAAIzD,EAKnB4C,EAAe,IAAI8B,QAQnBC,EAAW,IAAIC,IAKjBzB,EAAqC,SAACD,GACxC2B,QAAQC,MAAM5B,IAQZS,EAA6B,EAK7BU,GAAa,EAKXT,EACsC,mBAA1BmB,sBACJA,sBAAwBC,aAMhCV,EACqC,mBAAzBW,qBACJA,qBAAuBC,eAiCrC,SAAS7B,EAAcZ,EAA0BC,GAC/C,IACED,EAAQ0C,eAAezC,GACvB,MAAOQ,GACPC,EAAiBD,IA6BrB,SAASW,IAKP,GAHAF,EAAa,GAGTF,EAAa2B,QAAjB,CAOA,IAAIC,EAA0B,CAAE5C,QAAS,KAAMC,IAAK,MAKpD,IAJAe,EAAajD,QAAQ6E,KAIR,CAEX,IAAI3B,EAASD,EAAa9C,cAG1B,GAAI+C,IAAW2B,EACb,OAIE3B,EAAOjB,SAAWiB,EAAOhB,KAC3BF,EAAYkB,EAAOjB,QAASiB,EAAOhB,OAYzC,SAASwB,EAAgBvB,GACD,IAAlBgC,EAAS3K,MACX4J,EAAS0B,GAEXX,EAASY,IAAI5C,GASf,SAAS2C,IACPX,EAASa,QAAQC,GACjBd,EAASjJ,QAWX,SAAS+J,EAAa9C,GACpB,EAAA9E,SAAA,eAAwB8E,EAAO+C,GAMjC,SAASA,EAAU3F,GACjB,OAAiB,OAAVA,EAEV,CAxbD,CAAiBqB,IAAAA,EAAW","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/collections/src/bplustree.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/collections/src/linkedlist.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/messaging/node_modules/tslib/tslib.es6.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/messaging/src/index.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2018, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  ArrayExt,\n  each,\n  empty,\n  IIterable,\n  IIterator,\n  IRetroable,\n  IterableOrArrayLike\n} from '@lumino/algorithm';\n\n/**\n * A generic B+ tree.\n *\n * #### Notes\n * Most operations have `O(log32 n)` or better complexity.\n *\n * @deprecated This class will be removed in @lumino/collections@^2.0.0\n */\nexport class BPlusTree<T> implements IIterable<T>, IRetroable<T> {\n  /**\n   * Construct a new B+ tree.\n   *\n   * @param cmp - The item comparison function for the tree.\n   */\n  constructor(cmp: (a: T, b: T) => number) {\n    this.cmp = cmp;\n  }\n\n  /**\n   * The item comparison function for the tree.\n   *\n   * #### Complexity\n   * `O(1)`\n   */\n  readonly cmp: (a: T, b: T) => number;\n\n  /**\n   * Whether the tree is empty.\n   *\n   * #### Complexity\n   * `O(1)`\n   */\n  get isEmpty(): boolean {\n    return this._root.size === 0;\n  }\n\n  /**\n   * The size of the tree.\n   *\n   * #### Complexity\n   * `O(1)`\n   */\n  get size(): number {\n    return this._root.size;\n  }\n\n  /**\n   * The first item in the tree.\n   *\n   * This is `undefined` if the tree is empty.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  get first(): T | undefined {\n    let node = Private.firstLeaf(this._root);\n    return node.size > 0 ? node.items[0] : undefined;\n  }\n\n  /**\n   * The last item in the tree.\n   *\n   * This is `undefined` if the tree is empty.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  get last(): T | undefined {\n    let node = Private.lastLeaf(this._root);\n    return node.size > 0 ? node.items[node.size - 1] : undefined;\n  }\n\n  /**\n   * Create an iterator over the items in the tree.\n   *\n   * @returns A new iterator starting with the first item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  iter(): IIterator<T> {\n    return Private.iterItems(this._root);\n  }\n\n  /**\n   * Create a reverse iterator over the items in the tree.\n   *\n   * @returns A new iterator starting with the last item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  retro(): IIterator<T> {\n    return Private.retroItems(this._root);\n  }\n\n  /**\n   * Create an iterator for a slice of items in the tree.\n   *\n   * @param start - The index of the first item, inclusive. This\n   *   should be `< stop`. Negative values are taken as an offset\n   *   from the end of the tree. The default is `0`.\n   *\n   * @param stop - The index of the last item, exclusive. This\n   *   should be `> start`. Negative values are taken as an offset\n   *   from the end of the tree. The default is `size`.\n   *\n   * @returns A new iterator starting with the specified item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  slice(start?: number, stop?: number): IIterator<T> {\n    return Private.sliceItems(this._root, start, stop);\n  }\n\n  /**\n   * Create a reverse iterator for a slice of items in the tree.\n   *\n   * @param start - The index of the first item, inclusive. This\n   *   should be `> stop`. Negative values are taken as an offset\n   *   from the end of the tree. The default is `size - 1`.\n   *\n   * @param stop - The index of the last item, exclusive. This\n   *   should be `< start`. Negative values are taken as an offset\n   *   from the end of the tree. The default is `-size - 1`.\n   *\n   * @returns A new reverse iterator starting with the specified item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  retroSlice(start?: number, stop?: number): IIterator<T> {\n    return Private.retroSliceItems(this._root, start, stop);\n  }\n\n  /**\n   * Get the item at a particular index.\n   *\n   * @param index - The index of the item of interest. Negative\n   *   values are taken as an offset from the end of the tree.\n   *\n   * @returns The item at the specified index, or `undefined` if\n   *   the index is out of range.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  at(index: number): T | undefined {\n    return Private.itemAt(this._root, index);\n  }\n\n  /**\n   * Test whether the tree has an item which matches a key.\n   *\n   * @param key - The key of interest.\n   *\n   * @param cmp - A function which compares an item against the key.\n   *\n   * @returns `true` if the tree has an item which matches the given\n   *   key, `false` otherwise.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  has<U>(key: U, cmp: (item: T, key: U) => number): boolean {\n    return Private.hasItem(this._root, key, cmp);\n  }\n\n  /**\n   * Get the index of an item which matches a key.\n   *\n   * @param key - The key of interest.\n   *\n   * @param cmp - A function which compares an item against the key.\n   *\n   * @returns The index of the item which matches the given key. A\n   *   negative value means that a matching item does not exist in\n   *   the tree, but if one did it would reside at `-index - 1`.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  indexOf<U>(key: U, cmp: (item: T, key: U) => number): number {\n    return Private.indexOf(this._root, key, cmp);\n  }\n\n  /**\n   * Get the item which matches a key.\n   *\n   * @param item - The key of interest.\n   *\n   * @param cmp - A function which compares an item against the key.\n   *\n   * @returns The item which matches the given key, or `undefined` if\n   *   the tree does not have a matching item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  get<U>(key: U, cmp: (item: T, key: U) => number): T | undefined {\n    return Private.getItem(this._root, key, cmp);\n  }\n\n  /**\n   * Assign new items to the tree, replacing all current items.\n   *\n   * @param items - The items to assign to the tree.\n   *\n   * #### Complexity\n   * `O(n log32 n)`\n   */\n  assign(items: IterableOrArrayLike<T>): void {\n    this.clear();\n    this.update(items);\n  }\n\n  /**\n   * Insert an item into the tree.\n   *\n   * @param item - The item of interest.\n   *\n   * @returns If the given item matches an existing item in the tree,\n   *   the given item will replace it, and the existing item will be\n   *   returned. Otherwise, this method returns `undefined`.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  insert(item: T): T | undefined {\n    let existing = Private.insertItem(this._root, item, this.cmp);\n    this._root = Private.maybeSplitRoot(this._root);\n    return existing;\n  }\n\n  /**\n   * Update the tree with multiple items.\n   *\n   * @param items - The items to insert into the tree.\n   *\n   * #### Complexity\n   * `O(k log32 n)`\n   */\n  update(items: IterableOrArrayLike<T>): void {\n    each(items, item => {\n      this.insert(item);\n    });\n  }\n\n  /**\n   * Delete an item which matches a particular key.\n   *\n   * @param key - The key of interest.\n   *\n   * @param cmp - A function which compares an item against the key.\n   *\n   * @returns The item removed from the tree, or `undefined` if no\n   *   item matched the given key.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  delete<U>(key: U, cmp: (item: T, key: U) => number): T | undefined {\n    let item = Private.deleteItem(this._root, key, cmp);\n    this._root = Private.maybeExtractRoot(this._root);\n    return item;\n  }\n\n  /**\n   * Remove an item at a particular index.\n   *\n   * @param index - The index of the item to remove. Negative\n   *   values are taken as an offset from the end of the tree.\n   *\n   * @returns The item removed from the tree, or `undefined` if\n   *   the given index is out of range.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  remove(index: number): T | undefined {\n    let item = Private.removeItem(this._root, index);\n    this._root = Private.maybeExtractRoot(this._root);\n    return item;\n  }\n\n  /**\n   * Clear the contents of the tree.\n   *\n   * #### Complexity\n   * `O(n)`\n   */\n  clear(): void {\n    Private.clear(this._root);\n    this._root = new Private.LeafNode<T>();\n  }\n\n  private _root: Private.Node<T> = new Private.LeafNode<T>();\n}\n\n/**\n * The namespace for the `BPlusTree` class statics.\n *\n * @deprecated This namespace will be removed in @lumino/collections@^2.0.0\n */\nexport namespace BPlusTree {\n  /**\n   * Create a new B+ tree populated with the given items.\n   *\n   * @param items - The items to add to the tree.\n   *\n   * @param cmp - The item comparison function for the tree.\n   *\n   * @returns A new B+ tree populated with the given items.\n   *\n   * #### Complexity\n   * `O(n log32 n)`\n   */\n  export function from<T>(\n    items: IterableOrArrayLike<T>,\n    cmp: (a: T, b: T) => number\n  ): BPlusTree<T> {\n    let tree = new BPlusTree<T>(cmp);\n    tree.assign(items);\n    return tree;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A const enum of the B+ tree node types.\n   */\n  export const enum NodeType {\n    Branch,\n    Leaf\n  }\n\n  /**\n   * A branch node in a B+ tree.\n   */\n  export class BranchNode<T> {\n    /**\n     * The left-most item of each child subtree.\n     */\n    readonly items: T[] = [];\n\n    /**\n     * The cumulative sizes of each child subtree.\n     */\n    readonly sizes: number[] = [];\n\n    /**\n     * The child nodes of this branch node.\n     */\n    readonly children: Node<T>[] = [];\n\n    /**\n     * The discriminated type of the node.\n     */\n    get type(): NodeType.Branch {\n      return NodeType.Branch;\n    }\n\n    /**\n     * The total number of items in the subtree.\n     */\n    get size(): number {\n      return this.sizes[this.sizes.length - 1];\n    }\n\n    /**\n     * The tree width of the node.\n     */\n    get width(): number {\n      return this.children.length;\n    }\n  }\n\n  /**\n   * A leaf node in a B+ tree.\n   */\n  export class LeafNode<T> {\n    /**\n     * The next sibling leaf node of this leaf node.\n     */\n    next: LeafNode<T> | null = null;\n\n    /**\n     * The previous sibling leaf node of this leaf node.\n     */\n    prev: LeafNode<T> | null = null;\n\n    /**\n     * The items of the leaf.\n     */\n    readonly items: T[] = [];\n\n    /**\n     * The discriminated type of the node.\n     */\n    get type(): NodeType.Leaf {\n      return NodeType.Leaf;\n    }\n\n    /**\n     * The total number of items in the leaf.\n     */\n    get size(): number {\n      return this.items.length;\n    }\n\n    /**\n     * The tree width of the node.\n     */\n    get width(): number {\n      return this.items.length;\n    }\n  }\n\n  /**\n   * A type alias for the B+ tree nodes.\n   */\n  export type Node<T> = BranchNode<T> | LeafNode<T>;\n\n  /**\n   * Get the first leaf node in the tree.\n   *\n   * @param node - The root node of interest.\n   *\n   * @returns The first leaf node in the tree.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export function firstLeaf<T>(node: Node<T>): LeafNode<T> {\n    while (node.type === NodeType.Branch) {\n      node = node.children[0];\n    }\n    return node;\n  }\n\n  /**\n   * Get the last leaf node in the tree.\n   *\n   * @param node - The root node of interest.\n   *\n   * @returns The last leaf node in the tree.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export function lastLeaf<T>(node: Node<T>): LeafNode<T> {\n    while (node.type === NodeType.Branch) {\n      node = node.children[node.children.length - 1];\n    }\n    return node;\n  }\n\n  /**\n   * Create a forward iterator for the items in the tree.\n   *\n   * @param node - The root node of interest.\n   *\n   * @returns A new forward iterator starting with the first item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export function iterItems<T>(node: Node<T>): IIterator<T> {\n    let leaf = firstLeaf(node);\n    return new ForwardIterator<T>(leaf, 0, -1);\n  }\n\n  /**\n   * Create a reverse iterator for the items in the tree.\n   *\n   * @param node - The root node of interest.\n   *\n   * @returns A new reverse iterator starting with the last item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export function retroItems<T>(node: Node<T>): IIterator<T> {\n    let leaf = lastLeaf(node);\n    return new RetroIterator<T>(leaf, leaf.size - 1, -1);\n  }\n\n  /**\n   * Create an iterator for a slice of items in the tree.\n   *\n   * @param node - The root node of interest.\n   *\n   * @param start - The index of the first item, inclusive. This\n   *   should be `< stop`. Negative values are taken as an offset\n   *   from the end of the tree. The default is `0`.\n   *\n   * @param stop - The index of the last item, exclusive. This\n   *   should be `> start`. Negative values are taken as an offset\n   *   from the end of the tree. The default is `size`.\n   *\n   * @returns A new iterator starting with the specified item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export function sliceItems<T>(\n    node: Node<T>,\n    start?: number,\n    stop?: number\n  ): IIterator<T> {\n    // Normalize the start index.\n    if (start === undefined) {\n      start = 0;\n    } else if (start < 0) {\n      start = Math.max(0, start + node.size);\n    } else {\n      start = Math.min(start, node.size);\n    }\n\n    // Normalize the stop index.\n    if (stop === undefined) {\n      stop = node.size;\n    } else if (stop < 0) {\n      stop = Math.max(0, stop + node.size);\n    } else {\n      stop = Math.min(stop, node.size);\n    }\n\n    // Compute effective count.\n    let count = Math.max(0, stop - start);\n\n    // Bail early if there is nothing to iterate.\n    if (count === 0) {\n      return empty<T>();\n    }\n\n    // Find the starting leaf node and local index.\n    while (node.type === NodeType.Branch) {\n      let i = findPivotIndexByIndex(node.sizes, start);\n      if (i > 0) start -= node.sizes[i - 1];\n      node = node.children[i];\n    }\n\n    // Return the forward iterator for the range.\n    return new ForwardIterator<T>(node, start, count);\n  }\n\n  /**\n   * Create a reverse iterator for a slice of items in the tree.\n   *\n   * @param node - The root node of interest.\n   *\n   * @param start - The index of the first item, inclusive. This\n   *   should be `> stop`. Negative values are taken as an offset\n   *   from the end of the tree. The default is `size - 1`.\n   *\n   * @param stop - The index of the last item, exclusive. This\n   *   should be `< start`. Negative values are taken as an offset\n   *   from the end of the tree. The default is `-size - 1`.\n   *\n   * @returns A new reverse iterator starting with the specified item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export function retroSliceItems<T>(\n    node: Node<T>,\n    start?: number,\n    stop?: number\n  ): IIterator<T> {\n    // Normalize the start index.\n    if (start === undefined) {\n      start = node.size - 1;\n    } else if (start < 0) {\n      start = Math.max(-1, start + node.size);\n    } else {\n      start = Math.min(start, node.size - 1);\n    }\n\n    // Normalize the stop index.\n    if (stop === undefined) {\n      stop = -1;\n    } else if (stop < 0) {\n      stop = Math.max(-1, stop + node.size);\n    } else {\n      stop = Math.min(stop, node.size - 1);\n    }\n\n    // Compute the effective count.\n    let count = Math.max(0, start - stop);\n\n    // Bail early if there is nothing to iterate.\n    if (count === 0) {\n      return empty<T>();\n    }\n\n    // Find the starting leaf node and local index.\n    while (node.type === NodeType.Branch) {\n      let i = findPivotIndexByIndex(node.sizes, start);\n      if (i > 0) start -= node.sizes[i - 1];\n      node = node.children[i];\n    }\n\n    // Return the retro iterator for the range.\n    return new RetroIterator<T>(node, start, count);\n  }\n\n  /**\n   * Get the item at the specified index.\n   *\n   * @param node - The root node of interest.\n   *\n   * @param index - The index of the item of interest. Negative\n   *   values are taken as an offset from the end of the tree.\n   *\n   * @returns The item at the specified index, or `undefined` if\n   *   the index is out of range.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export function itemAt<T>(node: Node<T>, index: number): T | undefined {\n    // Wrap negative indices.\n    if (index < 0) {\n      index += node.size;\n    }\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= node.size) {\n      return undefined;\n    }\n\n    // Find the containing leaf node and local index.\n    while (node.type === NodeType.Branch) {\n      let i = findPivotIndexByIndex(node.sizes, index);\n      if (i > 0) index -= node.sizes[i - 1];\n      node = node.children[i];\n    }\n\n    // Return the item at the specified index.\n    return node.items[index];\n  }\n\n  /**\n   * Test whether the tree contains an item which matches a key.\n   *\n   * @param node - The root node of interest.\n   *\n   * @param key - The key of interest.\n   *\n   * @param cmp - The key comparison function.\n   *\n   * @returns Whether the tree contains a matching item.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export function hasItem<T, U>(\n    node: Node<T>,\n    key: U,\n    cmp: (item: T, key: U) => number\n  ): boolean {\n    // Find the containing leaf node.\n    while (node.type === NodeType.Branch) {\n      let i = findPivotIndexByKey(node.items, key, cmp);\n      node = node.children[i];\n    }\n\n    // Find the key index.\n    let i = findKeyIndex(node.items, key, cmp);\n\n    // Return whether or not the node contains a matching item.\n    return i >= 0;\n  }\n\n  /**\n   * Get the index of the item which matches a key.\n   *\n   * @param node - The node of interest.\n   *\n   * @param key - The key of interest.\n   *\n   * @param cmp - The key comparison function.\n   *\n   * @returns The index of the item which matches the given key. A\n   *   negative value means that a matching item does not exist in\n   *   the tree, but if one did it would reside at `-index - 1`.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export function indexOf<T, U>(\n    node: Node<T>,\n    key: U,\n    cmp: (item: T, key: U) => number\n  ): number {\n    // Set up the global index.\n    let index = 0;\n\n    // Find the containing leaf node and global index.\n    while (node.type === NodeType.Branch) {\n      let i = findPivotIndexByKey(node.items, key, cmp);\n      if (i > 0) index += node.sizes[i - 1];\n      node = node.children[i];\n    }\n\n    // Find the key index.\n    let i = findKeyIndex(node.items, key, cmp);\n\n    // Return the final computed index.\n    return i >= 0 ? index + i : -index + i;\n  }\n\n  /**\n   * Get the item for a particular key.\n   *\n   * @param node - The node of interest.\n   *\n   * @param key - The key of interest.\n   *\n   * @param cmp - The key comparison function.\n   *\n   * @returns The item for the specified key, or `undefined` if\n   *   the tree does not have a matching item for the key.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   */\n  export function getItem<T, U>(\n    node: Node<T>,\n    key: U,\n    cmp: (item: T, key: U) => number\n  ): T | undefined {\n    // Find the containing leaf node.\n    while (node.type === NodeType.Branch) {\n      let i = findPivotIndexByKey(node.items, key, cmp);\n      node = node.children[i];\n    }\n\n    // Find the key index.\n    let i = findKeyIndex(node.items, key, cmp);\n\n    // Return the item for the given key.\n    return i >= 0 ? node.items[i] : undefined;\n  }\n\n  /**\n   * Insert an item into the tree.\n   *\n   * @param node - The root node of interest.\n   *\n   * @param item - The item of interest.\n   *\n   * @param cmp - The item comparison function.\n   *\n   * @returns If the given item matches an existing item in the tree,\n   *   the given item will replace it, and the existing item will be\n   *   returned. Otherwise, this function returns `undefined`.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   *\n   * #### Notes\n   * The root may be overfull after calling this function.\n   */\n  export function insertItem<T>(\n    node: Node<T>,\n    item: T,\n    cmp: (a: T, b: T) => number\n  ): T | undefined {\n    // Handle leaf nodes first.\n    if (node.type === NodeType.Leaf) {\n      // Find the index for the given item.\n      let i = findKeyIndex(node.items, item, cmp);\n\n      // Fetch the existing item and insert the new item.\n      let existing: T | undefined;\n      if (i >= 0) {\n        existing = node.items[i];\n        node.items[i] = item;\n      } else {\n        existing = undefined;\n        ArrayExt.insert(node.items, -i - 1, item);\n      }\n\n      // Return the existing item.\n      return existing;\n    }\n\n    // Find the pivot index for the insert.\n    let i = findPivotIndexByKey(node.items, item, cmp);\n\n    // Fetch the pivot child.\n    let child = node.children[i];\n\n    // Fetch the current size of the child.\n    let prevSize = child.size;\n\n    // Recursively insert the item into the child.\n    let existing = insertItem(child, item, cmp);\n\n    // Fetch the updated size of the child.\n    let currSize = child.size;\n\n    // Update the item state of the branch.\n    node.items[i] = child.items[0];\n\n    // Bail early if the child size did not change.\n    if (prevSize === currSize) {\n      return existing;\n    }\n\n    // Split the child if it's overfull.\n    if (child.width > MAX_NODE_WIDTH) {\n      let next = splitNode(child);\n      ArrayExt.insert(node.children, i + 1, next);\n      ArrayExt.insert(node.items, i + 1, next.items[0]);\n    }\n\n    // Update the dirty sizes of the branch.\n    updateSizes(node, i);\n\n    // Return the existing item.\n    return existing;\n  }\n\n  /**\n   * Delete an item in the tree.\n   *\n   * @param node - The node of interest.\n   *\n   * @param key - The key of interest.\n   *\n   * @param cmp - The key comparison function.\n   *\n   * @returns The deleted item or `undefined`.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   *\n   * #### Notes\n   * The root may be underfull after calling this function.\n   */\n  export function deleteItem<T, U>(\n    node: Node<T>,\n    key: U,\n    cmp: (item: T, key: U) => number\n  ): T | undefined {\n    // Handle leaf nodes first.\n    if (node.type === NodeType.Leaf) {\n      // Find the index for the given key.\n      let i = findKeyIndex(node.items, key, cmp);\n\n      // Bail early if the item does not exist.\n      if (i < 0) {\n        return undefined;\n      }\n\n      // Remove the item at the computed index.\n      return ArrayExt.removeAt(node.items, i);\n    }\n\n    // Find the pivot index for the delete.\n    let i = findPivotIndexByKey(node.items, key, cmp);\n\n    // Fetch the pivot child.\n    let child = node.children[i];\n\n    // Fetch the current size of the child.\n    let prevSize = child.size;\n\n    // Recursively remove the item from the child.\n    let item = deleteItem(child, key, cmp);\n\n    // Fetch the updated size of the child.\n    let currSize = child.size;\n\n    // Bail early if the child size did not change.\n    if (prevSize === currSize) {\n      return item;\n    }\n\n    // Update the item state of the branch.\n    node.items[i] = child.items[0];\n\n    // Join the child if it's underfull.\n    if (child.width < MIN_NODE_WIDTH) {\n      i = joinChild(node, i);\n    }\n\n    // Update the dirty sizes of the branch.\n    updateSizes(node, i);\n\n    // Return the deleted item.\n    return item;\n  }\n\n  /**\n   * Remove an item from the tree.\n   *\n   * @param node - The node of interest.\n   *\n   * @param index - The index of interest.\n   *\n   * @returns The removed item or `undefined`.\n   *\n   * #### Complexity\n   * `O(log32 n)`\n   *\n   * #### Notes\n   * The root may be underfull after calling this function.\n   */\n  export function removeItem<T>(node: Node<T>, index: number): T | undefined {\n    // Wrap negative indices.\n    if (index < 0) {\n      index += node.size;\n    }\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= node.size) {\n      return undefined;\n    }\n\n    // Handle leaf nodes first.\n    if (node.type === NodeType.Leaf) {\n      return ArrayExt.removeAt(node.items, index);\n    }\n\n    // Find the pivot index for the remove.\n    let i = findPivotIndexByIndex(node.sizes, index);\n    if (i > 0) index -= node.sizes[i];\n\n    // Fetch the pivot child.\n    let child = node.children[i];\n\n    // Recursively remove the item from the child.\n    let item = removeItem(child, index);\n\n    // Update the item state of the branch.\n    node.items[i] = child.items[0];\n\n    // Join the child if it's underfull.\n    if (child.width < MIN_NODE_WIDTH) {\n      i = joinChild(node, i);\n    }\n\n    // Update the dirty sizes of the branch.\n    updateSizes(node, i);\n\n    // Return the removed item.\n    return item;\n  }\n\n  /**\n   * Recursively clear the contents of a node.\n   *\n   * @param node - The node of interest.\n   *\n   * #### Complexity\n   * `O(n)`\n   */\n  export function clear<T>(node: Node<T>): void {\n    if (node.type === NodeType.Branch) {\n      each(node.children, clear);\n      node.children.length = 0;\n      node.sizes.length = 0;\n      node.items.length = 0;\n    } else {\n      node.items.length = 0;\n      node.next = null;\n      node.prev = null;\n    }\n  }\n\n  /**\n   * Split a root node and create a new root, if needed.\n   *\n   * @param node - The root node of interest.\n   *\n   * @returns The new root node.\n   */\n  export function maybeSplitRoot<T>(node: Node<T>): Node<T> {\n    // Bail early if the current root is not overfull.\n    if (node.width <= MAX_NODE_WIDTH) {\n      return node;\n    }\n\n    // Create a new root branch node.\n    let root = new BranchNode<T>();\n\n    // Split the node to the right and create a new sibling.\n    let next = splitNode(node);\n\n    // Add the sizes to the root.\n    root.sizes[0] = node.size;\n    root.sizes[1] = node.size + next.size;\n\n    // Add the children to the root.\n    root.children[0] = node;\n    root.children[1] = next;\n\n    // Add the items to the root.\n    root.items[0] = node.items[0];\n    root.items[1] = next.items[0];\n\n    // Return the new root node.\n    return root;\n  }\n\n  /**\n   * Extract a single node child as a new root, if needed.\n   *\n   * @param node - The root node of interest.\n   *\n   * @returns The new root node.\n   */\n  export function maybeExtractRoot<T>(node: Node<T>): Node<T> {\n    // Bail early if the node it already a leaf.\n    if (node.type === NodeType.Leaf) {\n      return node;\n    }\n\n    // Bail early if the branch has more than one child.\n    if (node.children.length > 1) {\n      return node;\n    }\n\n    // Extract the sole remaining child as the new root.\n    let root = node.children.pop()!;\n\n    // Clear the rest of the node state.\n    clear(node);\n\n    // Return the new root.\n    return root;\n  }\n\n  /**\n   * The maximum width for a node in the tree.\n   */\n  const MAX_NODE_WIDTH = 32;\n\n  /**\n   * The minimum width for a node in the tree.\n   */\n  const MIN_NODE_WIDTH = MAX_NODE_WIDTH >> 1;\n\n  /**\n   * A forward iterator for a B+ tree.\n   */\n  class ForwardIterator<T> implements IIterator<T> {\n    /**\n     * Construct a new forward iterator.\n     *\n     * @param node - The first leaf node in the chain.\n     *\n     * @param index - The local index of the first item.\n     *\n     * @param count - The number of items to iterate. A value `< 0`\n     *   will iterate all available items.\n     */\n    constructor(node: LeafNode<T> | null, index: number, count: number) {\n      this._node = node;\n      this._index = index;\n      this._count = count;\n    }\n\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    iter(): IIterator<T> {\n      return this;\n    }\n\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    clone(): IIterator<T> {\n      return new ForwardIterator<T>(this._node, this._index, this._count);\n    }\n\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    next(): T | undefined {\n      if (this._node === null || this._count === 0) {\n        return undefined;\n      }\n      if (this._index >= this._node.size) {\n        this._node = this._node.next;\n        this._index = 0;\n        return this.next();\n      }\n      if (this._count > 0) {\n        this._count--;\n      }\n      return this._node.items[this._index++];\n    }\n\n    private _index: number;\n    private _count: number;\n    private _node: LeafNode<T> | null;\n  }\n\n  /**\n   * A reverse iterator for a B+ tree.\n   */\n  class RetroIterator<T> implements IIterator<T> {\n    /**\n     * Construct a new retro iterator.\n     *\n     * @param node - The last leaf node in the chain.\n     *\n     * @param index - The local index of the last item.\n     *\n     * @param count - The number of items to iterate. A value `< 0`\n     *   will iterate all available items.\n     */\n    constructor(node: LeafNode<T> | null, index: number, count: number) {\n      this._node = node;\n      this._index = index;\n      this._count = count;\n    }\n\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    iter(): IIterator<T> {\n      return this;\n    }\n\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    clone(): IIterator<T> {\n      return new RetroIterator<T>(this._node, this._index, this._count);\n    }\n\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    next(): T | undefined {\n      if (this._node === null || this._count === 0) {\n        return undefined;\n      }\n      if (this._index >= this._node.size) {\n        this._index = this._node.size - 1;\n      }\n      if (this._index < 0) {\n        this._node = this._node.prev;\n        this._index = this._node ? this._node.size - 1 : -1;\n        return this.next();\n      }\n      if (this._count > 0) {\n        this._count--;\n      }\n      return this._node.items[this._index--];\n    }\n\n    private _index: number;\n    private _count: number;\n    private _node: LeafNode<T> | null;\n  }\n\n  /**\n   * Find the pivot index for a particular local index.\n   */\n  function findPivotIndexByIndex(sizes: number[], index: number): number {\n    let n = sizes.length;\n    for (let i = 0; i < n; ++i) {\n      if (sizes[i] > index) {\n        return i;\n      }\n    }\n    return n - 1;\n  }\n\n  /**\n   * Find the pivot index for a particular key.\n   */\n  function findPivotIndexByKey<T, U>(\n    items: T[],\n    key: U,\n    cmp: (item: T, key: U) => number\n  ): number {\n    let n = items.length;\n    for (let i = 1; i < n; ++i) {\n      if (cmp(items[i], key) > 0) {\n        return i - 1;\n      }\n    }\n    return n - 1;\n  }\n\n  /**\n   * Find the key index for a particular key.\n   */\n  function findKeyIndex<T, U>(\n    items: T[],\n    key: U,\n    cmp: (item: T, key: U) => number\n  ): number {\n    let n = items.length;\n    for (let i = 0; i < n; ++i) {\n      let c = cmp(items[i], key);\n      if (c === 0) {\n        return i;\n      }\n      if (c > 0) {\n        return -i - 1;\n      }\n    }\n    return -n - 1;\n  }\n\n  /**\n   * Update the sizes of a branch node starting at the given index.\n   */\n  function updateSizes<T>(node: BranchNode<T>, i: number): void {\n    let { sizes, children } = node;\n    let last = i > 0 ? sizes[i - 1] : 0;\n    for (let n = children.length; i < n; ++i) {\n      last = sizes[i] = last + children[i].size;\n    }\n    sizes.length = children.length;\n  }\n\n  /**\n   * Split a node and return its new next sibling.\n   *\n   * @param node - The node of interest.\n   *\n   * @returns The new next sibling node.\n   */\n  function splitNode<T>(node: Node<T>): Node<T> {\n    // Handle leaf nodes first.\n    if (node.type === NodeType.Leaf) {\n      // Create the new sibling leaf node.\n      let next = new LeafNode<T>();\n\n      // Move the items to the new sibling.\n      let v1 = node.items;\n      let v2 = next.items;\n      for (let i = MIN_NODE_WIDTH, n = v1.length; i < n; ++i) {\n        v2.push(v1[i]);\n      }\n      v1.length = MIN_NODE_WIDTH;\n\n      // Patch up the sibling links.\n      if (node.next) node.next.prev = next;\n      next.next = node.next;\n      next.prev = node;\n      node.next = next;\n\n      // Return the new next sibling.\n      return next;\n    }\n\n    // Create the new sibling branch node.\n    let next = new BranchNode<T>();\n\n    // Move the children to the new sibling.\n    let c1 = node.children;\n    let c2 = next.children;\n    for (let i = MIN_NODE_WIDTH, n = c1.length; i < n; ++i) {\n      c2.push(c1[i]);\n    }\n    c1.length = MIN_NODE_WIDTH;\n\n    // Move the items to the new sibling.\n    let v1 = node.items;\n    let v2 = next.items;\n    for (let i = MIN_NODE_WIDTH, n = v1.length; i < n; ++i) {\n      v2.push(v1[i]);\n    }\n    v1.length = MIN_NODE_WIDTH;\n\n    // Update the dirty sizes of the nodes.\n    updateSizes(node, MIN_NODE_WIDTH);\n    updateSizes(next, 0);\n\n    // Return the new next sibling.\n    return next;\n  }\n\n  /**\n   * Join a child node of a branch with one of its siblings.\n   *\n   * @param node - The branch node of interest.\n   *\n   * @param i - The index of the child node of interest.\n   *\n   * @returns The first modified index.\n   *\n   * #### Notes\n   * This may cause the branch to become underfull.\n   */\n  function joinChild<T>(node: BranchNode<T>, i: number): number {\n    // Fetch the child to be joined.\n    let child = node.children[i];\n\n    // Fetch the relevant sibling.\n    let sibling = i === 0 ? node.children[i + 1] : node.children[i - 1];\n\n    // Compute the flags which control the join behavior.\n    let hasNext = i === 0;\n    let isLeaf = child.type === NodeType.Leaf;\n    let hasExtra = sibling.width > MIN_NODE_WIDTH;\n\n    // Join case #1: steal from next sibling leaf\n    if (isLeaf && hasExtra && hasNext) {\n      // Cast the children as leaves.\n      let c = child as LeafNode<T>;\n      let s = sibling as LeafNode<T>;\n\n      // Steal an item.\n      c.items.push(s.items.shift()!);\n\n      // Update the branch items.\n      node.items[i + 1] = s.items[0];\n\n      // Return the first modified index.\n      return i;\n    }\n\n    // Join case #2: steal from previous sibling leaf\n    if (isLeaf && hasExtra && !hasNext) {\n      // Cast the children as leaves.\n      let c = child as LeafNode<T>;\n      let s = sibling as LeafNode<T>;\n\n      // Steal an item.\n      c.items.unshift(s.items.pop()!);\n\n      // Update the branch items.\n      node.items[i] = c.items[0];\n\n      // Return the first modified index.\n      return i - 1;\n    }\n\n    // Join case #3: merge with next sibling leaf\n    if (isLeaf && !hasExtra && hasNext) {\n      // Cast the children as leaves.\n      let c = child as LeafNode<T>;\n      let s = sibling as LeafNode<T>;\n\n      // Merge items.\n      s.items.unshift(...c.items);\n\n      // Remove the old branch child.\n      ArrayExt.removeAt(node.children, i);\n\n      // Remove the stale branch item.\n      ArrayExt.removeAt(node.items, i + 1);\n\n      // Patch up the sibling links.\n      if (c.prev) c.prev.next = s;\n      s.prev = c.prev;\n\n      // Clear the original child.\n      clear(c);\n\n      // Return the first modified index.\n      return i;\n    }\n\n    // Join case #4: merge with previous sibling leaf\n    if (isLeaf && !hasExtra && !hasNext) {\n      // Cast the children as leaves.\n      let c = child as LeafNode<T>;\n      let s = sibling as LeafNode<T>;\n\n      // Merge items.\n      s.items.push(...c.items);\n\n      // Remove the old branch child.\n      ArrayExt.removeAt(node.children, i);\n\n      // Remove the stale branch item.\n      ArrayExt.removeAt(node.items, i);\n\n      // Patch up the sibling links.\n      if (c.next) c.next.prev = s;\n      s.next = c.next;\n\n      // Clear the original child.\n      clear(c);\n\n      // Return the first modified index.\n      return i - 1;\n    }\n\n    // Join case #5: steal from next sibling branch\n    if (!isLeaf && hasExtra && hasNext) {\n      // Cast the children to branches.\n      let c = child as BranchNode<T>;\n      let s = sibling as BranchNode<T>;\n\n      // Steal a child from the next sibling.\n      c.children.push(s.children.shift()!);\n\n      // Steal an item from the next sibling.\n      c.items.push(s.items.shift()!);\n\n      // Update the branch items.\n      node.items[i + 1] = s.items[0];\n\n      // Update the sibling sizes.\n      updateSizes(c, c.width - 1);\n      updateSizes(s, 0);\n\n      // Return the first modified index.\n      return i;\n    }\n\n    // Join case #6: steal from previous sibling branch\n    if (!isLeaf && hasExtra && !hasNext) {\n      // Cast the children to branches.\n      let c = child as BranchNode<T>;\n      let s = sibling as BranchNode<T>;\n\n      // Steal a child from the previous sibling.\n      c.children.unshift(s.children.pop()!);\n\n      // Steal an item from the previous sibling.\n      c.items.unshift(s.items.pop()!);\n\n      // Update the branch items.\n      node.items[i] = c.items[0];\n\n      // Update the sibling sizes.\n      updateSizes(c, 0);\n      updateSizes(s, s.width - 1);\n\n      // Return the first modified index.\n      return i - 1;\n    }\n\n    // Join case #7: merge with next sibling branch\n    if (!isLeaf && !hasExtra && hasNext) {\n      // Cast the children to branches.\n      let c = child as BranchNode<T>;\n      let s = sibling as BranchNode<T>;\n\n      // Merge the children with the next sibling.\n      s.children.unshift(...c.children);\n\n      // Merge the items with the next sibling.\n      s.items.unshift(...c.items);\n\n      // Remove the old branch child.\n      ArrayExt.removeAt(node.children, i);\n\n      // Remove the stale branch item.\n      ArrayExt.removeAt(node.items, i + 1);\n\n      // Update the sibling sizes.\n      updateSizes(s, 0);\n\n      // Clear the original child but, not its children.\n      c.children.length = 0;\n      clear(c);\n\n      // Return the first modified index.\n      return i;\n    }\n\n    // Join case #8: merge with previous sibling branch\n    if (!isLeaf && !hasExtra && !hasNext) {\n      // Cast the children to branches.\n      let c = child as BranchNode<T>;\n      let s = sibling as BranchNode<T>;\n\n      // Merge the children with the previous sibling.\n      s.children.push(...c.children);\n\n      // Merge the items with the previous sibling.\n      s.items.push(...c.items);\n\n      // Remove the old branch child.\n      ArrayExt.removeAt(node.children, i);\n\n      // Remove the stale branch item.\n      ArrayExt.removeAt(node.items, i);\n\n      // Update the sibling sizes.\n      updateSizes(s, 0);\n\n      // Clear the original child, but not its children.\n      c.children.length = 0;\n      clear(c);\n\n      // Return the first modified index.\n      return i - 1;\n    }\n\n    // One of the above cases must match.\n    throw 'unreachable';\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  each,\n  IIterable,\n  IIterator,\n  IRetroable,\n  IterableOrArrayLike\n} from '@lumino/algorithm';\n\n/**\n * A generic doubly-linked list.\n */\nexport class LinkedList<T> implements IIterable<T>, IRetroable<T> {\n  /**\n   * Whether the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get isEmpty(): boolean {\n    return this._size === 0;\n  }\n\n  /**\n   * The size of the list.\n   *\n   * #### Complexity\n   * `O(1)`\n   *\n   * #### Notes\n   * This is equivalent to `length`.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * The length of the list.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * This is equivalent to `size`.\n   *\n   * This property is deprecated.\n   */\n  get length(): number {\n    return this._size;\n  }\n\n  /**\n   * The first value in the list.\n   *\n   * This is `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get first(): T | undefined {\n    return this._first ? this._first.value : undefined;\n  }\n\n  /**\n   * The last value in the list.\n   *\n   * This is `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get last(): T | undefined {\n    return this._last ? this._last.value : undefined;\n  }\n\n  /**\n   * The first node in the list.\n   *\n   * This is `null` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get firstNode(): LinkedList.INode<T> | null {\n    return this._first;\n  }\n\n  /**\n   * The last node in the list.\n   *\n   * This is `null` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get lastNode(): LinkedList.INode<T> | null {\n    return this._last;\n  }\n\n  /**\n   * Create an iterator over the values in the list.\n   *\n   * @returns A new iterator starting with the first value.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  iter(): IIterator<T> {\n    return new LinkedList.ForwardValueIterator<T>(this._first);\n  }\n\n  /**\n   * Create a reverse iterator over the values in the list.\n   *\n   * @returns A new iterator starting with the last value.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  retro(): IIterator<T> {\n    return new LinkedList.RetroValueIterator<T>(this._last);\n  }\n\n  /**\n   * Create an iterator over the nodes in the list.\n   *\n   * @returns A new iterator starting with the first node.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  nodes(): IIterator<LinkedList.INode<T>> {\n    return new LinkedList.ForwardNodeIterator<T>(this._first);\n  }\n\n  /**\n   * Create a reverse iterator over the nodes in the list.\n   *\n   * @returns A new iterator starting with the last node.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  retroNodes(): IIterator<LinkedList.INode<T>> {\n    return new LinkedList.RetroNodeIterator<T>(this._last);\n  }\n\n  /**\n   * Assign new values to the list, replacing all current values.\n   *\n   * @param values - The values to assign to the list.\n   *\n   * #### Complexity\n   * Linear.\n   */\n  assign(values: IterableOrArrayLike<T>): void {\n    this.clear();\n    each(values, value => {\n      this.addLast(value);\n    });\n  }\n\n  /**\n   * Add a value to the end of the list.\n   *\n   * @param value - The value to add to the end of the list.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * This is equivalent to `addLast`.\n   */\n  push(value: T): void {\n    this.addLast(value);\n  }\n\n  /**\n   * Remove and return the value at the end of the list.\n   *\n   * @returns The removed value, or `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * This is equivalent to `removeLast`.\n   */\n  pop(): T | undefined {\n    return this.removeLast();\n  }\n\n  /**\n   * Add a value to the beginning of the list.\n   *\n   * @param value - The value to add to the beginning of the list.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * This is equivalent to `addFirst`.\n   */\n  shift(value: T): void {\n    this.addFirst(value);\n  }\n\n  /**\n   * Remove and return the value at the beginning of the list.\n   *\n   * @returns The removed value, or `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * This is equivalent to `removeFirst`.\n   */\n  unshift(): T | undefined {\n    return this.removeFirst();\n  }\n\n  /**\n   * Add a value to the beginning of the list.\n   *\n   * @param value - The value to add to the beginning of the list.\n   *\n   * @returns The list node which holds the value.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  addFirst(value: T): LinkedList.INode<T> {\n    let node = new Private.LinkedListNode<T>(this, value);\n    if (!this._first) {\n      this._first = node;\n      this._last = node;\n    } else {\n      node.next = this._first;\n      this._first.prev = node;\n      this._first = node;\n    }\n    this._size++;\n    return node;\n  }\n\n  /**\n   * Add a value to the end of the list.\n   *\n   * @param value - The value to add to the end of the list.\n   *\n   * @returns The list node which holds the value.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  addLast(value: T): LinkedList.INode<T> {\n    let node = new Private.LinkedListNode<T>(this, value);\n    if (!this._last) {\n      this._first = node;\n      this._last = node;\n    } else {\n      node.prev = this._last;\n      this._last.next = node;\n      this._last = node;\n    }\n    this._size++;\n    return node;\n  }\n\n  /**\n   * Insert a value before a specific node in the list.\n   *\n   * @param value - The value to insert before the reference node.\n   *\n   * @param ref - The reference node of interest. If this is `null`,\n   *   the value will be added to the beginning of the list.\n   *\n   * @returns The list node which holds the value.\n   *\n   * #### Notes\n   * The reference node must be owned by the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  insertBefore(value: T, ref: LinkedList.INode<T> | null): LinkedList.INode<T> {\n    if (!ref || ref === this._first) {\n      return this.addFirst(value);\n    }\n    if (!(ref instanceof Private.LinkedListNode) || ref.list !== this) {\n      throw new Error('Reference node is not owned by the list.');\n    }\n    let node = new Private.LinkedListNode<T>(this, value);\n    let _ref = ref as Private.LinkedListNode<T>;\n    let prev = _ref.prev!;\n    node.next = _ref;\n    node.prev = prev;\n    _ref.prev = node;\n    prev.next = node;\n    this._size++;\n    return node;\n  }\n\n  /**\n   * Insert a value after a specific node in the list.\n   *\n   * @param value - The value to insert after the reference node.\n   *\n   * @param ref - The reference node of interest. If this is `null`,\n   *   the value will be added to the end of the list.\n   *\n   * @returns The list node which holds the value.\n   *\n   * #### Notes\n   * The reference node must be owned by the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  insertAfter(value: T, ref: LinkedList.INode<T> | null): LinkedList.INode<T> {\n    if (!ref || ref === this._last) {\n      return this.addLast(value);\n    }\n    if (!(ref instanceof Private.LinkedListNode) || ref.list !== this) {\n      throw new Error('Reference node is not owned by the list.');\n    }\n    let node = new Private.LinkedListNode<T>(this, value);\n    let _ref = ref as Private.LinkedListNode<T>;\n    let next = _ref.next!;\n    node.next = next;\n    node.prev = _ref;\n    _ref.next = node;\n    next.prev = node;\n    this._size++;\n    return node;\n  }\n\n  /**\n   * Remove and return the value at the beginning of the list.\n   *\n   * @returns The removed value, or `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  removeFirst(): T | undefined {\n    let node = this._first;\n    if (!node) {\n      return undefined;\n    }\n    if (node === this._last) {\n      this._first = null;\n      this._last = null;\n    } else {\n      this._first = node.next;\n      this._first!.prev = null;\n    }\n    node.list = null;\n    node.next = null;\n    node.prev = null;\n    this._size--;\n    return node.value;\n  }\n\n  /**\n   * Remove and return the value at the end of the list.\n   *\n   * @returns The removed value, or `undefined` if the list is empty.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  removeLast(): T | undefined {\n    let node = this._last;\n    if (!node) {\n      return undefined;\n    }\n    if (node === this._first) {\n      this._first = null;\n      this._last = null;\n    } else {\n      this._last = node.prev;\n      this._last!.next = null;\n    }\n    node.list = null;\n    node.next = null;\n    node.prev = null;\n    this._size--;\n    return node.value;\n  }\n\n  /**\n   * Remove a specific node from the list.\n   *\n   * @param node - The node to remove from the list.\n   *\n   * #### Complexity\n   * Constant.\n   *\n   * #### Notes\n   * The node must be owned by the list.\n   */\n  removeNode(node: LinkedList.INode<T>): void {\n    if (!(node instanceof Private.LinkedListNode) || node.list !== this) {\n      throw new Error('Node is not owned by the list.');\n    }\n    let _node = node as Private.LinkedListNode<T>;\n    if (_node === this._first && _node === this._last) {\n      this._first = null;\n      this._last = null;\n    } else if (_node === this._first) {\n      this._first = _node.next;\n      this._first!.prev = null;\n    } else if (_node === this._last) {\n      this._last = _node.prev;\n      this._last!.next = null;\n    } else {\n      _node.next!.prev = _node.prev;\n      _node.prev!.next = _node.next;\n    }\n    _node.list = null;\n    _node.next = null;\n    _node.prev = null;\n    this._size--;\n  }\n\n  /**\n   * Remove all values from the list.\n   *\n   * #### Complexity\n   * Linear.\n   */\n  clear(): void {\n    let node = this._first;\n    while (node) {\n      let next = node.next;\n      node.list = null;\n      node.prev = null;\n      node.next = null;\n      node = next;\n    }\n    this._first = null;\n    this._last = null;\n    this._size = 0;\n  }\n\n  private _first: Private.LinkedListNode<T> | null = null;\n  private _last: Private.LinkedListNode<T> | null = null;\n  private _size = 0;\n}\n\n/**\n * The namespace for the `LinkedList` class statics.\n */\nexport namespace LinkedList {\n  /**\n   * An object which represents a node in a linked list.\n   *\n   * #### Notes\n   * User code will not create linked list nodes directly. Nodes\n   * are created automatically when values are added to a list.\n   */\n  export interface INode<T> {\n    /**\n     * The linked list which created and owns the node.\n     *\n     * This will be `null` when the node is removed from the list.\n     */\n    readonly list: LinkedList<T> | null;\n\n    /**\n     * The next node in the list.\n     *\n     * This will be `null` when the node is the last node in the list\n     * or when the node is removed from the list.\n     */\n    readonly next: INode<T> | null;\n\n    /**\n     * The previous node in the list.\n     *\n     * This will be `null` when the node is the first node in the list\n     * or when the node is removed from the list.\n     */\n    readonly prev: INode<T> | null;\n\n    /**\n     * The user value stored in the node.\n     */\n    readonly value: T;\n  }\n\n  /**\n   * Create a linked list from an iterable of values.\n   *\n   * @param values - The iterable or array-like object of interest.\n   *\n   * @returns A new linked list initialized with the given values.\n   *\n   * #### Complexity\n   * Linear.\n   */\n  export function from<T>(values: IterableOrArrayLike<T>): LinkedList<T> {\n    let list = new LinkedList<T>();\n    list.assign(values);\n    return list;\n  }\n\n  /**\n   * A forward iterator for values in a linked list.\n   */\n  export class ForwardValueIterator<T> implements IIterator<T> {\n    /**\n     * Construct a forward value iterator.\n     *\n     * @param node - The first node in the list.\n     */\n    constructor(node: INode<T> | null) {\n      this._node = node;\n    }\n\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    iter(): IIterator<T> {\n      return this;\n    }\n\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    clone(): IIterator<T> {\n      return new ForwardValueIterator<T>(this._node);\n    }\n\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    next(): T | undefined {\n      if (!this._node) {\n        return undefined;\n      }\n      let node = this._node;\n      this._node = node.next;\n      return node.value;\n    }\n\n    private _node: INode<T> | null;\n  }\n\n  /**\n   * A reverse iterator for values in a linked list.\n   */\n  export class RetroValueIterator<T> implements IIterator<T> {\n    /**\n     * Construct a retro value iterator.\n     *\n     * @param node - The last node in the list.\n     */\n    constructor(node: INode<T> | null) {\n      this._node = node;\n    }\n\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    iter(): IIterator<T> {\n      return this;\n    }\n\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    clone(): IIterator<T> {\n      return new RetroValueIterator<T>(this._node);\n    }\n\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    next(): T | undefined {\n      if (!this._node) {\n        return undefined;\n      }\n      let node = this._node;\n      this._node = node.prev;\n      return node.value;\n    }\n\n    private _node: INode<T> | null;\n  }\n\n  /**\n   * A forward iterator for nodes in a linked list.\n   */\n  export class ForwardNodeIterator<T> implements IIterator<INode<T>> {\n    /**\n     * Construct a forward node iterator.\n     *\n     * @param node - The first node in the list.\n     */\n    constructor(node: INode<T> | null) {\n      this._node = node;\n    }\n\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    iter(): IIterator<INode<T>> {\n      return this;\n    }\n\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    clone(): IIterator<INode<T>> {\n      return new ForwardNodeIterator<T>(this._node);\n    }\n\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    next(): INode<T> | undefined {\n      if (!this._node) {\n        return undefined;\n      }\n      let node = this._node;\n      this._node = node.next;\n      return node;\n    }\n\n    private _node: INode<T> | null;\n  }\n\n  /**\n   * A reverse iterator for nodes in a linked list.\n   */\n  export class RetroNodeIterator<T> implements IIterator<INode<T>> {\n    /**\n     * Construct a retro node iterator.\n     *\n     * @param node - The last node in the list.\n     */\n    constructor(node: INode<T> | null) {\n      this._node = node;\n    }\n\n    /**\n     * Get an iterator over the object's values.\n     *\n     * @returns An iterator which yields the object's values.\n     */\n    iter(): IIterator<INode<T>> {\n      return this;\n    }\n\n    /**\n     * Create an independent clone of the iterator.\n     *\n     * @returns A new independent clone of the iterator.\n     */\n    clone(): IIterator<INode<T>> {\n      return new RetroNodeIterator<T>(this._node);\n    }\n\n    /**\n     * Get the next value from the iterator.\n     *\n     * @returns The next value from the iterator, or `undefined`.\n     */\n    next(): INode<T> | undefined {\n      if (!this._node) {\n        return undefined;\n      }\n      let node = this._node;\n      this._node = node.prev;\n      return node;\n    }\n\n    private _node: INode<T> | null;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * The internal linked list node implementation.\n   */\n  export class LinkedListNode<T> {\n    /**\n     * The linked list which created and owns the node.\n     */\n    list: LinkedList<T> | null = null;\n\n    /**\n     * The next node in the list.\n     */\n    next: LinkedListNode<T> | null = null;\n\n    /**\n     * The previous node in the list.\n     */\n    prev: LinkedListNode<T> | null = null;\n\n    /**\n     * The user value stored in the node.\n     */\n    readonly value: T;\n\n    /**\n     * Construct a new linked list node.\n     *\n     * @param list - The list which owns the node.\n     *\n     * @param value - The value for the link.\n     */\n    constructor(list: LinkedList<T>, value: T) {\n      this.list = list;\n      this.value = value;\n    }\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || from);\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt, each, every, retro, some } from '@lumino/algorithm';\n\nimport { LinkedList } from '@lumino/collections';\n\n/**\n * A message which can be delivered to a message handler.\n *\n * #### Notes\n * This class may be subclassed to create complex message types.\n */\nexport class Message {\n  /**\n   * Construct a new message.\n   *\n   * @param type - The type of the message.\n   */\n  constructor(type: string) {\n    this.type = type;\n  }\n\n  /**\n   * The type of the message.\n   *\n   * #### Notes\n   * The `type` of a message should be related directly to its actual\n   * runtime type. This means that `type` can and will be used to cast\n   * the message to the relevant derived `Message` subtype.\n   */\n  readonly type: string;\n\n  /**\n   * Test whether the message is conflatable.\n   *\n   * #### Notes\n   * Message conflation is an advanced topic. Most message types will\n   * not make use of this feature.\n   *\n   * If a conflatable message is posted to a handler while another\n   * conflatable message of the same `type` has already been posted\n   * to the handler, the `conflate()` method of the existing message\n   * will be invoked. If that method returns `true`, the new message\n   * will not be enqueued. This allows messages to be compressed, so\n   * that only a single instance of the message type is processed per\n   * cycle, no matter how many times messages of that type are posted.\n   *\n   * Custom message types may reimplement this property.\n   *\n   * The default implementation is always `false`.\n   */\n  get isConflatable(): boolean {\n    return false;\n  }\n\n  /**\n   * Conflate this message with another message of the same `type`.\n   *\n   * @param other - A conflatable message of the same `type`.\n   *\n   * @returns `true` if the message was successfully conflated, or\n   *   `false` otherwise.\n   *\n   * #### Notes\n   * Message conflation is an advanced topic. Most message types will\n   * not make use of this feature.\n   *\n   * This method is called automatically by the message loop when the\n   * given message is posted to the handler paired with this message.\n   * This message will already be enqueued and conflatable, and the\n   * given message will have the same `type` and also be conflatable.\n   *\n   * This method should merge the state of the other message into this\n   * message as needed so that when this message is finally delivered\n   * to the handler, it receives the most up-to-date information.\n   *\n   * If this method returns `true`, it signals that the other message\n   * was successfully conflated and that message will not be enqueued.\n   *\n   * If this method returns `false`, the other message will be enqueued\n   * for normal delivery.\n   *\n   * Custom message types may reimplement this method.\n   *\n   * The default implementation always returns `false`.\n   */\n  conflate(other: Message): boolean {\n    return false;\n  }\n}\n\n/**\n * A convenience message class which conflates automatically.\n *\n * #### Notes\n * Message conflation is an advanced topic. Most user code will not\n * make use of this class.\n *\n * This message class is useful for creating message instances which\n * should be conflated, but which have no state other than `type`.\n *\n * If conflation of stateful messages is required, a custom `Message`\n * subclass should be created.\n */\nexport class ConflatableMessage extends Message {\n  /**\n   * Test whether the message is conflatable.\n   *\n   * #### Notes\n   * This property is always `true`.\n   */\n  get isConflatable(): boolean {\n    return true;\n  }\n\n  /**\n   * Conflate this message with another message of the same `type`.\n   *\n   * #### Notes\n   * This method always returns `true`.\n   */\n  conflate(other: ConflatableMessage): boolean {\n    return true;\n  }\n}\n\n/**\n * An object which handles messages.\n *\n * #### Notes\n * A message handler is a simple way of defining a type which can act\n * upon on a large variety of external input without requiring a large\n * abstract API surface. This is particularly useful in the context of\n * widget frameworks where the number of distinct message types can be\n * unbounded.\n */\nexport interface IMessageHandler {\n  /**\n   * Process a message sent to the handler.\n   *\n   * @param msg - The message to be processed.\n   */\n  processMessage(msg: Message): void;\n}\n\n/**\n * An object which intercepts messages sent to a message handler.\n *\n * #### Notes\n * A message hook is useful for intercepting or spying on messages\n * sent to message handlers which were either not created by the\n * consumer, or when subclassing the handler is not feasible.\n *\n * If `messageHook` returns `false`, no other message hooks will be\n * invoked and the message will not be delivered to the handler.\n *\n * If all installed message hooks return `true`, the message will\n * be delivered to the handler for processing.\n *\n * **See also:** [[installMessageHook]] and [[removeMessageHook]]\n */\nexport interface IMessageHook {\n  /**\n   * Intercept a message sent to a message handler.\n   *\n   * @param handler - The target handler of the message.\n   *\n   * @param msg - The message to be sent to the handler.\n   *\n   * @returns `true` if the message should continue to be processed\n   *   as normal, or `false` if processing should cease immediately.\n   */\n  messageHook(handler: IMessageHandler, msg: Message): boolean;\n}\n\n/**\n * A type alias for message hook object or function.\n *\n * #### Notes\n * The signature and semantics of a message hook function are the same\n * as the `messageHook` method of [[IMessageHook]].\n */\nexport type MessageHook =\n  | IMessageHook\n  | ((handler: IMessageHandler, msg: Message) => boolean);\n\n/**\n * The namespace for the global singleton message loop.\n */\nexport namespace MessageLoop {\n  /**\n   * Send a message to a message handler to process immediately.\n   *\n   * @param handler - The handler which should process the message.\n   *\n   * @param msg - The message to deliver to the handler.\n   *\n   * #### Notes\n   * The message will first be sent through any installed message hooks\n   * for the handler. If the message passes all hooks, it will then be\n   * delivered to the `processMessage` method of the handler.\n   *\n   * The message will not be conflated with pending posted messages.\n   *\n   * Exceptions in hooks and handlers will be caught and logged.\n   */\n  export function sendMessage(handler: IMessageHandler, msg: Message): void {\n    // Lookup the message hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Handle the common case of no installed hooks.\n    if (!hooks || hooks.length === 0) {\n      invokeHandler(handler, msg);\n      return;\n    }\n\n    // Invoke the message hooks starting with the newest first.\n    let passed = every(retro(hooks), hook => {\n      return hook ? invokeHook(hook, handler, msg) : true;\n    });\n\n    // Invoke the handler if the message passes all hooks.\n    if (passed) {\n      invokeHandler(handler, msg);\n    }\n  }\n\n  /**\n   * Post a message to a message handler to process in the future.\n   *\n   * @param handler - The handler which should process the message.\n   *\n   * @param msg - The message to post to the handler.\n   *\n   * #### Notes\n   * The message will be conflated with the pending posted messages for\n   * the handler, if possible. If the message is not conflated, it will\n   * be queued for normal delivery on the next cycle of the event loop.\n   *\n   * Exceptions in hooks and handlers will be caught and logged.\n   */\n  export function postMessage(handler: IMessageHandler, msg: Message): void {\n    // Handle the common case of a non-conflatable message.\n    if (!msg.isConflatable) {\n      enqueueMessage(handler, msg);\n      return;\n    }\n\n    // Conflate the message with an existing message if possible.\n    let conflated = some(messageQueue, posted => {\n      if (posted.handler !== handler) {\n        return false;\n      }\n      if (!posted.msg) {\n        return false;\n      }\n      if (posted.msg.type !== msg.type) {\n        return false;\n      }\n      if (!posted.msg.isConflatable) {\n        return false;\n      }\n      return posted.msg.conflate(msg);\n    });\n\n    // Enqueue the message if it was not conflated.\n    if (!conflated) {\n      enqueueMessage(handler, msg);\n    }\n  }\n\n  /**\n   * Install a message hook for a message handler.\n   *\n   * @param handler - The message handler of interest.\n   *\n   * @param hook - The message hook to install.\n   *\n   * #### Notes\n   * A message hook is invoked before a message is delivered to the\n   * handler. If the hook returns `false`, no other hooks will be\n   * invoked and the message will not be delivered to the handler.\n   *\n   * The most recently installed message hook is executed first.\n   *\n   * If the hook is already installed, this is a no-op.\n   */\n  export function installMessageHook(\n    handler: IMessageHandler,\n    hook: MessageHook\n  ): void {\n    // Lookup the hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Bail early if the hook is already installed.\n    if (hooks && hooks.indexOf(hook) !== -1) {\n      return;\n    }\n\n    // Add the hook to the end, so it will be the first to execute.\n    if (!hooks) {\n      messageHooks.set(handler, [hook]);\n    } else {\n      hooks.push(hook);\n    }\n  }\n\n  /**\n   * Remove an installed message hook for a message handler.\n   *\n   * @param handler - The message handler of interest.\n   *\n   * @param hook - The message hook to remove.\n   *\n   * #### Notes\n   * It is safe to call this function while the hook is executing.\n   *\n   * If the hook is not installed, this is a no-op.\n   */\n  export function removeMessageHook(\n    handler: IMessageHandler,\n    hook: MessageHook\n  ): void {\n    // Lookup the hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Bail early if the hooks do not exist.\n    if (!hooks) {\n      return;\n    }\n\n    // Lookup the index of the hook and bail if not found.\n    let i = hooks.indexOf(hook);\n    if (i === -1) {\n      return;\n    }\n\n    // Clear the hook and schedule a cleanup of the array.\n    hooks[i] = null;\n    scheduleCleanup(hooks);\n  }\n\n  /**\n   * Clear all message data associated with a message handler.\n   *\n   * @param handler - The message handler of interest.\n   *\n   * #### Notes\n   * This will clear all posted messages and hooks for the handler.\n   */\n  export function clearData(handler: IMessageHandler): void {\n    // Lookup the hooks for the handler.\n    let hooks = messageHooks.get(handler);\n\n    // Clear all messsage hooks for the handler.\n    if (hooks && hooks.length > 0) {\n      ArrayExt.fill(hooks, null);\n      scheduleCleanup(hooks);\n    }\n\n    // Clear all posted messages for the handler.\n    each(messageQueue, posted => {\n      if (posted.handler === handler) {\n        posted.handler = null;\n        posted.msg = null;\n      }\n    });\n  }\n\n  /**\n   * Process the pending posted messages in the queue immediately.\n   *\n   * #### Notes\n   * This function is useful when posted messages must be processed\n   * immediately, instead of on the next animation frame.\n   *\n   * This function should normally not be needed, but it may be\n   * required to work around certain browser idiosyncrasies.\n   *\n   * Recursing into this function is a no-op.\n   */\n  export function flush(): void {\n    // Bail if recursion is detected or if there is no pending task.\n    if (flushGuard || loopTaskID === 0) {\n      return;\n    }\n\n    // Unschedule the pending loop task.\n    unschedule(loopTaskID);\n\n    // Run the message loop within the recursion guard.\n    flushGuard = true;\n    runMessageLoop();\n    flushGuard = false;\n  }\n\n  /**\n   * A type alias for the exception handler function.\n   */\n  export type ExceptionHandler = (err: Error) => void;\n\n  /**\n   * Get the message loop exception handler.\n   *\n   * @returns The current exception handler.\n   *\n   * #### Notes\n   * The default exception handler is `console.error`.\n   */\n  export function getExceptionHandler(): ExceptionHandler {\n    return exceptionHandler;\n  }\n\n  /**\n   * Set the message loop exception handler.\n   *\n   * @param handler - The function to use as the exception handler.\n   *\n   * @returns The old exception handler.\n   *\n   * #### Notes\n   * The exception handler is invoked when a message handler or a\n   * message hook throws an exception.\n   */\n  export function setExceptionHandler(\n    handler: ExceptionHandler\n  ): ExceptionHandler {\n    let old = exceptionHandler;\n    exceptionHandler = handler;\n    return old;\n  }\n\n  /**\n   * A type alias for a posted message pair.\n   */\n  type PostedMessage = { handler: IMessageHandler | null; msg: Message | null };\n\n  /**\n   * The queue of posted message pairs.\n   */\n  const messageQueue = new LinkedList<PostedMessage>();\n\n  /**\n   * A mapping of handler to array of installed message hooks.\n   */\n  const messageHooks = new WeakMap<\n    IMessageHandler,\n    Array<MessageHook | null>\n  >();\n\n  /**\n   * A set of message hook arrays which are pending cleanup.\n   */\n  const dirtySet = new Set<Array<MessageHook | null>>();\n\n  /**\n   * The message loop exception handler.\n   */\n  let exceptionHandler: ExceptionHandler = (err: Error) => {\n    console.error(err);\n  };\n\n  type ScheduleHandle = number | any; //  requestAnimationFrame (number) and setImmediate (any)\n\n  /**\n   * The id of the pending loop task animation frame.\n   */\n  let loopTaskID: ScheduleHandle = 0;\n\n  /**\n   * A guard flag to prevent flush recursion.\n   */\n  let flushGuard = false;\n\n  /**\n   * A function to schedule an event loop callback.\n   */\n  const schedule = ((): ScheduleHandle => {\n    let ok = typeof requestAnimationFrame === 'function';\n    return ok ? requestAnimationFrame : setImmediate;\n  })();\n\n  /**\n   * A function to unschedule an event loop callback.\n   */\n  const unschedule = (() => {\n    let ok = typeof cancelAnimationFrame === 'function';\n    return ok ? cancelAnimationFrame : clearImmediate;\n  })();\n\n  /**\n   * Invoke a message hook with the specified handler and message.\n   *\n   * Returns the result of the hook, or `true` if the hook throws.\n   *\n   * Exceptions in the hook will be caught and logged.\n   */\n  function invokeHook(\n    hook: MessageHook,\n    handler: IMessageHandler,\n    msg: Message\n  ): boolean {\n    let result = true;\n    try {\n      if (typeof hook === 'function') {\n        result = hook(handler, msg);\n      } else {\n        result = hook.messageHook(handler, msg);\n      }\n    } catch (err) {\n      exceptionHandler(err);\n    }\n    return result;\n  }\n\n  /**\n   * Invoke a message handler with the specified message.\n   *\n   * Exceptions in the handler will be caught and logged.\n   */\n  function invokeHandler(handler: IMessageHandler, msg: Message): void {\n    try {\n      handler.processMessage(msg);\n    } catch (err) {\n      exceptionHandler(err);\n    }\n  }\n\n  /**\n   * Add a message to the end of the message queue.\n   *\n   * This will automatically schedule a run of the message loop.\n   */\n  function enqueueMessage(handler: IMessageHandler, msg: Message): void {\n    // Add the posted message to the queue.\n    messageQueue.addLast({ handler, msg });\n\n    // Bail if a loop task is already pending.\n    if (loopTaskID !== 0) {\n      return;\n    }\n\n    // Schedule a run of the message loop.\n    loopTaskID = schedule(runMessageLoop);\n  }\n\n  /**\n   * Run an iteration of the message loop.\n   *\n   * This will process all pending messages in the queue. If a message\n   * is added to the queue while the message loop is running, it will\n   * be processed on the next cycle of the loop.\n   */\n  function runMessageLoop(): void {\n    // Clear the task ID so the next loop can be scheduled.\n    loopTaskID = 0;\n\n    // If the message queue is empty, there is nothing else to do.\n    if (messageQueue.isEmpty) {\n      return;\n    }\n\n    // Add a sentinel value to the end of the queue. The queue will\n    // only be processed up to the sentinel. Messages posted during\n    // this cycle will execute on the next cycle.\n    let sentinel: PostedMessage = { handler: null, msg: null };\n    messageQueue.addLast(sentinel);\n\n    // Enter the message loop.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // Remove the first posted message in the queue.\n      let posted = messageQueue.removeFirst()!;\n\n      // If the value is the sentinel, exit the loop.\n      if (posted === sentinel) {\n        return;\n      }\n\n      // Dispatch the message if it has not been cleared.\n      if (posted.handler && posted.msg) {\n        sendMessage(posted.handler, posted.msg);\n      }\n    }\n  }\n\n  /**\n   * Schedule a cleanup of a message hooks array.\n   *\n   * This will add the array to the dirty set and schedule a deferred\n   * cleanup of the array contents. On cleanup, any `null` hook will\n   * be removed from the array.\n   */\n  function scheduleCleanup(hooks: Array<MessageHook | null>): void {\n    if (dirtySet.size === 0) {\n      schedule(cleanupDirtySet);\n    }\n    dirtySet.add(hooks);\n  }\n\n  /**\n   * Cleanup the message hook arrays in the dirty set.\n   *\n   * This function should only be invoked asynchronously, when the\n   * stack frame is guaranteed to not be on the path of user code.\n   */\n  function cleanupDirtySet(): void {\n    dirtySet.forEach(cleanupHooks);\n    dirtySet.clear();\n  }\n\n  /**\n   * Cleanup the dirty hooks in a message hooks array.\n   *\n   * This will remove any `null` hook from the array.\n   *\n   * This function should only be invoked asynchronously, when the\n   * stack frame is guaranteed to not be on the path of user code.\n   */\n  function cleanupHooks(hooks: Array<MessageHook | null>): void {\n    ArrayExt.removeAllWhere(hooks, isNull);\n  }\n\n  /**\n   * Test whether a value is `null`.\n   */\n  function isNull<T>(value: T | null): boolean {\n    return value === null;\n  }\n}\n"],"names":["Private","cmp","_root","LeafNode","this","size","node","firstLeaf","items","undefined","lastLeaf","iter","iterItems","retro","retroItems","slice","start","stop","sliceItems","retroSlice","retroSliceItems","at","index","itemAt","has","key","hasItem","indexOf","get","getItem","assign","clear","update","insert","item","existing","insertItem","maybeSplitRoot","each","delete","deleteItem","maybeExtractRoot","remove","removeItem","BPlusTree","from","tree","sizes","children","length","BranchNode","next","prev","type","leaf","ForwardIterator","RetroIterator","Math","max","min","count","empty","i","findPivotIndexByIndex","findPivotIndexByKey","findKeyIndex","ArrayExt","child","prevSize","currSize","width","MAX_NODE_WIDTH","splitNode","updateSizes","MIN_NODE_WIDTH","joinChild","root","pop","_node","_index","_count","clone","n","c","last","push","c1","c2","v1","v2","sibling","hasNext","isLeaf","hasExtra","s","shift","unshift","_first","_last","_size","value","LinkedList","ForwardValueIterator","RetroValueIterator","nodes","ForwardNodeIterator","retroNodes","RetroNodeIterator","values","addLast","removeLast","addFirst","removeFirst","LinkedListNode","insertBefore","ref","list","Error","_ref","insertAfter","removeNode","MessageLoop","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","conflate","other","TypeError","String","__","constructor","create","Message","sendMessage","handler","msg","hooks","messageHooks","passed","every","hook","result","messageHook","err","exceptionHandler","invokeHook","invokeHandler","postMessage","isConflatable","some","messageQueue","posted","loopTaskID","schedule","runMessageLoop","enqueueMessage","installMessageHook","set","removeMessageHook","scheduleCleanup","clearData","flush","flushGuard","unschedule","getExceptionHandler","setExceptionHandler","old","WeakMap","dirtySet","Set","console","error","requestAnimationFrame","setImmediate","cancelAnimationFrame","clearImmediate","processMessage","isEmpty","sentinel","cleanupDirtySet","add","forEach","cleanupHooks","isNull"],"sourceRoot":""}