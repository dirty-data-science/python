{"version":3,"file":"8061.cc62561.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/commands/src/index.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/commands/node_modules/tslib/tslib.es6.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt } from '@lumino/algorithm';\n\nimport {\n  JSONExt,\n  ReadonlyJSONObject,\n  ReadonlyPartialJSONObject\n} from '@lumino/coreutils';\n\nimport { DisposableDelegate, IDisposable } from '@lumino/disposable';\n\nimport { Platform, Selector } from '@lumino/domutils';\n\nimport { getKeyboardLayout } from '@lumino/keyboard';\n\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { VirtualElement } from '@lumino/virtualdom';\n\n/**\n * An object which manages a collection of commands.\n *\n * #### Notes\n * A command registry can be used to populate a variety of action-based\n * widgets, such as command palettes, menus, and toolbars.\n */\nexport class CommandRegistry {\n  /**\n   * A signal emitted when a command has changed.\n   *\n   * #### Notes\n   * This signal is useful for visual representations of commands which\n   * need to refresh when the state of a relevant command has changed.\n   */\n  get commandChanged(): ISignal<this, CommandRegistry.ICommandChangedArgs> {\n    return this._commandChanged;\n  }\n\n  /**\n   * A signal emitted when a command has executed.\n   *\n   * #### Notes\n   * Care should be taken when consuming this signal. The command system is used\n   * by many components for many user actions. Handlers registered with this\n   * signal must return quickly to ensure the overall application remains responsive.\n   */\n  get commandExecuted(): ISignal<this, CommandRegistry.ICommandExecutedArgs> {\n    return this._commandExecuted;\n  }\n\n  /**\n   * A signal emitted when a key binding is changed.\n   */\n  get keyBindingChanged(): ISignal<\n    this,\n    CommandRegistry.IKeyBindingChangedArgs\n  > {\n    return this._keyBindingChanged;\n  }\n\n  /**\n   * A read-only array of the key bindings in the registry.\n   */\n  get keyBindings(): ReadonlyArray<CommandRegistry.IKeyBinding> {\n    return this._keyBindings;\n  }\n\n  /**\n   * List the ids of the registered commands.\n   *\n   * @returns A new array of the registered command ids.\n   */\n  listCommands(): string[] {\n    return Object.keys(this._commands);\n  }\n\n  /**\n   * Test whether a specific command is registered.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @returns `true` if the command is registered, `false` otherwise.\n   */\n  hasCommand(id: string): boolean {\n    return id in this._commands;\n  }\n\n  /**\n   * Add a command to the registry.\n   *\n   * @param id - The unique id of the command.\n   *\n   * @param options - The options for the command.\n   *\n   * @returns A disposable which will remove the command.\n   *\n   * @throws An error if the given `id` is already registered.\n   */\n  addCommand(\n    id: string,\n    options: CommandRegistry.ICommandOptions\n  ): IDisposable {\n    // Throw an error if the id is already registered.\n    if (id in this._commands) {\n      throw new Error(`Command '${id}' already registered.`);\n    }\n\n    // Add the command to the registry.\n    this._commands[id] = Private.createCommand(options);\n\n    // Emit the `commandChanged` signal.\n    this._commandChanged.emit({ id, type: 'added' });\n\n    // Return a disposable which will remove the command.\n    return new DisposableDelegate(() => {\n      // Remove the command from the registry.\n      delete this._commands[id];\n\n      // Emit the `commandChanged` signal.\n      this._commandChanged.emit({ id, type: 'removed' });\n    });\n  }\n\n  /**\n   * Notify listeners that the state of a command has changed.\n   *\n   * @param id - The id of the command which has changed. If more than\n   *   one command has changed, this argument should be omitted.\n   *\n   * @throws An error if the given `id` is not registered.\n   *\n   * #### Notes\n   * This method should be called by the command author whenever the\n   * application state changes such that the results of the command\n   * metadata functions may have changed.\n   *\n   * This will cause the `commandChanged` signal to be emitted.\n   */\n  notifyCommandChanged(id?: string): void {\n    if (id !== undefined && !(id in this._commands)) {\n      throw new Error(`Command '${id}' is not registered.`);\n    }\n    this._commandChanged.emit({ id, type: id ? 'changed' : 'many-changed' });\n  }\n\n  /**\n   * Get the description for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @returns The description for the command.\n   */\n  describedBy(id: string): { args: ReadonlyJSONObject | null } {\n    let cmd = this._commands[id];\n    return cmd ? cmd.describedBy || { args: null } : { args: null };\n  }\n\n  /**\n   * Get the display label for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The display label for the command, or an empty string\n   *   if the command is not registered.\n   */\n  label(\n    id: string,\n    args: ReadonlyPartialJSONObject = JSONExt.emptyObject\n  ): string {\n    let cmd = this._commands[id];\n    return cmd ? cmd.label.call(undefined, args) : '';\n  }\n\n  /**\n   * Get the mnemonic index for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The mnemonic index for the command, or `-1` if the\n   *   command is not registered.\n   */\n  mnemonic(\n    id: string,\n    args: ReadonlyPartialJSONObject = JSONExt.emptyObject\n  ): number {\n    let cmd = this._commands[id];\n    return cmd ? cmd.mnemonic.call(undefined, args) : -1;\n  }\n\n  /**\n   * Get the icon renderer for a specific command.\n   *\n   * DEPRECATED: if set to a string value, the .icon field will\n   * function as an alias for the .iconClass field, for backwards\n   * compatibility. In the future when this is removed, the default\n   * return type will become undefined.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The icon renderer for the command, or\n   *   an empty string if the command is not registered.\n   */\n  icon(\n    id: string,\n    args: ReadonlyPartialJSONObject = JSONExt.emptyObject\n  ):\n    | VirtualElement.IRenderer\n    | undefined\n    /* <DEPRECATED> */\n    | string /* </DEPRECATED> */ {\n    let cmd = this._commands[id];\n    return cmd\n      ? cmd.icon.call(undefined, args)\n      : /* <DEPRECATED> */ '' /* </DEPRECATED> */ /* <FUTURE> undefined </FUTURE> */;\n  }\n\n  /**\n   * Get the icon class for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The icon class for the command, or an empty string if\n   *   the command is not registered.\n   */\n  iconClass(\n    id: string,\n    args: ReadonlyPartialJSONObject = JSONExt.emptyObject\n  ): string {\n    let cmd = this._commands[id];\n    return cmd ? cmd.iconClass.call(undefined, args) : '';\n  }\n\n  /**\n   * Get the icon label for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The icon label for the command, or an empty string if\n   *   the command is not registered.\n   */\n  iconLabel(\n    id: string,\n    args: ReadonlyPartialJSONObject = JSONExt.emptyObject\n  ): string {\n    let cmd = this._commands[id];\n    return cmd ? cmd.iconLabel.call(undefined, args) : '';\n  }\n\n  /**\n   * Get the short form caption for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The caption for the command, or an empty string if the\n   *   command is not registered.\n   */\n  caption(\n    id: string,\n    args: ReadonlyPartialJSONObject = JSONExt.emptyObject\n  ): string {\n    let cmd = this._commands[id];\n    return cmd ? cmd.caption.call(undefined, args) : '';\n  }\n\n  /**\n   * Get the usage help text for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The usage text for the command, or an empty string if\n   *   the command is not registered.\n   */\n  usage(\n    id: string,\n    args: ReadonlyPartialJSONObject = JSONExt.emptyObject\n  ): string {\n    let cmd = this._commands[id];\n    return cmd ? cmd.usage.call(undefined, args) : '';\n  }\n\n  /**\n   * Get the extra class name for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The class name for the command, or an empty string if\n   *   the command is not registered.\n   */\n  className(\n    id: string,\n    args: ReadonlyPartialJSONObject = JSONExt.emptyObject\n  ): string {\n    let cmd = this._commands[id];\n    return cmd ? cmd.className.call(undefined, args) : '';\n  }\n\n  /**\n   * Get the dataset for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The dataset for the command, or an empty dataset if\n   *   the command is not registered.\n   */\n  dataset(\n    id: string,\n    args: ReadonlyPartialJSONObject = JSONExt.emptyObject\n  ): CommandRegistry.Dataset {\n    let cmd = this._commands[id];\n    return cmd ? cmd.dataset.call(undefined, args) : {};\n  }\n\n  /**\n   * Test whether a specific command is enabled.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns A boolean indicating whether the command is enabled,\n   *   or `false` if the command is not registered.\n   */\n  isEnabled(\n    id: string,\n    args: ReadonlyPartialJSONObject = JSONExt.emptyObject\n  ): boolean {\n    let cmd = this._commands[id];\n    return cmd ? cmd.isEnabled.call(undefined, args) : false;\n  }\n\n  /**\n   * Test whether a specific command is toggled.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns A boolean indicating whether the command is toggled,\n   *   or `false` if the command is not registered.\n   */\n  isToggled(\n    id: string,\n    args: ReadonlyPartialJSONObject = JSONExt.emptyObject\n  ): boolean {\n    let cmd = this._commands[id];\n    return cmd ? cmd.isToggled.call(undefined, args) : false;\n  }\n\n  /**\n   * Test whether a specific command is toggleable.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns A boolean indicating whether the command is toggleable,\n   *   or `false` if the command is not registered.\n   */\n  isToggleable(\n    id: string,\n    args: ReadonlyJSONObject = JSONExt.emptyObject\n  ): boolean {\n    let cmd = this._commands[id];\n    return cmd ? cmd.isToggleable : false;\n  }\n\n  /**\n   * Test whether a specific command is visible.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns A boolean indicating whether the command is visible,\n   *   or `false` if the command is not registered.\n   */\n  isVisible(\n    id: string,\n    args: ReadonlyPartialJSONObject = JSONExt.emptyObject\n  ): boolean {\n    let cmd = this._commands[id];\n    return cmd ? cmd.isVisible.call(undefined, args) : false;\n  }\n\n  /**\n   * Execute a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns A promise which resolves with the result of the command.\n   *\n   * #### Notes\n   * The promise will reject if the command throws an exception,\n   * or if the command is not registered.\n   */\n  execute(\n    id: string,\n    args: ReadonlyPartialJSONObject = JSONExt.emptyObject\n  ): Promise<any> {\n    // Reject if the command is not registered.\n    let cmd = this._commands[id];\n    if (!cmd) {\n      return Promise.reject(new Error(`Command '${id}' not registered.`));\n    }\n\n    // Execute the command and reject if an exception is thrown.\n    let value: any;\n    try {\n      value = cmd.execute.call(undefined, args);\n    } catch (err) {\n      value = Promise.reject(err);\n    }\n\n    // Create the return promise which resolves the result.\n    let result = Promise.resolve(value);\n\n    // Emit the command executed signal.\n    this._commandExecuted.emit({ id, args, result });\n\n    // Return the result promise to the caller.\n    return result;\n  }\n\n  /**\n   * Add a key binding to the registry.\n   *\n   * @param options - The options for creating the key binding.\n   *\n   * @returns A disposable which removes the added key binding.\n   *\n   * #### Notes\n   * If multiple key bindings are registered for the same sequence, the\n   * binding with the highest selector specificity is executed first. A\n   * tie is broken by using the most recently added key binding.\n   *\n   * Ambiguous key bindings are resolved with a timeout. As an example,\n   * suppose two key bindings are registered: one with the key sequence\n   * `['Ctrl D']`, and another with `['Ctrl D', 'Ctrl W']`. If the user\n   * presses `Ctrl D`, the first binding cannot be immediately executed\n   * since the user may intend to complete the chord with `Ctrl W`. For\n   * such cases, a timer is used to allow the chord to be completed. If\n   * the chord is not completed before the timeout, the first binding\n   * is executed.\n   */\n  addKeyBinding(options: CommandRegistry.IKeyBindingOptions): IDisposable {\n    // Create the binding for the given options.\n    let binding = Private.createKeyBinding(options);\n\n    // Add the key binding to the bindings array.\n    this._keyBindings.push(binding);\n\n    // Emit the `bindingChanged` signal.\n    this._keyBindingChanged.emit({ binding, type: 'added' });\n\n    // Return a disposable which will remove the binding.\n    return new DisposableDelegate(() => {\n      // Remove the binding from the array.\n      ArrayExt.removeFirstOf(this._keyBindings, binding);\n\n      // Emit the `bindingChanged` signal.\n      this._keyBindingChanged.emit({ binding, type: 'removed' });\n    });\n  }\n\n  /**\n   * Process a `'keydown'` event and invoke a matching key binding.\n   *\n   * @param event - The event object for a `'keydown'` event.\n   *\n   * #### Notes\n   * This should be called in response to a `'keydown'` event in order\n   * to invoke the command for the best matching key binding.\n   *\n   * The registry **does not** install its own listener for `'keydown'`\n   * events. This allows the application full control over the nodes\n   * and phase for which the registry processes `'keydown'` events.\n   *\n   * When the keydown event is processed, if the event target or any of its\n   * ancestor nodes has a `data-lm-suppress-shortcuts` attribute, its keydown\n   * events will not invoke commands.\n   */\n  processKeydownEvent(event: KeyboardEvent): void {\n    // Bail immediately if playing back keystrokes.\n    if (this._replaying || CommandRegistry.isModifierKeyPressed(event)) {\n      return;\n    }\n\n    // Get the normalized keystroke for the event.\n    let keystroke = CommandRegistry.keystrokeForKeydownEvent(event);\n\n    // If the keystroke is not valid for the keyboard layout, replay\n    // any suppressed events and clear the pending state.\n    if (!keystroke) {\n      this._replayKeydownEvents();\n      this._clearPendingState();\n      return;\n    }\n\n    // Add the keystroke to the current key sequence.\n    this._keystrokes.push(keystroke);\n\n    // Find the exact and partial matches for the key sequence.\n    let { exact, partial } = Private.matchKeyBinding(\n      this._keyBindings,\n      this._keystrokes,\n      event\n    );\n\n    // If there is no exact match and no partial match, replay\n    // any suppressed events and clear the pending state.\n    if (!exact && !partial) {\n      this._replayKeydownEvents();\n      this._clearPendingState();\n      return;\n    }\n\n    // Stop propagation of the event. If there is only a partial match,\n    // the event will be replayed if a final exact match never occurs.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // If there is an exact match but no partial match, the exact match\n    // can be dispatched immediately. The pending state is cleared so\n    // the next key press starts from the default state.\n    if (exact && !partial) {\n      this._executeKeyBinding(exact);\n      this._clearPendingState();\n      return;\n    }\n\n    // If there is both an exact match and a partial match, the exact\n    // match is stored for future dispatch in case the timer expires\n    // before a more specific match is triggered.\n    if (exact) {\n      this._exactKeyMatch = exact;\n    }\n\n    // Store the event for possible playback in the future.\n    this._keydownEvents.push(event);\n\n    // (Re)start the timer to dispatch the most recent exact match\n    // in case the partial match fails to result in an exact match.\n    this._startTimer();\n  }\n\n  /**\n   * Start or restart the pending timeout.\n   */\n  private _startTimer(): void {\n    this._clearTimer();\n    this._timerID = window.setTimeout(() => {\n      this._onPendingTimeout();\n    }, Private.CHORD_TIMEOUT);\n  }\n\n  /**\n   * Clear the pending timeout.\n   */\n  private _clearTimer(): void {\n    if (this._timerID !== 0) {\n      clearTimeout(this._timerID);\n      this._timerID = 0;\n    }\n  }\n\n  /**\n   * Replay the keydown events which were suppressed.\n   */\n  private _replayKeydownEvents(): void {\n    if (this._keydownEvents.length === 0) {\n      return;\n    }\n    this._replaying = true;\n    this._keydownEvents.forEach(Private.replayKeyEvent);\n    this._replaying = false;\n  }\n\n  /**\n   * Execute the command for the given key binding.\n   *\n   * If the command is missing or disabled, a warning will be logged.\n   */\n  private _executeKeyBinding(binding: CommandRegistry.IKeyBinding): void {\n    let { command, args } = binding;\n    if (!this.hasCommand(command) || !this.isEnabled(command, args)) {\n      let word = this.hasCommand(command) ? 'enabled' : 'registered';\n      let keys = binding.keys.join(', ');\n      let msg1 = `Cannot execute key binding '${keys}':`;\n      let msg2 = `command '${command}' is not ${word}.`;\n      console.warn(`${msg1} ${msg2}`);\n      return;\n    }\n    this.execute(command, args);\n  }\n\n  /**\n   * Clear the internal pending state.\n   */\n  private _clearPendingState(): void {\n    this._clearTimer();\n    this._exactKeyMatch = null;\n    this._keystrokes.length = 0;\n    this._keydownEvents.length = 0;\n  }\n\n  /**\n   * Handle the partial match timeout.\n   */\n  private _onPendingTimeout(): void {\n    this._timerID = 0;\n    if (this._exactKeyMatch) {\n      this._executeKeyBinding(this._exactKeyMatch);\n    } else {\n      this._replayKeydownEvents();\n    }\n    this._clearPendingState();\n  }\n\n  private _timerID = 0;\n  private _replaying = false;\n  private _keystrokes: string[] = [];\n  private _keydownEvents: KeyboardEvent[] = [];\n  private _keyBindings: CommandRegistry.IKeyBinding[] = [];\n  private _exactKeyMatch: CommandRegistry.IKeyBinding | null = null;\n  private _commands: { [id: string]: Private.ICommand } = Object.create(null);\n  private _commandChanged = new Signal<\n    this,\n    CommandRegistry.ICommandChangedArgs\n  >(this);\n  private _commandExecuted = new Signal<\n    this,\n    CommandRegistry.ICommandExecutedArgs\n  >(this);\n  private _keyBindingChanged = new Signal<\n    this,\n    CommandRegistry.IKeyBindingChangedArgs\n  >(this);\n}\n\n/**\n * The namespace for the `CommandRegistry` class statics.\n */\nexport namespace CommandRegistry {\n  /**\n   * A type alias for a user-defined command function.\n   */\n  export type CommandFunc<T> = (args: ReadonlyPartialJSONObject) => T;\n\n  /**\n   * A type alias for a simple immutable string dataset.\n   */\n  export type Dataset = { readonly [key: string]: string };\n\n  /**\n   * An options object for creating a command.\n   *\n   * #### Notes\n   * A command is an abstract representation of code to be executed along\n   * with metadata for describing how the command should be displayed in\n   * a visual representation.\n   *\n   * A command is a collection of functions, *not* methods. The command\n   * registry will always invoke the command functions with a `thisArg`\n   * which is `undefined`.\n   */\n  export interface ICommandOptions {\n    /**\n     * The function to invoke when the command is executed.\n     *\n     * #### Notes\n     * This should return the result of the command (if applicable) or\n     * a promise which yields the result. The result is resolved as a\n     * promise and that promise is returned to the code which executed\n     * the command.\n     *\n     * This may be invoked even when `isEnabled` returns `false`.\n     */\n    execute: CommandFunc<any | Promise<any>>;\n\n    /**\n     * JSON Schemas describing the command.\n     *\n     * #### Notes\n     * For now, the command arguments are the only one that can be\n     * described.\n     */\n    describedBy?: { args?: ReadonlyJSONObject };\n\n    /**\n     * The label for the command.\n     *\n     * #### Notes\n     * This can be a string literal, or a function which returns the\n     * label based on the provided command arguments.\n     *\n     * The label is often used as the primary text for the command.\n     *\n     * The default value is an empty string.\n     */\n    label?: string | CommandFunc<string>;\n\n    /**\n     * The index of the mnemonic character in the command's label.\n     *\n     * #### Notes\n     * This can be an index literal, or a function which returns the\n     * mnemonic index based on the provided command arguments.\n     *\n     * The mnemonic character is often used by menus to provide easy\n     * single-key keyboard access for triggering a menu item. It is\n     * typically rendered as an underlined character in the label.\n     *\n     * The default value is `-1`.\n     */\n    mnemonic?: number | CommandFunc<number>;\n\n    /**\n     * The icon renderer for the command.\n     *\n     * #### Notes\n     * This can be an IRenderer object, or a function which returns the\n     * renderer based on the provided command arguments.\n     *\n     * The default value is undefined.\n     *\n     * DEPRECATED: if set to a string value, the .icon field will function as\n     * an alias for the .iconClass field, for backwards compatibility\n     */\n    icon?:\n      | VirtualElement.IRenderer\n      | undefined\n      /* <DEPRECATED> */\n      | string /* </DEPRECATED> */\n      | CommandFunc<\n          | VirtualElement.IRenderer\n          | undefined\n          /* <DEPRECATED> */\n          | string /* </DEPRECATED> */\n        >;\n\n    /**\n     * The icon class for the command.\n     *\n     * #### Notes\n     * This class name will be added to the icon node for the visual\n     * representation of the command.\n     *\n     * Multiple class names can be separated with white space.\n     *\n     * This can be a string literal, or a function which returns the\n     * icon based on the provided command arguments.\n     *\n     * The default value is an empty string.\n     */\n    iconClass?: string | CommandFunc<string>;\n\n    /**\n     * The icon label for the command.\n     *\n     * #### Notes\n     * This label will be added as text to the icon node for the visual\n     * representation of the command.\n     *\n     * This can be a string literal, or a function which returns the\n     * label based on the provided command arguments.\n     *\n     * The default value is an empty string.\n     */\n    iconLabel?: string | CommandFunc<string>;\n\n    /**\n     * The caption for the command.\n     *\n     * #### Notes\n     * This should be a simple one line description of the command. It\n     * is used by some visual representations to show quick info about\n     * the command.\n     *\n     * This can be a string literal, or a function which returns the\n     * caption based on the provided command arguments.\n     *\n     * The default value is an empty string.\n     */\n    caption?: string | CommandFunc<string>;\n\n    /**\n     * The usage text for the command.\n     *\n     * #### Notes\n     * This should be a full description of the command, which includes\n     * information about the structure of the arguments and the type of\n     * the return value. It is used by some visual representations when\n     * displaying complete help info about the command.\n     *\n     * This can be a string literal, or a function which returns the\n     * usage text based on the provided command arguments.\n     *\n     * The default value is an empty string.\n     */\n    usage?: string | CommandFunc<string>;\n\n    /**\n     * The general class name for the command.\n     *\n     * #### Notes\n     * This class name will be added to the primary node for the visual\n     * representation of the command.\n     *\n     * Multiple class names can be separated with white space.\n     *\n     * This can be a string literal, or a function which returns the\n     * class name based on the provided command arguments.\n     *\n     * The default value is an empty string.\n     */\n    className?: string | CommandFunc<string>;\n\n    /**\n     * The dataset for the command.\n     *\n     * #### Notes\n     * The dataset values will be added to the primary node for the\n     * visual representation of the command.\n     *\n     * This can be a dataset object, or a function which returns the\n     * dataset object based on the provided command arguments.\n     *\n     * The default value is an empty dataset.\n     */\n    dataset?: Dataset | CommandFunc<Dataset>;\n\n    /**\n     * A function which indicates whether the command is enabled.\n     *\n     * #### Notes\n     * Visual representations may use this value to display a disabled\n     * command as grayed-out or in some other non-interactive fashion.\n     *\n     * The default value is `() => true`.\n     */\n    isEnabled?: CommandFunc<boolean>;\n\n    /**\n     * A function which indicates whether the command is toggled.\n     *\n     * #### Notes\n     * Visual representations may use this value to display a toggled\n     * command in a different form, such as a check mark icon for a\n     * menu item or a depressed state for a toggle button.\n     *\n     * The default value is `() => false`.\n     */\n    isToggled?: CommandFunc<boolean>;\n\n    /**\n     * A function which indicates whether the command is toggleable.\n     *\n     * #### Notes\n     * Visual representations may use this value to display a toggled command in\n     * a different form, such as a check box for a menu item or a depressed\n     * state for a toggle button. This attribute also allows for accessible\n     * interfaces to notify the user that the command corresponds to some state.\n     *\n     * The default value is `true` if an `isToggled` function is given, `false`\n     * otherwise.\n     */\n    isToggleable?: boolean;\n\n    /**\n     * A function which indicates whether the command is visible.\n     *\n     * #### Notes\n     * Visual representations may use this value to hide or otherwise\n     * not display a non-visible command.\n     *\n     * The default value is `() => true`.\n     */\n    isVisible?: CommandFunc<boolean>;\n  }\n\n  /**\n   * An arguments object for the `commandChanged` signal.\n   */\n  export interface ICommandChangedArgs {\n    /**\n     * The id of the associated command.\n     *\n     * This will be `undefined` when the type is `'many-changed'`.\n     */\n    readonly id: string | undefined;\n\n    /**\n     * Whether the command was added, removed, or changed.\n     */\n    readonly type: 'added' | 'removed' | 'changed' | 'many-changed';\n  }\n\n  /**\n   * An arguments object for the `commandExecuted` signal.\n   */\n  export interface ICommandExecutedArgs {\n    /**\n     * The id of the associated command.\n     */\n    readonly id: string;\n\n    /**\n     * The arguments object passed to the command.\n     */\n    readonly args: ReadonlyPartialJSONObject;\n\n    /**\n     * The promise which resolves with the result of the command.\n     */\n    readonly result: Promise<any>;\n  }\n\n  /**\n   * An options object for creating a key binding.\n   */\n  export interface IKeyBindingOptions {\n    /**\n     * The default key sequence for the key binding.\n     *\n     * A key sequence is composed of one or more keystrokes, where each\n     * keystroke is a combination of modifiers and a primary key.\n     *\n     * Most key sequences will contain a single keystroke. Key sequences\n     * with multiple keystrokes are called \"chords\", and are useful for\n     * implementing modal input (ala Vim).\n     *\n     * Each keystroke in the sequence should be of the form:\n     *   `[<modifier 1> [<modifier 2> [<modifier N> ]]]<primary key>`\n     *\n     * The supported modifiers are: `Accel`, `Alt`, `Cmd`, `Ctrl`, and\n     * `Shift`. The `Accel` modifier is translated to `Cmd` on Mac and\n     * `Ctrl` on all other platforms. The `Cmd` modifier is ignored on\n     * non-Mac platforms.\n     *\n     * Keystrokes are case sensitive.\n     *\n     * **Examples:** `['Accel C']`, `['Shift F11']`, `['D', 'D']`\n     */\n    keys: string[];\n\n    /**\n     * The CSS selector for the key binding.\n     *\n     * The key binding will only be invoked when the selector matches a\n     * node on the propagation path of the keydown event. This allows\n     * the key binding to be restricted to user-defined contexts.\n     *\n     * The selector must not contain commas.\n     */\n    selector: string;\n\n    /**\n     * The id of the command to execute when the binding is matched.\n     */\n    command: string;\n\n    /**\n     * The arguments for the command, if necessary.\n     *\n     * The default value is an empty object.\n     */\n    args?: ReadonlyPartialJSONObject;\n\n    /**\n     * The key sequence to use when running on Windows.\n     *\n     * If provided, this will override `keys` on Windows platforms.\n     */\n    winKeys?: string[];\n\n    /**\n     * The key sequence to use when running on Mac.\n     *\n     * If provided, this will override `keys` on Mac platforms.\n     */\n    macKeys?: string[];\n\n    /**\n     * The key sequence to use when running on Linux.\n     *\n     * If provided, this will override `keys` on Linux platforms.\n     */\n    linuxKeys?: string[];\n  }\n\n  /**\n   * An object which represents a key binding.\n   *\n   * #### Notes\n   * A key binding is an immutable object created by a registry.\n   */\n  export interface IKeyBinding {\n    /**\n     * The key sequence for the binding.\n     */\n    readonly keys: ReadonlyArray<string>;\n\n    /**\n     * The CSS selector for the binding.\n     */\n    readonly selector: string;\n\n    /**\n     * The command executed when the binding is matched.\n     */\n    readonly command: string;\n\n    /**\n     * The arguments for the command.\n     */\n    readonly args: ReadonlyPartialJSONObject;\n  }\n\n  /**\n   * An arguments object for the `keyBindingChanged` signal.\n   */\n  export interface IKeyBindingChangedArgs {\n    /**\n     * The key binding which was changed.\n     */\n    readonly binding: IKeyBinding;\n\n    /**\n     * Whether the key binding was added or removed.\n     */\n    readonly type: 'added' | 'removed';\n  }\n\n  /**\n   * An object which holds the results of parsing a keystroke.\n   */\n  export interface IKeystrokeParts {\n    /**\n     * Whether `'Cmd'` appears in the keystroke.\n     */\n    cmd: boolean;\n\n    /**\n     * Whether `'Ctrl'` appears in the keystroke.\n     */\n    ctrl: boolean;\n\n    /**\n     * Whether `'Alt'` appears in the keystroke.\n     */\n    alt: boolean;\n\n    /**\n     * Whether `'Shift'` appears in the keystroke.\n     */\n    shift: boolean;\n\n    /**\n     * The primary key for the keystroke.\n     */\n    key: string;\n  }\n\n  /**\n   * Parse a keystroke into its constituent components.\n   *\n   * @param keystroke - The keystroke of interest.\n   *\n   * @returns The parsed components of the keystroke.\n   *\n   * #### Notes\n   * The keystroke should be of the form:\n   *   `[<modifier 1> [<modifier 2> [<modifier N> ]]]<primary key>`\n   *\n   * The supported modifiers are: `Accel`, `Alt`, `Cmd`, `Ctrl`, and\n   * `Shift`. The `Accel` modifier is translated to `Cmd` on Mac and\n   * `Ctrl` on all other platforms.\n   *\n   * The parsing is tolerant and will not throw exceptions. Notably:\n   *   - Duplicate modifiers are ignored.\n   *   - Extra primary keys are ignored.\n   *   - The order of modifiers and primary key is irrelevant.\n   *   - The keystroke parts should be separated by whitespace.\n   *   - The keystroke is case sensitive.\n   */\n  export function parseKeystroke(keystroke: string): IKeystrokeParts {\n    let key = '';\n    let alt = false;\n    let cmd = false;\n    let ctrl = false;\n    let shift = false;\n    for (let token of keystroke.split(/\\s+/)) {\n      if (token === 'Accel') {\n        if (Platform.IS_MAC) {\n          cmd = true;\n        } else {\n          ctrl = true;\n        }\n      } else if (token === 'Alt') {\n        alt = true;\n      } else if (token === 'Cmd') {\n        cmd = true;\n      } else if (token === 'Ctrl') {\n        ctrl = true;\n      } else if (token === 'Shift') {\n        shift = true;\n      } else if (token.length > 0) {\n        key = token;\n      }\n    }\n    return { cmd, ctrl, alt, shift, key };\n  }\n\n  /**\n   * Normalize a keystroke into a canonical representation.\n   *\n   * @param keystroke - The keystroke of interest.\n   *\n   * @returns The normalized representation of the keystroke.\n   *\n   * #### Notes\n   * This normalizes the keystroke by removing duplicate modifiers and\n   * extra primary keys, and assembling the parts in a canonical order.\n   *\n   * The `Cmd` modifier is ignored on non-Mac platforms.\n   */\n  export function normalizeKeystroke(keystroke: string): string {\n    let mods = '';\n    let parts = parseKeystroke(keystroke);\n    if (parts.ctrl) {\n      mods += 'Ctrl ';\n    }\n    if (parts.alt) {\n      mods += 'Alt ';\n    }\n    if (parts.shift) {\n      mods += 'Shift ';\n    }\n    if (parts.cmd && Platform.IS_MAC) {\n      mods += 'Cmd ';\n    }\n    return mods + parts.key;\n  }\n\n  /**\n   * Get the platform-specific normalized keys for an options object.\n   *\n   * @param options - The options for the key binding.\n   *\n   * @returns Array of combined, normalized keys.\n   */\n  export function normalizeKeys(options: IKeyBindingOptions): string[] {\n    let keys: string[];\n    if (Platform.IS_WIN) {\n      keys = options.winKeys || options.keys;\n    } else if (Platform.IS_MAC) {\n      keys = options.macKeys || options.keys;\n    } else {\n      keys = options.linuxKeys || options.keys;\n    }\n    return keys.map(normalizeKeystroke);\n  }\n\n  /**\n   * Format keystrokes for display on the local system.\n   *\n   * If a list of keystrokes is provided, it will be displayed as\n   * a comma-separated string\n   *\n   * @param keystroke The keystrokes to format\n   * @returns The keystrokes representation\n   */\n  export function formatKeystroke(\n    keystroke: string | readonly string[]\n  ): string {\n    return typeof keystroke === 'string'\n      ? formatSingleKey(keystroke)\n      : keystroke.map(formatSingleKey).join(', ');\n\n    function formatSingleKey(key: string) {\n      let mods = [];\n      let separator = Platform.IS_MAC ? ' ' : '+';\n      let parts = parseKeystroke(key);\n      if (parts.ctrl) {\n        mods.push('Ctrl');\n      }\n      if (parts.alt) {\n        mods.push('Alt');\n      }\n      if (parts.shift) {\n        mods.push('Shift');\n      }\n      if (Platform.IS_MAC && parts.cmd) {\n        mods.push('Cmd');\n      }\n      mods.push(parts.key);\n      return mods.map(Private.formatKey).join(separator);\n    }\n  }\n\n  /**\n   * Check if `'keydown'` event is caused by pressing a modifier key that should be ignored.\n   *\n   * @param event - The event object for a `'keydown'` event.\n   *\n   * @returns `true` if modifier key was pressed, `false` otherwise.\n   */\n  export function isModifierKeyPressed(event: KeyboardEvent): boolean {\n    let layout = getKeyboardLayout();\n    let key = layout.keyForKeydownEvent(event);\n    return layout.isModifierKey(key);\n  }\n\n  /**\n   * Create a normalized keystroke for a `'keydown'` event.\n   *\n   * @param event - The event object for a `'keydown'` event.\n   *\n   * @returns A normalized keystroke, or an empty string if the event\n   *   does not represent a valid keystroke for the given layout.\n   */\n  export function keystrokeForKeydownEvent(event: KeyboardEvent): string {\n    let layout = getKeyboardLayout();\n    let key = layout.keyForKeydownEvent(event);\n    if (!key || layout.isModifierKey(key)) {\n      return '';\n    }\n    let mods = [];\n    if (event.ctrlKey) {\n      mods.push('Ctrl');\n    }\n    if (event.altKey) {\n      mods.push('Alt');\n    }\n    if (event.shiftKey) {\n      mods.push('Shift');\n    }\n    if (event.metaKey && Platform.IS_MAC) {\n      mods.push('Cmd');\n    }\n    mods.push(key);\n    return mods.join(' ');\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * The timeout in ms for triggering a key binding chord.\n   */\n  export const CHORD_TIMEOUT = 1000;\n\n  /**\n   * A convenience type alias for a command func.\n   */\n  export type CommandFunc<T> = CommandRegistry.CommandFunc<T>;\n\n  /**\n   * A convenience type alias for a command dataset.\n   */\n  export type Dataset = CommandRegistry.Dataset;\n\n  /**\n   * A normalized command object.\n   */\n  export interface ICommand {\n    readonly execute: CommandFunc<any>;\n    readonly describedBy: { args: ReadonlyJSONObject | null };\n    readonly label: CommandFunc<string>;\n    readonly mnemonic: CommandFunc<number>;\n\n    readonly icon: CommandFunc<\n      | VirtualElement.IRenderer\n      | undefined\n      /* <DEPRECATED> */\n      | string /* </DEPRECATED> */\n    >;\n\n    readonly iconClass: CommandFunc<string>;\n    readonly iconLabel: CommandFunc<string>;\n    readonly caption: CommandFunc<string>;\n    readonly usage: CommandFunc<string>;\n    readonly className: CommandFunc<string>;\n    readonly dataset: CommandFunc<Dataset>;\n    readonly isEnabled: CommandFunc<boolean>;\n    readonly isToggled: CommandFunc<boolean>;\n    readonly isToggleable: boolean;\n    readonly isVisible: CommandFunc<boolean>;\n  }\n\n  /**\n   * Create a normalized command from an options object.\n   */\n  export function createCommand(\n    options: CommandRegistry.ICommandOptions\n  ): ICommand {\n    let icon;\n    let iconClass;\n\n    /* <DEPRECATED> */\n    if (!options.icon || typeof options.icon === 'string') {\n      // alias icon to iconClass\n      iconClass = asFunc(options.iconClass || options.icon, emptyStringFunc);\n      icon = iconClass;\n    } else {\n      /* /<DEPRECATED> */\n\n      iconClass = asFunc(options.iconClass, emptyStringFunc);\n      icon = asFunc(options.icon, undefinedFunc);\n\n      /* <DEPRECATED> */\n    }\n    /* </DEPRECATED> */\n\n    return {\n      execute: options.execute,\n      describedBy: { args: null, ...options.describedBy },\n      label: asFunc(options.label, emptyStringFunc),\n      mnemonic: asFunc(options.mnemonic, negativeOneFunc),\n      icon,\n      iconClass,\n      iconLabel: asFunc(options.iconLabel, emptyStringFunc),\n      caption: asFunc(options.caption, emptyStringFunc),\n      usage: asFunc(options.usage, emptyStringFunc),\n      className: asFunc(options.className, emptyStringFunc),\n      dataset: asFunc(options.dataset, emptyDatasetFunc),\n      isEnabled: options.isEnabled || trueFunc,\n      isToggled: options.isToggled || falseFunc,\n      isToggleable: options.isToggleable || !!options.isToggled,\n      isVisible: options.isVisible || trueFunc\n    };\n  }\n\n  /**\n   * Create a key binding object from key binding options.\n   */\n  export function createKeyBinding(\n    options: CommandRegistry.IKeyBindingOptions\n  ): CommandRegistry.IKeyBinding {\n    return {\n      keys: CommandRegistry.normalizeKeys(options),\n      selector: validateSelector(options),\n      command: options.command,\n      args: options.args || JSONExt.emptyObject\n    };\n  }\n\n  /**\n   * An object which holds the results of a key binding match.\n   */\n  export interface IMatchResult {\n    /**\n     * The best key binding which exactly matches the key sequence.\n     */\n    exact: CommandRegistry.IKeyBinding | null;\n\n    /**\n     * Whether there are bindings which partially match the sequence.\n     */\n    partial: boolean;\n  }\n\n  /**\n   * Find the key bindings which match a key sequence.\n   *\n   * This returns a match result which contains the best exact matching\n   * binding, and a flag which indicates if there are partial matches.\n   */\n  export function matchKeyBinding(\n    bindings: ReadonlyArray<CommandRegistry.IKeyBinding>,\n    keys: ReadonlyArray<string>,\n    event: KeyboardEvent\n  ): IMatchResult {\n    // The current best exact match.\n    let exact: CommandRegistry.IKeyBinding | null = null;\n\n    // Whether a partial match has been found.\n    let partial = false;\n\n    // The match distance for the exact match.\n    let distance = Infinity;\n\n    // The specificity for the exact match.\n    let specificity = 0;\n\n    // Iterate over the bindings and search for the best match.\n    for (let i = 0, n = bindings.length; i < n; ++i) {\n      // Lookup the current binding.\n      let binding = bindings[i];\n\n      // Check whether the key binding sequence is a match.\n      let sqm = matchSequence(binding.keys, keys);\n\n      // If there is no match, the binding is ignored.\n      if (sqm === SequenceMatch.None) {\n        continue;\n      }\n\n      // If it is a partial match and no other partial match has been\n      // found, ensure the selector matches and set the partial flag.\n      if (sqm === SequenceMatch.Partial) {\n        if (!partial && targetDistance(binding.selector, event) !== -1) {\n          partial = true;\n        }\n        continue;\n      }\n\n      // Ignore the match if the selector doesn't match, or if the\n      // matched node is farther away than the current best match.\n      let td = targetDistance(binding.selector, event);\n      if (td === -1 || td > distance) {\n        continue;\n      }\n\n      // Get the specificity for the selector.\n      let sp = Selector.calculateSpecificity(binding.selector);\n\n      // Update the best match if this match is stronger.\n      if (!exact || td < distance || sp >= specificity) {\n        exact = binding;\n        distance = td;\n        specificity = sp;\n      }\n    }\n\n    // Return the match result.\n    return { exact, partial };\n  }\n\n  /**\n   * Replay a keyboard event.\n   *\n   * This synthetically dispatches a clone of the keyboard event.\n   */\n  export function replayKeyEvent(event: KeyboardEvent): void {\n    event.target!.dispatchEvent(cloneKeyboardEvent(event));\n  }\n\n  export function formatKey(key: string): string {\n    if (Platform.IS_MAC) {\n      return MAC_DISPLAY.hasOwnProperty(key) ? MAC_DISPLAY[key] : key;\n    } else {\n      return WIN_DISPLAY.hasOwnProperty(key) ? WIN_DISPLAY[key] : key;\n    }\n  }\n\n  const MAC_DISPLAY: { [key: string]: string } = {\n    Backspace: '⌫',\n    Tab: '⇥',\n    Enter: '↩',\n    Shift: '⇧',\n    Ctrl: '⌃',\n    Alt: '⌥',\n    Escape: '⎋',\n    PageUp: '⇞',\n    PageDown: '⇟',\n    End: '↘',\n    Home: '↖',\n    ArrowLeft: '←',\n    ArrowUp: '↑',\n    ArrowRight: '→',\n    ArrowDown: '↓',\n    Delete: '⌦',\n    Cmd: '⌘'\n  };\n\n  const WIN_DISPLAY: { [key: string]: string } = {\n    Escape: 'Esc',\n    PageUp: 'Page Up',\n    PageDown: 'Page Down',\n    ArrowLeft: 'Left',\n    ArrowUp: 'Up',\n    ArrowRight: 'Right',\n    ArrowDown: 'Down',\n    Delete: 'Del'\n  };\n\n  /**\n   * A singleton empty string function.\n   */\n  const emptyStringFunc = () => '';\n\n  /**\n   * A singleton `-1` number function\n   */\n  const negativeOneFunc = () => -1;\n\n  /**\n   * A singleton true boolean function.\n   */\n  const trueFunc = () => true;\n\n  /**\n   * A singleton false boolean function.\n   */\n  const falseFunc = () => false;\n\n  /**\n   * A singleton empty dataset function.\n   */\n  const emptyDatasetFunc = () => ({});\n\n  /**\n   * A singleton undefined function\n   */\n  const undefinedFunc = () => undefined;\n\n  /**\n   * Cast a value or command func to a command func.\n   */\n  function asFunc<T>(\n    value: undefined | T | CommandFunc<T>,\n    dfault: CommandFunc<T>\n  ): CommandFunc<T> {\n    if (value === undefined) {\n      return dfault;\n    }\n    if (typeof value === 'function') {\n      return value as CommandFunc<T>;\n    }\n    return () => value;\n  }\n\n  /**\n   * Validate the selector for an options object.\n   *\n   * This returns the validated selector, or throws if the selector is\n   * invalid or contains commas.\n   */\n  function validateSelector(\n    options: CommandRegistry.IKeyBindingOptions\n  ): string {\n    if (options.selector.indexOf(',') !== -1) {\n      throw new Error(`Selector cannot contain commas: ${options.selector}`);\n    }\n    if (!Selector.isValid(options.selector)) {\n      throw new Error(`Invalid selector: ${options.selector}`);\n    }\n    return options.selector;\n  }\n\n  /**\n   * An enum which describes the possible sequence matches.\n   */\n  const enum SequenceMatch {\n    None,\n    Exact,\n    Partial\n  }\n\n  /**\n   * Test whether a key binding sequence matches a key sequence.\n   *\n   * Returns a `SequenceMatch` value indicating the type of match.\n   */\n  function matchSequence(\n    bindKeys: ReadonlyArray<string>,\n    userKeys: ReadonlyArray<string>\n  ): SequenceMatch {\n    if (bindKeys.length < userKeys.length) {\n      return SequenceMatch.None;\n    }\n    for (let i = 0, n = userKeys.length; i < n; ++i) {\n      if (bindKeys[i] !== userKeys[i]) {\n        return SequenceMatch.None;\n      }\n    }\n    if (bindKeys.length > userKeys.length) {\n      return SequenceMatch.Partial;\n    }\n    return SequenceMatch.Exact;\n  }\n\n  /**\n   * Find the distance from the target node to the first matching node.\n   *\n   * This traverses the event path from `target` to `currentTarget` and\n   * computes the distance from `target` to the first node which matches\n   * the CSS selector. If no match is found, `-1` is returned.\n   */\n  function targetDistance(selector: string, event: KeyboardEvent): number {\n    let targ = event.target as Element | null;\n    let curr = event.currentTarget as Element | null;\n    for (let dist = 0; targ !== null; targ = targ.parentElement, ++dist) {\n      if (targ.hasAttribute('data-lm-suppress-shortcuts')) {\n        return -1;\n      }\n      /* <DEPRECATED> */\n      if (targ.hasAttribute('data-p-suppress-shortcuts')) {\n        return -1;\n      }\n      /* </DEPRECATED> */\n      if (Selector.matches(targ, selector)) {\n        return dist;\n      }\n      if (targ === curr) {\n        return -1;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Clone a keyboard event.\n   */\n  function cloneKeyboardEvent(event: KeyboardEvent): KeyboardEvent {\n    // A custom event is required because Chrome nulls out the\n    // `keyCode` field in user-generated `KeyboardEvent` types.\n    let clone = document.createEvent('Event') as any;\n    let bubbles = event.bubbles || true;\n    let cancelable = event.cancelable || true;\n    clone.initEvent(event.type || 'keydown', bubbles, cancelable);\n    clone.key = event.key || '';\n    clone.keyCode = event.keyCode || 0;\n    clone.which = event.keyCode || 0;\n    clone.ctrlKey = event.ctrlKey || false;\n    clone.altKey = event.altKey || false;\n    clone.shiftKey = event.shiftKey || false;\n    clone.metaKey = event.metaKey || false;\n    clone.view = event.view || window;\n    return clone as KeyboardEvent;\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || from);\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n"],"names":["Private","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","_timerID","_replaying","_keystrokes","_keydownEvents","_keyBindings","_exactKeyMatch","_commands","create","_commandChanged","Signal","_commandExecuted","_keyBindingChanged","listCommands","keys","hasCommand","id","addCommand","options","Error","createCommand","emit","type","DisposableDelegate","notifyCommandChanged","undefined","describedBy","cmd","args","label","JSONExt","mnemonic","icon","iconClass","iconLabel","caption","usage","className","dataset","isEnabled","isToggled","isToggleable","isVisible","execute","value","Promise","reject","err","result","resolve","addKeyBinding","binding","createKeyBinding","push","ArrayExt","processKeydownEvent","event","CommandRegistry","isModifierKeyPressed","keystroke","keystrokeForKeydownEvent","_replayKeydownEvents","_clearPendingState","exact","partial","preventDefault","stopPropagation","_executeKeyBinding","_startTimer","_clearTimer","window","setTimeout","_onPendingTimeout","CHORD_TIMEOUT","clearTimeout","forEach","replayKeyEvent","command","word","msg1","join","msg2","console","warn","parseKeystroke","key","alt","ctrl","shift","split","token","Platform","normalizeKeystroke","mods","parts","normalizeKeys","winKeys","macKeys","linuxKeys","map","formatKeystroke","formatSingleKey","separator","formatKey","layout","getKeyboardLayout","keyForKeydownEvent","isModifierKey","ctrlKey","altKey","shiftKey","metaKey","asFunc","emptyStringFunc","undefinedFunc","negativeOneFunc","emptyDatasetFunc","trueFunc","falseFunc","selector","validateSelector","matchKeyBinding","bindings","distance","Infinity","specificity","sqm","matchSequence","td","targetDistance","sp","Selector","target","dispatchEvent","clone","document","createEvent","bubbles","cancelable","initEvent","keyCode","which","view","cloneKeyboardEvent","MAC_DISPLAY","WIN_DISPLAY","Backspace","Tab","Enter","Shift","Ctrl","Alt","Escape","PageUp","PageDown","End","Home","ArrowLeft","ArrowUp","ArrowRight","ArrowDown","Delete","Cmd","dfault","indexOf","bindKeys","userKeys","targ","curr","currentTarget","dist","parentElement","hasAttribute"],"sourceRoot":""}