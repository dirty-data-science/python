{"version":3,"file":"555.2cd31dd.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/settings/src/settings.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/settings/src/tokens.ts"],"sourcesContent":["import { PageConfig, URLExt } from '@jupyterlab/coreutils';\n\nimport * as json5 from 'json5';\n\nimport type localforage from 'localforage';\n\nimport { IFederatedExtension } from '@jupyterlite/types';\n\nimport { IPlugin, ISettings } from './tokens';\nimport { PromiseDelegate } from '@lumino/coreutils';\n\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n\n/**\n * A class to handle requests to /api/settings\n */\nexport class Settings implements ISettings {\n  constructor(options: Settings.IOptions) {\n    this._localforage = options.localforage;\n    this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n    this._storageDrivers = options.storageDrivers || null;\n\n    this._ready = new PromiseDelegate();\n  }\n\n  /**\n   * A promise that resolves when the settings storage is fully initialized\n   */\n  get ready(): Promise<void> {\n    return this._ready.promise;\n  }\n\n  /**\n   * A lazy reference to initialized storage\n   */\n  protected get storage(): Promise<LocalForage> {\n    return this.ready.then(() => this._storage as LocalForage);\n  }\n\n  /**\n   * Finish any initialization after server has started and all extensions are applied.\n   */\n  async initialize() {\n    await this.initStorage();\n    this._ready.resolve(void 0);\n  }\n\n  /**\n   * Prepare the storage\n   */\n  protected async initStorage() {\n    this._storage = this.defaultSettingsStorage();\n  }\n\n  /**\n   * Get default options for localForage instances\n   */\n  protected get defaultStorageOptions(): LocalForageOptions {\n    const driver = this._storageDrivers?.length ? this._storageDrivers : null;\n    return {\n      version: 1,\n      name: this._storageName,\n      ...(driver ? { driver } : {}),\n    };\n  }\n\n  /**\n   * Create a settings store.\n   */\n  protected defaultSettingsStorage(): LocalForage {\n    return this._localforage.createInstance({\n      description: 'Offline Storage for Settings',\n      storeName: 'settings',\n      ...this.defaultStorageOptions,\n    });\n  }\n\n  /**\n   * Get settings by plugin id\n   *\n   * @param pluginId the id of the plugin\n   *\n   */\n  async get(pluginId: string): Promise<IPlugin | undefined> {\n    const all = await this.getAll();\n    const settings = all.settings as IPlugin[];\n    let found = settings.find((setting: IPlugin) => {\n      return setting.id === pluginId;\n    });\n\n    if (!found) {\n      found = await this._getFederated(pluginId);\n    }\n\n    return found;\n  }\n\n  /**\n   * Get all the settings\n   */\n  async getAll(): Promise<{ settings: IPlugin[] }> {\n    const settingsUrl = PageConfig.getOption('settingsUrl') ?? '/';\n    const storage = await this.storage;\n    const all = (await (\n      await fetch(URLExt.join(settingsUrl, 'all.json'))\n    ).json()) as IPlugin[];\n    const settings = await Promise.all(\n      all.map(async (plugin) => {\n        const { id } = plugin;\n        const raw = ((await storage.getItem(id)) as string) ?? plugin.raw;\n        return {\n          ...Private.override(plugin),\n          raw,\n          settings: json5.parse(raw),\n        };\n      })\n    );\n    return { settings };\n  }\n\n  /**\n   * Save settings for a given plugin id\n   *\n   * @param pluginId The id of the plugin\n   * @param raw The raw settings\n   *\n   */\n  async save(pluginId: string, raw: string): Promise<void> {\n    await (await this.storage).setItem(pluginId, raw);\n  }\n\n  /**\n   * Get the settings for a federated extension\n   *\n   * @param pluginId The id of a plugin\n   */\n  private async _getFederated(pluginId: string): Promise<IPlugin | undefined> {\n    const [packageName, schemaName] = pluginId.split(':');\n\n    if (!Private.isFederated(packageName)) {\n      return;\n    }\n\n    const labExtensionsUrl = PageConfig.getOption('fullLabextensionsUrl');\n    const schemaUrl = URLExt.join(\n      labExtensionsUrl,\n      packageName,\n      'schemas',\n      packageName,\n      `${schemaName}.json`\n    );\n    const packageUrl = URLExt.join(labExtensionsUrl, packageName, 'package.json');\n    const schema = await (await fetch(schemaUrl)).json();\n    const packageJson = await (await fetch(packageUrl)).json();\n    const raw = ((await (await this.storage).getItem(pluginId)) as string) ?? '{}';\n    const settings = json5.parse(raw) || {};\n    return Private.override({\n      id: pluginId,\n      raw,\n      schema,\n      settings,\n      version: packageJson.version || '3.0.8',\n    });\n  }\n\n  private _storageName: string = DEFAULT_STORAGE_NAME;\n  private _storageDrivers: string[] | null = null;\n  private _storage: LocalForage | undefined;\n  private _localforage: typeof localforage;\n  private _ready: PromiseDelegate<void>;\n}\n\n/**\n * A namespace for settings metadata.\n */\nexport namespace Settings {\n  /**\n   * Initialization options for settings.\n   */\n  export interface IOptions {\n    localforage: typeof localforage;\n    storageName?: string | null;\n    storageDrivers?: string[] | null;\n  }\n}\n\n/**\n * A namespace for private data\n */\nnamespace Private {\n  const _overrides: Record<string, IPlugin['schema']['default']> = JSON.parse(\n    PageConfig.getOption('settingsOverrides') || '{}'\n  );\n\n  /**\n   * Test whether this package is configured in `federated_extensions` in this app\n   *\n   * @param packageName The npm name of a package\n   */\n  export function isFederated(packageName: string): boolean {\n    let federated: IFederatedExtension[];\n\n    try {\n      federated = JSON.parse(PageConfig.getOption('federated_extensions'));\n    } catch {\n      return false;\n    }\n\n    for (const { name } of federated) {\n      if (name === packageName) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Override the defaults of the schema with ones from PageConfig\n   *\n   * @see https://github.com/jupyterlab/jupyterlab_server/blob/v2.5.2/jupyterlab_server/settings_handler.py#L216-L227\n   */\n  export function override(plugin: IPlugin): IPlugin {\n    if (_overrides[plugin.id]) {\n      if (!plugin.schema.properties) {\n        // probably malformed, or only provides keyboard shortcuts, etc.\n        plugin.schema.properties = {};\n      }\n      for (const [prop, propDefault] of Object.entries(_overrides[plugin.id] || {})) {\n        plugin.schema.properties[prop].default = propDefault;\n      }\n    }\n    return plugin;\n  }\n}\n","import { ISettingRegistry } from '@jupyterlab/settingregistry';\n\nimport { JSONObject, PartialJSONObject, Token } from '@lumino/coreutils';\n\n/**\n * The token for the settings service.\n */\nexport const ISettings = new Token<ISettings>('@jupyterlite/settings:ISettings');\n\n/**\n * An interface for the plugin settings.\n */\nexport interface IPlugin extends PartialJSONObject {\n  /**\n   * The name of the plugin.\n   */\n  id: string;\n\n  /**\n   * The settings for the plugin.\n   */\n  settings: JSONObject;\n\n  /**\n   * The raw user settings data as a string containing JSON with comments.\n   */\n  raw: string;\n\n  /**\n   * The JSON schema for the plugin.\n   */\n  schema: ISettingRegistry.ISchema;\n\n  /**\n   * The published version of the NPM package containing the plugin.\n   */\n  version: string;\n}\n\n/**\n * The interface for the Settings service.\n */\nexport interface ISettings {\n  /**\n   * A promise that resolves after the settings have been full initialized\n   */\n  ready: Promise<void>;\n\n  /**\n   * Get settings by plugin id\n   *\n   * @param pluginId the id of the plugin\n   *\n   */\n  get(pluginId: string): Promise<IPlugin | undefined>;\n\n  /**\n   * Get all the settings\n   */\n  getAll(): Promise<{ settings: IPlugin[] }>;\n\n  /**\n   * Save settings for a given plugin id\n   *\n   * @param pluginId The id of the plugin\n   * @param raw The raw settings\n   *\n   */\n  save(pluginId: string, raw: string): Promise<void>;\n}\n"],"names":["DEFAULT_STORAGE_NAME","Settings","constructor","options","_storageName","_storageDrivers","this","_localforage","localforage","storageName","storageDrivers","_ready","PromiseDelegate","ready","promise","storage","then","_storage","async","initStorage","resolve","defaultSettingsStorage","defaultStorageOptions","driver","length","version","name","createInstance","description","storeName","pluginId","found","getAll","settings","find","setting","id","_getFederated","settingsUrl","PageConfig","all","fetch","URLExt","json","Promise","map","plugin","raw","getItem","Private","override","setItem","packageName","schemaName","split","isFederated","labExtensionsUrl","schemaUrl","packageUrl","schema","packageJson","_overrides","JSON","parse","federated","properties","prop","propDefault","Object","entries","default","ISettings","Token"],"sourceRoot":""}