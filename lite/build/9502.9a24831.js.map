{"version":3,"file":"9502.9a24831.js","mappings":"4OASO,MAAMA,EAAuB,4BAKvBC,EAAY,IAAI,EAAAC,MAAiB,mCCIxCC,EAA+BC,OAAOC,OAAO,CAAEC,SAAU,KAKxD,MAAMC,EAIXC,YACE,MAAO,CACLC,QAAS,UACGC,KAAKC,gBACf,CAACD,KAAKE,eAAgBF,KAAKG,mBAGjC,CAKcD,cACZ,OAAO,EAAAE,WAAA,UAAqB,YAAc,aAC5C,CAKcC,qBACZ,OAAO,EAAAC,OAAA,KAAY,EAAAF,WAAA,aAAyB,QAASd,EACvD,CAKciB,uBACZ,OAAO,EAAAH,WAAA,UAAqB,uBAC9B,CAKAN,wBACE,IAAIU,EAASf,EAEb,IAEEe,SADuBC,MAAMT,KAAKK,iBAChBK,M,CAClB,MAAOC,GACPC,QAAQC,KAAK,iCAAkCb,KAAKE,Q,CAGtD,OAAOM,CACT,CAKAV,sBACE,MAAMC,EAA2B,CAAC,EAClC,IAAIe,EAEJ,IACEA,EAAYC,KAAKC,MAAM,EAAAZ,WAAA,UAAqB,wB,CAC5C,MACA,OAAOL,C,CAGT,MAAMkB,EAAW,GAEjB,IAAK,MAAMC,KAAOJ,EAChBG,EAASE,KAAKnB,KAAKoB,iBAAiBF,EAAKnB,IAG3C,UACQsB,QAAQC,IAAIL,E,CAClB,MAAON,GACPC,QAAQC,KAAK,2BAA4BF,E,CAG3C,OAAOZ,CACT,CAKAD,uBAAuBoB,EAA0BnB,GAC/C,IACE,MAAMwB,EAAM,EAAAjB,OAAA,KACVN,KAAKO,iBACLW,EAAIM,KACJ,SACAlC,GAEImC,QAAiBhB,MAAMc,GAC7BxB,EAAQmB,EAAIM,YAAcC,EAASf,M,CACnC,MACAE,QAAQC,KAAK,iCAAkCK,GAC/CnB,EAAQmB,EAAIM,MAAQ/B,C,CAExB,E","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/licenses/src/tokens.ts","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/licenses/src/licenses.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { ReadonlyJSONObject, Token } from '@lumino/coreutils';\n\n/**\n * The well-known name of the file. Can actually be configured by alternate\n * implementations, but the default is probably good enough for \"best-effort.\"\n */\nexport const THIRD_PARTY_LICENSES = 'third-party-licenses.json';\n\n/**\n * The token for the licenses service.\n */\nexport const ILicenses = new Token<ILicenses>('@jupyterlite/licenses:ILicenses');\n\n/**\n * The interface for the Settings service.\n */\nexport interface ILicenses {\n  /**\n   * Get licenses\n   *\n   */\n  get(): Promise<ILicenseResponse | undefined>;\n}\n\n/**\n * A named bundle of licenses\n */\nexport interface ILicenseBundles {\n  [key: string]: ILicenseBundle;\n}\n\n/**\n * The JSON response from the API\n */\nexport interface ILicenseResponse {\n  bundles: ILicenseBundles;\n}\n\n/**\n * A top-level report of the licenses for all code included in a bundle\n *\n * Note\n *\n * This is roughly informed by the terms defined in the SPDX spec, though is not\n * an SPDX Document, since there seem to be several (incompatible) specs\n * in that repo.\n *\n * @see https://github.com/spdx/spdx-spec/blob/development/v2.2.1/schemas/spdx-schema.json\n **/\nexport interface ILicenseBundle extends ReadonlyJSONObject {\n  packages: IPackageLicenseInfo[];\n}\n\n/**\n * A best-effort single bundled package's information.\n *\n * Note\n *\n * This is roughly informed by SPDX `packages` and `hasExtractedLicenseInfos`,\n * as making it conformant would vastly complicate the structure.\n *\n * @see https://github.com/spdx/spdx-spec/blob/development/v2.2.1/schemas/spdx-schema.json\n **/\nexport interface IPackageLicenseInfo extends ReadonlyJSONObject {\n  /**\n   * the name of the package as it appears in package.json\n   */\n  name: string;\n  /**\n   * the version of the package, or an empty string if unknown\n   */\n  versionInfo: string;\n  /**\n   * an SPDX license identifier or LicenseRef, or an empty string if unknown\n   */\n  licenseId: string;\n  /**\n   * the verbatim extracted text of the license, or an empty string if unknown\n   */\n  extractedText: string;\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport { URLExt, PageConfig } from '@jupyterlab/coreutils';\n\nimport { IFederatedExtension } from '@jupyterlite/types';\n\nimport {\n  ILicenseBundle,\n  ILicenseBundles,\n  ILicenseResponse,\n  ILicenses,\n  THIRD_PARTY_LICENSES,\n} from './tokens';\n\n/**\n * An empty bundle.\n */\nconst EMPTY_BUNDLE: ILicenseBundle = Object.freeze({ packages: [] });\n\n/**\n * A JupyterLite implementation of the jupyterlab_server licenses route\n */\nexport class Licenses implements ILicenses {\n  /**\n   * A GET handler for the licenses\n   */\n  async get(): Promise<ILicenseResponse> {\n    return {\n      bundles: {\n        ...(await this._getFederated()),\n        [this.appName]: await this._getAppLicenses(),\n      },\n    };\n  }\n\n  /**\n   * Get the app name (or default).\n   */\n  protected get appName(): string {\n    return PageConfig.getOption('appName') || 'JupyterLite';\n  }\n\n  /**\n   * Get the well-known URL of the app licenses.\n   */\n  protected get appLicensesUrl(): string {\n    return URLExt.join(PageConfig.getBaseUrl(), 'build', THIRD_PARTY_LICENSES);\n  }\n\n  /**\n   * Get the lab extension base url.\n   */\n  protected get labExtensionsUrl(): string {\n    return PageConfig.getOption('fullLabextensionsUrl');\n  }\n\n  /**\n   * Resolve the licenses for the app distribution itself, or the empty bundle.\n   */\n  async _getAppLicenses(): Promise<ILicenseBundle> {\n    let bundle = EMPTY_BUNDLE;\n\n    try {\n      const response = await fetch(this.appLicensesUrl);\n      bundle = response.json() as any;\n    } catch (err) {\n      console.warn('Could not resolve licenses for', this.appName);\n    }\n\n    return bundle;\n  }\n\n  /**\n   * Resolve the licenses for all federated extensions.\n   */\n  async _getFederated(): Promise<ILicenseBundles> {\n    const bundles: ILicenseBundles = {};\n    let federated: IFederatedExtension[];\n\n    try {\n      federated = JSON.parse(PageConfig.getOption('federated_extensions'));\n    } catch {\n      return bundles;\n    }\n\n    const promises = [] as Promise<any>[];\n\n    for (const ext of federated) {\n      promises.push(this._getOneFederated(ext, bundles));\n    }\n\n    try {\n      await Promise.all(promises);\n    } catch (err) {\n      console.warn('Error resolving licenses', err);\n    }\n\n    return bundles;\n  }\n\n  /**\n   * Update the bundles with the extension's licenses, or the empty bundle.\n   */\n  async _getOneFederated(ext: IFederatedExtension, bundles: ILicenseBundles) {\n    try {\n      const url = URLExt.join(\n        this.labExtensionsUrl,\n        ext.name,\n        'static',\n        THIRD_PARTY_LICENSES\n      );\n      const response = await fetch(url);\n      bundles[ext.name] = await response.json();\n    } catch {\n      console.warn('Could not resolve licenses for', ext);\n      bundles[ext.name] = EMPTY_BUNDLE;\n    }\n  }\n}\n"],"names":["THIRD_PARTY_LICENSES","ILicenses","Token","EMPTY_BUNDLE","Object","freeze","packages","Licenses","async","bundles","this","_getFederated","appName","_getAppLicenses","PageConfig","appLicensesUrl","URLExt","labExtensionsUrl","bundle","fetch","json","err","console","warn","federated","JSON","parse","promises","ext","push","_getOneFederated","Promise","all","url","name","response"],"sourceRoot":""}